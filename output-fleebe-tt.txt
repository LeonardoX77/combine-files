Archivos a procesar:
.____env_Dddd
.____env_example
.env
.eslintrc.js
.gitignore
README.md
components/BrandBackground.tsx
components/Calendar.tsx
components/DataGridLocal.tsx
components/DayBox.tsx
components/DefaultActionButtons.tsx
components/EmployeeDateFilter.tsx
components/ErrorBoundary.tsx
components/ErrorMessage.tsx
components/FormValidator/CustomValidator.tsx
components/Layout.tsx
components/LocalCalendar.tsx
components/LocalDevExCalendar.tsx
components/LocalForm.tsx
components/LocalGrid.tsx
components/Logo.tsx
components/Modal.tsx
components/Navbar.tsx
components/NoResults.tsx
components/SearchBox.tsx
components/Sidebar.tsx
components/SlideOver.tsx
components/StepIndicator.tsx
components/TimeInput.tsx
components/WeekDayBoxes.tsx
components/WorkingHoursForm.tsx
components/badges/ScoreBadge.tsx
components/charts/BaseChart.tsx
components/charts/ColumnChart.tsx
components/charts/PieChart.tsx
components/chat/AcceptCommunications.tsx
components/chat/AudioRecorder.tsx
components/chat/Chat.tsx
components/chat/CountdownTimer.tsx
components/chat/Dots.tsx
components/chat/Footer.tsx
components/chat/Header.tsx
components/chat/TermsAndConditions.tsx
components/chat/body/Body.module.css
components/chat/body/index.tsx
components/chat/context/ChatContext.tsx
components/chat/context/ChatProvider.tsx
components/chat/types.ts
components/chat/useChat.tsx
components/slider/Slider.tsx
components/track/Checking.tsx
components/track/CustomButton.tsx
components/track/Totem.tsx
constants/CalendarDayTypes.tsx
context/NotificationsComponentContext.tsx
declaration.d.ts
ecosystem.config.js
helpers/DateHelper.ts
helpers/Geolocation.ts
helpers/OptionsHelper.ts
helpers/TimeHelper.ts
hooks/useCookieConsentBanner.tsx
hooks/useLocalizedChat.tsx
hooks/useLocalizedCountries.tsx
hooks/useLocalizedFileUploader.tsx
hooks/useNetworkErrorHandler.tsx
hooks/useNotificationsComponent.tsx
hooks/useTermsAndConditionsModal.tsx
i18n.ts
middleware.ts
network-client.ts
next-env.d.ts
next.config.js
package.json
pages/401.tsx
pages/500.tsx
pages/_app.tsx
pages/_document.tsx
pages/api/[...slot].ts
pages/api/account/login.ts
pages/api/account/logout.ts
pages/api/account/refresh.ts
pages/api/copilot/form-completion/transcribe/index.ts
pages/api/file/[...slot].ts
pages/calendar/[...slug].tsx
pages/calendar/index.tsx
pages/company/[...slug].tsx
pages/company/details/[id].tsx
pages/company/index.tsx
pages/create-password.tsx
pages/event/[...slug].tsx
pages/event/index.tsx
pages/force-change-password.tsx
pages/forgot-password-success.tsx
pages/forgot-password.tsx
pages/index.tsx
pages/login.tsx
pages/profile.tsx
pages/register-confirmation.tsx
pages/register.tsx
pages/reports/index.tsx
pages/reset-password-confirmation.tsx
pages/reset-password.tsx
pages/track/index.tsx
pages/tracking/index.tsx
pages/user/[...slug].tsx
pages/user/details/[id].tsx
pages/user/index.tsx
pages/user/user-working-hours/[id].tsx
pages/working-hours/index.tsx
postcss.config.js
roles.ts
routes.ts
scripts/copy-files-linux.sh
scripts/copy-files-windows.ps1
server/proxy.ts
services/AccountService.ts
services/CalendarDayService.ts
services/CalendarService.ts
services/CompanyService.ts
services/EntryTypeService.ts
services/EventService.ts
services/EventTypeService.ts
services/FileService.ts
services/FrontUserService.ts
services/LanguageService.ts
services/QueryBuilderService.ts
services/RoleService.ts
services/TimeZoneService.ts
services/UserEntryService.ts
services/UserService.ts
services/UserWorkingHoursService.ts
services/WorkingHoursService.ts
stores/UserStore.ts
styles/forms.css
styles/globals.css
styles/variables.css
tailwind.config.js
tsconfig.json


### .____env_Dddd ###
# # LOCAL
# PROTOCOL=https
# PORT=3000
# # HOST=dev-timetracking-back.fleebecorporate.ai
# HOST=localhost:6002
# API_URL=$PROTOCOL://$HOST
# COOKIE_NAME=fusion-cookie
# NEXT_PUBLIC_GLOBAL_STATE_KEY=fusion-state
# # NEXT_PUBLIC_WEB_URL=dev-timetracking-front.fleebecorporate.ai
# NEXT_PUBLIC_WEB_URL=http://localhost:3000
# NEXT_PUBLIC_ALLOW_SELF_SIGNUP=true
# NAME_APP=DEV_Fleebee
# NODE_TLS_REJECT_UNAUTHORIZED=0
# NEXT_PUBLIC_DEVEXTREME_LICENSE_KEY="ewogICJmb3JtYXQiOiAxLAogICJjdXN0b21lcklkIjogIjVlNjQ4YmFiLWNmMWQtNDk5OS05ZGM5LWU1ZDg1NTIxNzg1YyIsCiAgIm1heFZlcnNpb25BbGxvd2VkIjogMjQxCn0=.Lu0URUsSME7NYsSut0hx58B94i5TyvbcgYNnlb88QZv+YdxnLRNmk/HgeRN9kSr4u0f5oFAFtZl6ORvIRiDoTQx3dZzL/dp4pZCDwSH8WjFPVvuloJOBLWf6EN4e2sO3D8LpOw=="


### .____env_example ###
# # LOCAL
# PROTOCOL=https
# PORT=3000
# HOST=localhost:61938
# API_URL=$PROTOCOL://$HOST
# COOKIE_NAME=fusion-cookie
# NEXT_PUBLIC_GLOBAL_STATE_KEY=fusion-state
# NEXT_PUBLIC_WEB_URL=http://localhost:3000
# NEXT_PUBLIC_ALLOW_SELF_SIGNUP=true
# NAME_APP=DEV_Fleebee
# NODE_TLS_REJECT_UNAUTHORIZED=0
# NEXT_PUBLIC_DEVEXTREME_LICENSE_KEY="ewogICJmb3JtYXQiOiAxLAogICJjdXN0b21lcklkIjogIjVlNjQ4YmFiLWNmMWQtNDk5OS05ZGM5LWU1ZDg1NTIxNzg1YyIsCiAgIm1heFZlcnNpb25BbGxvd2VkIjogMjQxCn0=.Lu0URUsSME7NYsSut0hx58B94i5TyvbcgYNnlb88QZv+YdxnLRNmk/HgeRN9kSr4u0f5oFAFtZl6ORvIRiDoTQx3dZzL/dp4pZCDwSH8WjFPVvuloJOBLWf6EN4e2sO3D8LpOw=="


### .env ###
# LOCAL
PROTOCOL=https
PORT=3000
APP_HOST=localhost:61938
API_URL=https://localhost:61938
COOKIE_NAME=fusion-cookie
NEXT_PUBLIC_GLOBAL_STATE_KEY=fusion-state
NEXT_PUBLIC_WEB_URL=http://localhost:3000
NEXT_PUBLIC_ALLOW_SELF_SIGNUP=true
NAME_APP=DEV_Fleebee
NODE_TLS_REJECT_UNAUTHORIZED=0
NEXT_PUBLIC_DEVEXTREME_LICENSE_KEY="ewogICJmb3JtYXQiOiAxLAogICJjdXN0b21lcklkIjogIjVlNjQ4YmFiLWNmMWQtNDk5OS05ZGM5LWU1ZDg1NTIxNzg1YyIsCiAgIm1heFZlcnNpb25BbGxvd2VkIjogMjQxCn0=.Lu0URUsSME7NYsSut0hx58B94i5TyvbcgYNnlb88QZv+YdxnLRNmk/HgeRN9kSr4u0f5oFAFtZl6ORvIRiDoTQx3dZzL/dp4pZCDwSH8WjFPVvuloJOBLWf6EN4e2sO3D8LpOw=="


### .eslintrc.js ###
module.exports = {
  extends: 'next',
  root: true,
}


### .gitignore ###
node_modules
.next
.env
tsconfig.tsbuildinfo
.DS_Store


### README.md ###
# Introduction 
TODO: Give a short introduction of your project. Let this section explain the objectives or the motivation behind this project. 

# Getting Started
TODO: Guide users through getting your code up and running on their own system. In this section you can talk about:
1.	Installation process
2.	Software dependencies
3.	Latest releases
4.	API references

# Build and Test
TODO: Describe and show how to build your code and run the tests. 

# Contribute
TODO: Explain how other users and developers can contribute to make your code better. 

If you want to learn more about creating good readme files then refer the following [guidelines](https://docs.microsoft.com/en-us/azure/devops/repos/git/create-a-readme?view=azure-devops). You can also seek inspiration from the below readme files:
- [ASP.NET Core](https://github.com/aspnet/Home)
- [Visual Studio Code](https://github.com/Microsoft/vscode)
- [Chakra Core](https://github.com/Microsoft/ChakraCore)

### components/BrandBackground.tsx ###
import Image from "next/image";
import BgImage from "../public/bg-login.png";

const BrandBackground = () => {
  return (
    <div className="tw-relative tw-hidden tw-w-0 tw-flex-1 lg:tw-block tw-bg-primary-200">
      <Image
        alt="login background"
        className="tw-absolute tw-inset-0 tw-h-full tw-w-full tw-object-cover"
        src={BgImage}
      />
    </div>
  );
};

export default BrandBackground;


### components/Calendar.tsx ###
import { classNames, DateHelper } from "@fusion/utils";
import { useEffect, useState } from "react";
import { useTranslation } from "react-i18next";
import { LocalCalendar } from "./LocalCalendar";

export type MultipleRangeValues = {
  id: string;
  singleDayId: string;
  name: string;
  startDate: Date;
  endDate?: Date;
  rangeColorClass: string;
  shownDays?: number[];
};

type CalendarProps = {
  ranges?: MultipleRangeValues[];
  onValueChange?:
    | ((value: Array<Date | number | string> | Date | number | string) => void)
    | undefined;
};

interface CustomCellRenderType {
  date: Date;
  text: string;
  rangeColorClass: string;
}

const Calendar: React.FC<CalendarProps> = (props) => {
  const { ranges, onValueChange } = props;
  const [year, setYear] = useState(new Date().getFullYear());
  const { t } = useTranslation("UserWorkingHoursScreen");

  const renderCalendars = () => {
    return Array.from({ length: 12 }, (_, index) => {
      const monthDate = new Date(year, index, 1);
      const endOfMonth = new Date(
        new Date().getFullYear(),
        index + 1,
        0, //this give the last day of the month
        23,
        55
      );

      const filterDates = (
        allDates: MultipleRangeValues[],
        index: number
      ): MultipleRangeValues[] => {
        // Create a date object for the first and last day of the specified month
        const monthDate = new Date(new Date().getFullYear(), index, 1, 0);
        const startOfMonth = monthDate;

        const defaultValueCalendarObject = {
          id: "1",
          singleDayId: "",
          name: "",
          startDate: new Date(year, index, 12, 1),
          endDate: new Date(year, index, 13, 1),
          rangeColorClass: "tw-bg-transparent tw-text-gray-400",
          shownDays: [0, 1, 2, 3, 4, 5, 6],
        };
        // Filter the ranges that overlap with the specified month
        const overlappingRanges = allDates.filter((range) => {
          const rangeStart = range.startDate;
          const rangeEnd = range.endDate || range.startDate;

          // Check if the range overlaps with the month
          return rangeStart <= endOfMonth && rangeEnd >= startOfMonth;
        });

        // If there are overlapping ranges, adjust their start and end dates
        if (overlappingRanges.length > 0) {
          const overlappingRangesWithoutDefault = overlappingRanges.map(
            (range) => {
              const {
                id,
                singleDayId,
                name,
                startDate,
                endDate,
                rangeColorClass,
                shownDays,
              } = range;
              let rangeStart = new Date(startDate);
              let rangeEnd =
                endDate != null ? new Date(endDate) : new Date(startDate);

              const isDifferentMonthOrYear =
                endDate &&
                (startDate.getMonth() !== endDate.getMonth() ||
                  startDate.getFullYear() !== endDate.getFullYear());

              if (isDifferentMonthOrYear) {
                rangeStart = new Date(endDate);
                rangeStart.setHours(1);
                rangeEnd = new Date(endDate);
              } else {
                rangeEnd = rangeEnd || new Date(startDate);
              }

              if (rangeStart.getMonth() === index) {
                //this case is when the selected value day is 01, so the range cant start the last day of the past month bacause the localcalendar makes a bug of dragging,
                //so to make a compatible range and paint the day in the calendar i put a hours range, only for day 1 case, in the rest of the days always the range is start
                // in the previus day and end in actual date value, so is a range into 2 days to pait the end date, is strange but the calendar paint with ranges.
                if (rangeStart.getDate() === 1) {
                  rangeEnd.setHours(23);
                  rangeStart.setHours(0);
                } else {
                  rangeStart = new Date(rangeStart.getTime() - 86400000);
                }
              } else {
                rangeStart = startOfMonth;
              }

              const overlappingReturnObject = {
                id,
                singleDayId,
                name,
                startDate: rangeStart,
                endDate: rangeEnd.getMonth() === index ? rangeEnd : endOfMonth,
                rangeColorClass,
                shownDays,
              };

              return overlappingReturnObject;
            }
          );

          if (
            !overlappingRangesWithoutDefault.find(
              (r) => r?.startDate == new Date(year, index, 13, 1)
            )
          ) {
            overlappingRangesWithoutDefault.push(defaultValueCalendarObject);
          }

          return overlappingRangesWithoutDefault;
        } else {
          // Return the default object if no overlaps
          return [defaultValueCalendarObject];
        }
      };

      return (
        <div
          key={index}
          className="tw-border tw-border-gray-300 tw-rounded-lg tw-p-4 tw-shadow-md tw-flex tw-flex-col tw-items-center tw-bg-white"
        >
          <h3 className="tw-text-center tw-mb-2">
            {monthDate.toLocaleString("default", { month: "long" })}
          </h3>
          <LocalCalendar
            min={monthDate}
            max={endOfMonth}
            onValueChange={onValueChange}
            value={filterDates(
              ranges ?? [
                {
                  id: "1",
                  singleDayId: "",
                  name: "",
                  startDate: monthDate,
                  rangeColorClass: "",
                  shownDays: [],
                },
              ],
              index
            )}
            firstDayOfWeek={1}
            cellRender={({
              text,
              date,
              rangeColorClass,
            }: CustomCellRenderType) => {
              const isCurrentMonth = date.getMonth() === index;
              const filteredRanges = filterDates(ranges ?? [], index);
              const isInShownDays = filteredRanges.some(
                (range) =>
                  range.shownDays && range.shownDays.includes(date.getDay())
              );

              if (!isInShownDays || !isCurrentMonth)
                return (
                  <span className="tw-bg-transparent tw-text-gray-300">
                    {text}
                  </span>
                );

              return (
                <span
                  className={classNames(
                    "tw-border tw-rounded-2xl tw-bg-blue-400",
                    rangeColorClass
                  )}
                >
                  {text}
                </span>
              );
            }}
            hideHeader
            selectionMode="multiple-range"
          />
        </div>
      );
    });
  };

  const handleYearChange = (sum: number) => {
    setYear((prevYear) => prevYear + sum);
  };

  return (
    <div className="tw-text-center">
      <div className="tw-mb-6">
        <button
          className="tw-bg-primary-500 tw-text-white tw-px-3 tw-py-1 tw-rounded tw-mr-2"
          onClick={() => handleYearChange(-1)}
        >
          {t("<")}
        </button>
        <span className="tw-text-xl tw-font-bold">{year}</span>
        <button
          className="tw-bg-primary-500 tw-text-white tw-px-3 tw-py-1 tw-rounded tw-ml-2"
          onClick={() => handleYearChange(1)}
        >
          {t(">")}
        </button>
      </div>
      <div className="tw-grid tw-grid-cols-1 sm:tw-grid-cols-2 xl:tw-grid-cols-3 tw-gap-5 lg:tw-grid-cols-2">
        {renderCalendars()}
      </div>
    </div>
  );
};

export default Calendar;


### components/DataGridLocal.tsx ###
import { createStore } from "devextreme-aspnet-data-nojquery";
import { DataGrid as DataGridDX } from "devextreme-react";
import {
    DataGridTypes,
    Export,
    FilterRow,
    HeaderFilter,
    Pager,
    SearchPanel,
    StateStoring,
} from "devextreme-react/data-grid";
import { exportDataGrid } from "devextreme/excel_exporter";
import { Workbook } from "exceljs";
import React, { useEffect } from "react";

export type DataGridProps<T extends {}[]> = {
    /**
     * Used when you need to render information without using the DevExtreme Loader
     */
    data?: T;
    /**
     * Used when you need to use the DevExtreme Loader
     */
    paginate?: boolean,
    url?: string;
    ActionButtonsComponent?: any;
    hideActionButtons?: boolean;
    deferLoading?: boolean;
    identifier?: string;
    sortBy?: string;
    sortDirection?: "Asc" | "Desc";
    clientSide?: boolean;
    allowedPageSizes?: (number | "all")[];
    stateStoring?: {
        enabled: boolean;
        storageKey: string;
    };
    enableRowAlternation?: boolean;
    allowColumnReorder?: boolean;
    /**
     * `true` if you want to let users change the size of each column. `false` for fixed size
     */
    allowColumnResizing?: boolean;
    allowColumnHiding?: boolean;
    showHeaderFilter?: boolean;
    showColumnChooser?: boolean;
    showFilterRow?: boolean;
    showSearchPanel?: boolean;
    allowExcelExport?: boolean;
    excelExportFilename?: string;
    excelExportWorksheetName?: string;
    locale?: {
        nameColumn?: {
            caption?: string;
        };
    };
    children?: JSX.Element | JSX.Element[];
    onOptionChanged?: (e: DataGridTypes.OptionChangedEvent) => void;
};

export const DataGridLocal = <T extends {}[]>(props: DataGridProps<T>) => {
    const {
        children,
        url,
        data,
        paginate,
        stateStoring,
        enableRowAlternation = true,
        showHeaderFilter = true,
        showColumnChooser = true,
        showFilterRow = true,
        showSearchPanel = true,
        allowColumnReorder = true,
        allowColumnHiding = true,
        allowColumnResizing = true,
        allowExcelExport = true,
        excelExportFilename = "export.xlsx",
        excelExportWorksheetName = "Main sheet",
        locale = {
            nameColumn: {
                caption: "Name",
            },
        },
        allowedPageSizes = [5, 10, 50, 100, "all"],
        onOptionChanged,
    } = props;

    const dataSource = createStore({
        loadUrl: url,
        onBeforeSend: (method: any, ajaxOptions: any) => {
            ajaxOptions.headers = {
                ...ajaxOptions.headers,
                "Content-Type": "application/json",
            };
        }
    });

    const onExporting = async (e: DataGridTypes.ExportingEvent) => {
        const workbook = new Workbook();
        const worksheet = workbook.addWorksheet(excelExportWorksheetName);

        await exportDataGrid({
            component: e.component,
            worksheet,
            autoFilterEnabled: true,
        });

        const buffer = await workbook.xlsx.writeBuffer();

        saveAs(new Blob([buffer], { type: "application/octet-stream" }), excelExportFilename);
    };

    const saveAs = (blob:any, fileName: string) => {
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);

        link.href = url;
        link.download = fileName;

        link.click();

        URL.revokeObjectURL(url);
        link.remove();
    };
    
    useEffect(() => {
        document.querySelector("body")?.classList.add("dx-viewport");
    }, []);

    return (
        <DataGridDX
            columnChooser={{
                enabled: showColumnChooser,
            }}
            cacheEnabled={false}
            columnHidingEnabled={allowColumnHiding}
            columnResizingMode={"nextColumn"}
            showBorders={true}
            columnAutoWidth={true}
            allowColumnResizing={allowColumnResizing}
            allowColumnReordering={allowColumnReorder}
            remoteOperations={true}
            dataSource={dataSource}
            rowAlternationEnabled={enableRowAlternation}
            onExporting={onExporting}
            onOptionChanged={onOptionChanged}
        >
            {showFilterRow ? <FilterRow visible={true}></FilterRow> : null}
            {showSearchPanel ? (
                <SearchPanel visible={showSearchPanel}></SearchPanel>
            ) : null}
            {stateStoring ? (
                <StateStoring
                    enabled={stateStoring.enabled}
                    storageKey={stateStoring.storageKey}
                ></StateStoring>
            ) : (
                <StateStoring enabled={false}></StateStoring>
            )}
            <HeaderFilter visible={showHeaderFilter}></HeaderFilter>
            {/* Improve using dayjs to get a better formatting for the date */}
            <Export
                enabled={allowExcelExport}
                allowExportSelectedData={allowExcelExport}
            ></Export>
            {paginate && <Pager
                visible={true}
                allowedPageSizes={allowedPageSizes}
                displayMode="full"
                showPageSizeSelector={true}
                showInfo={true}
                showNavigationButtons={true}
            ></Pager>}
            {children}
        </DataGridDX>
    );
};


### components/DayBox.tsx ###
import React from "react";

export type WeekDayBoxesProps = {
  label: string;
  classNames?: string;
  active?: boolean;
};

export const DayBox = (props: WeekDayBoxesProps) => {
  const { label, classNames, active = true } = props;

  return (
    <p
      className={`tw-inline-flex tw-justify-center tw-items-center tw-rounded-md tw-border tw-border-transparent tw-text-sm tw-font-medium tw-shadow-sm ${
        !active
          ? "tw-bg-white tw-border-primary-600 tw-text-primary-600"
          : "tw-text-white tw-bg-primary-600"
      } tw-px-0 tw-py-0 ${classNames}`}
    >
      {label}
    </p>
  );
};


### components/DefaultActionButtons.tsx ###
import { ActionButton } from "@fusion/action-button";
import { DecisionButton } from "@fusion/decision-button";
import { RedirectButton } from "@fusion/redirect-button";
import { DataGridColumnInformation, LinkProps } from "@fusion/utils";
import { EyeIcon, PencilIcon, TrashIcon } from "@heroicons/react/20/solid";
import React from "react";

export type DefaultActionButtonsProps = {
  info: DataGridColumnInformation<null>;
  entityName: string;
  onDeleteConfirmed: () => Promise<void>;
  hideEdit?: boolean;
  locale?: {
    tooltips?: {
      edit?: string;
      details?: string;
      delete?: string;
    };
    delete?: {
      modalTitle?: string;
      confirmLabel?: string;
      cancelLabel?: string;
    };
  };
  children?:
    | React.ReactElement<typeof ActionButton>
    | React.ReactElement<typeof ActionButton>[];
  LinkComponent: React.ComponentType<LinkProps>;
  showDeleteButton?: boolean;
  showEditButton?: boolean;
  showDetailsButton?: boolean;
};

export const DefaultActionButtons = (props: DefaultActionButtonsProps) => {
  const {
    info,
    children,
    onDeleteConfirmed,
    entityName,
    LinkComponent,
    hideEdit = false,
    locale = {
      tooltips: {
        edit: "Edit",
        details: "Details",
        delete: "Delete",
      },
      delete: {
        modalTitle: "Are you sure you want to delete {0}",
        confirmLabel: "Confirm",
        cancelLabel: "Cancel",
      },
    },
    showDeleteButton = true,
    showEditButton = true,
    showDetailsButton = true,
  } = props;

  return (
    <div className="tw-flex tw-items-center tw-justify-start">
      {showDetailsButton && (
        <RedirectButton
          LinkComponent={LinkComponent}
          tooltip={locale.tooltips?.details}
          _buttonProps={{
            variant: "tertiary",
          }}
          iconLeft={
            <EyeIcon className="tw-h-5 tw-w-5" fill="#799452"></EyeIcon>
          }
          url={`/${entityName}/details/${info.row.data.id}`}
        ></RedirectButton>
      )}
      {showEditButton && (
        <RedirectButton
          LinkComponent={LinkComponent}
          tooltip={locale.tooltips?.edit}
          _buttonProps={{
            variant: "tertiary",
          }}
          iconLeft={
            <PencilIcon className="tw-h-5 tw-w-5" fill="#799452"></PencilIcon>
          }
          url={`/${entityName}/edit/${info.row.data.id}`}
        ></RedirectButton>
      )}
      {showDeleteButton && (
        <DecisionButton
          tooltip={locale.tooltips?.delete}
          _buttonProps={{
            variant: "tertiary",
          }}
          iconLeft={
            <TrashIcon className="tw-h-5 tw-w-5" fill="#799452"></TrashIcon>
          }
          modal={{
            title: locale.delete?.modalTitle
              ? locale.delete?.modalTitle.replace("{0}", info.row.data.name)
              : "",
            onConfirm: async () => {
              await onDeleteConfirmed();
              info.component.refresh();
            },
            confirmLabel: locale?.delete?.confirmLabel,
            cancelLabel: locale?.delete?.cancelLabel,
          }}
        ></DecisionButton>
      )}

      {children}
    </div>
  );
};


### components/EmployeeDateFilter.tsx ###
import React, { useEffect, useRef, useState } from "react";
import { useTranslation } from "react-i18next";
import {
  Button,
  Form,
  FormLabel,
  Input,
  Select,
  useServerSideErrors,
} from "@fusion/ui";
import UserEntryService from "../services/UserEntryService";
import { EmployeesOption, FormValues } from "../pages/reports";
import useNetworkErrorHandler from "../hooks/useNetworkErrorHandler";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useUserStore } from "../stores/UserStore";
import {roles} from "../roles";
import {DateHelper} from "../helpers/DateHelper";

export type EmployeeDateFilterProps = {
  setAbsencesUrl: React.Dispatch<React.SetStateAction<string | undefined>>;
};

export const EmployeeDateFilter = (props: EmployeeDateFilterProps) => {
  const { setAbsencesUrl } = props;

  const store = useUserStore();

  const isHumanCapital =
      store.roles && store.roles.includes(roles.FrontFrontHumanCapital);

  const { t } = useTranslation("EmployeeDateFilter");
  const [employees, setEmployees] = useState<EmployeesOption[]>();
  const firstMount = useRef<boolean>(true);
  const [formData, setFormData] = useState<FormValues>();
  const { handleError } = useNetworkErrorHandler();
  const baseAbsencesUrlReport = `/api/event/get-user-event?`;
  const {
    errors,
    setErrors,
    clearErrors: clearServerErrors,
  } = useServerSideErrors<FormValues>();

  const getEmployees = async () => {
    try {
      const result = await UserEntryService.getUserReportList();
      let employeesList = result.map((c) => ({
        value: c.value ?? "",
        name: c.text,
      }));
      if (isHumanCapital){
        const all   = {
          value: "",
          name: t("EmployeesAllPlaceholder")}
        employeesList =[all, ...employeesList]
      }
      setEmployees(employeesList);
    } catch (error) {
      handleError(error);
    }
  };

  useEffect(() => {
    if (firstMount.current) {
      firstMount.current = false;
      getEmployees();
    }
  }, []);

  useEffect(() => {
    const culture = useUserStore.getState().preferredLanguage || "es";
    if (formData && formData?.employee !== "") {
      let url = `${baseAbsencesUrlReport}&userId=${formData?.employee}&dateStart=
      ${formData?.dateFrom}&dateEnd=${formData?.dateTo}&culture=${culture}`;
      setAbsencesUrl(url);
    } else {
      setAbsencesUrl(
        `${baseAbsencesUrlReport}&employee=0&dateFrom=1000-01-01&dateTo=1000-01-01&culture=${culture}`
      );
    }
    console.log(formData, "formData");
  }, [formData]);

  const validationSchema = z.object({
    dateFrom: z.string({
      required_error: t("DateFromRequiredValidationMessage"),
    }),
    dateTo: z.string({
      required_error: t("DateToRequiredValidationMessage"),
    }),
    employee: z.string({
      required_error: t("EmployeeRequiredValidationMessage"),
    }),
  });

  type ValidationSchema = z.infer<typeof validationSchema>;
  const {
    control,
    handleSubmit,
    formState: { errors: clientErrors, isSubmitting },
    clearErrors: clearClientErrors,
  } = useForm<ValidationSchema>({
    defaultValues: {
      employee: isHumanCapital && employees?employees[0].name:"",
    },
    resolver: zodResolver(validationSchema),
  });

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearServerErrors();
      try {
        setFormData({
          dateFrom: DateHelper.toLocalISOString(new Date(data.dateFrom)),
          dateTo: DateHelper.toLocalISOString(new Date(data.dateTo)),
          employee: data.employee,
        });
      } catch (error) {
        setErrors(error);
        console.error("An unexpected error happened:", error);
      }
    },
    (error, event) => {
      event?.preventDefault();
      handleError(error);
    }
  );

  return (
    <Form>
      <div className="tw-grid tw-grid-cols-4 tw-gap-4">
        <Select
          multiple={false}
          LabelComponent={<FormLabel>{t("EmployeesLabel")}</FormLabel>}
          name="employee"
          placeholder={t("EmployeesPlaceholder")}
          control={control}
          errors={errors}
          searchEnabled={false}
          displayExpr={"name"}
          valueExpr={"value"}
          items={employees}
        />
        <Input
          name="dateFrom"
          defaultValue={formData?.dateFrom}
          control={control}
          type="date"
          errors={errors}
          required
          LabelComponent={<FormLabel>{t("DateFromLabel")}</FormLabel>}
        ></Input>
        <Input
          name="dateTo"
          defaultValue={formData?.dateTo}
          control={control}
          type="date"
          errors={errors}
          required
          LabelComponent={<FormLabel>{t("DateToLabel")}</FormLabel>}
        ></Input>
        <div>
          <Button
            onClick={onSubmit}
            disabled={isSubmitting}
            loading={isSubmitting}
          >
            {t("Search")}
          </Button>
        </div>
      </div>
    </Form>
  );
};


### components/ErrorBoundary.tsx ###
import { Component, ErrorInfo, ReactNode } from "react";
import ErrorMessage from "./ErrorMessage";

type ErrorBoundaryProps = {
  children?: ReactNode;
};

type ErrorBoundaryState = {
  hasError: boolean;
};

class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  public state: ErrorBoundaryState = {
    hasError: false,
  };

  public static getDerivedStateFromError(_: Error): ErrorBoundaryState {
    // Update state so the next render will show the fallback UI.
    return { hasError: true };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Use error logging service here.
    console.error("Uncaught error:", error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <ErrorMessage
          onBackTapped={() => {
            this.setState({ hasError: false });
          }}
        />
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;


### components/ErrorMessage.tsx ###
import { Button } from "@fusion/ui";
import Image from "next/image";
import { useRouter } from "next/router";
import { useTranslation } from "react-i18next";
import Logo from "../public/logo.png";
import BrandBackground from "./BrandBackground";

type ErrorMessageProps = {
  onBackTapped?: () => void;
};

export default function ErrorMessage({ onBackTapped }: ErrorMessageProps) {
  const { t } = useTranslation("Error");
  const router = useRouter();

  return (
    <div className="tw-flex tw-min-h-full">
      <div className="tw-flex tw-flex-1 tw-flex-col tw-justify-center tw-py-12 tw-px-4 sm:tw-px-6 lg:tw-flex-none lg:tw-px-20 xl:tw-px-24">
        <div className="tw-mx-auto tw-w-full">
          <Image
            className="tw-h-12 tw-w-auto tw-object-contain"
            src={Logo}
            alt="Logo"
          />
          <h1 className="tw-mt-4 tw-text-3xl tw-font-bold tw-tracking-tight tw-text-gray-900 sm:tw-text-5xl tw-text-center">
            {t("Title")}
          </h1>
          <p className="tw-mt-6 tw-text-base tw-leading-7 tw-text-gray-600 tw-text-center">
            {t("Subtitle")}
          </p>
          <div className="tw-mt-8">
            <div className="tw-mt-6 tw-flex tw-justify-center">
              <Button
                onClick={() => {
                  onBackTapped && onBackTapped();
                  router.push("/");
                }}
                className="tw-text-sm tw-font-semibold tw-ml-2 tw-border-transparent tw-border-0 tw-shadow-transparent tw-text-primary-600 hover:tw-text-primary-500 tw-flex tw-justify-center hover:tw-bg-transparent focus:tw-ring-transparent"
                variant="tertiary"
              >
                {`â¬… ${t("BackToHome")}`}
              </Button>
            </div>
          </div>
        </div>
      </div>
      <BrandBackground />
    </div>
  );
}


### components/FormValidator/CustomValidator.tsx ###
import React from "react";
import {FormError} from "@fusion/form-error";

export type FormServerSideErrorsProps = {
    errors?: { [key: string]: string[] | string };
    fieldKey?: string;
};

export const CustomFormServerSideErrors: React.FC<FormServerSideErrorsProps> = (
    props
) => {
    const { errors, fieldKey } = props;

    if (!errors) return null;

    // If no specific fieldKey, render all errors
    if (!fieldKey || fieldKey === "") {
        return (
            <>
                {Object.keys(errors).map((key) => {
                    const errorMessages = errors[key];
                    if (typeof errorMessages === "string") {
                        return <FormError key={key} message={errorMessages} />;
                    } else {
                        return (errorMessages as string[]).map((message, index) => (
                            <FormError key={`${key}-${index}`} message={message} />
                        ));
                    }
                })}
            </>
        );
    }

    // If specific fieldKey is provided, render only its errors
    const lowercasedKey = fieldKey.toLowerCase();
    if (!errors[lowercasedKey]) return null;

    if (typeof errors[lowercasedKey] === "string") {
        return <FormError key={fieldKey} message={errors[lowercasedKey] as string} />;
    }

    return (
        <>
            {(errors[lowercasedKey] as string[]).map((error, index) => (
                <FormError key={`${fieldKey}-${index}`} message={error}></FormError>
            ))}
        </>
    );
};


### components/Layout.tsx ###
import { Button, HamburguerMenu, ToastContainer, useToast } from "@fusion/ui";
import { classNames } from "@fusion/utils";
import {
  ArrowRightOnRectangleIcon,
  ArrowLeftOnRectangleIcon,
} from "@heroicons/react/20/solid";

import {
  UserIcon,
  BuildingOfficeIcon,
  ClockIcon,
  ClipboardDocumentListIcon,
  CalendarDaysIcon,
  DeviceTabletIcon,
  ChartBarIcon,
  DocumentTextIcon,
} from "@heroicons/react/24/outline";
import Link from "next/link";
import { useRouter } from "next/router";
import { useEffect, useState } from "react";
import { useTranslation } from "react-i18next";
import { publicRoutes, routes } from "../routes";
import AccountService from "../services/AccountService";
import { useUserStore } from "../stores/UserStore";
import Logo from "./Logo";
import { Navbar } from "./Navbar";
import esMessages from "../public/js/devextreme/localization/es.json";
import { locale, loadMessages } from "devextreme/localization";
import { menuItems } from "../roles";
import Totem from "./track/Totem";
import { roles as rolesEnum } from "../roles";
import "react-toastify/dist/ReactToastify.css";
import { Modal } from "./Modal";

loadMessages(esMessages);
let preferredLanguage = useUserStore.getState().preferredLanguage || "es";
locale(preferredLanguage);

export default function Layout({ children }: { children: React.ReactNode }) {
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const store = useUserStore();
  const [email, setEmail] = useState<string>();
  const router = useRouter();
  const [showLogout, setShowLogout] = useState(false);
  const [code, setCode] = useState("");

  const { t } = useTranslation("Layout");
  const toast = useToast();

  const navigation = [
    { name: "Company", href: routes.COMPANY, icon: BuildingOfficeIcon },
    { name: "Calendar", href: routes.CALENDAR, icon: CalendarDaysIcon },
    { name: "Reports", href: routes.REPORTS, icon: DeviceTabletIcon },
    { name: "User", href: routes.USER, icon: UserIcon },
    { name: "Track", href: routes.TRACK, icon: ClockIcon },
    {
      name: "WorkingHours",
      href: routes.WORKINGHOURS,
      icon: ClipboardDocumentListIcon,
    },
    { name: "Tracking", href: routes.TRACKING, icon: ChartBarIcon },
    { name: "Event", href: routes.EVENT, icon: DocumentTextIcon },
    {
      name: "UserAssignedWorkingHours",
      href: routes.USERWORKINHOURS + "/" + store.id,
      icon: ClipboardDocumentListIcon,
    },
  ];

  useEffect(() => {
    setEmail(store.email);
  }, []);

  const logout = async (checkRole = true) => {
    if (
      store?.roles?.includes(rolesEnum.FrontFrontManualSigning) &&
      checkRole
    ) {
      setCode("");
      setShowLogout(true);
      return;
    }
    try {
      await AccountService.logout(code);
      setShowLogout(false);
      router.push("/login");
    } catch {
      const toastMessage = t("LogoutTotemInvalidCode");

      toast(toastMessage, {
        position: "bottom-center",
        autoClose: 3000,
        hideProgressBar: true,
        closeOnClick: true,
        pauseOnHover: false,
        draggable: false,
        progress: undefined,
        theme: "colored",
        type: "error",
      });
    } finally {
      setCode("");
    }
  };

  const logoutTotem = async () => {
    await logout(false);
  };

  const currentPath = router.asPath;

  // Only show layout if the route is not public
  const includeLayout =
    publicRoutes.find((p) => p.includes(router.pathname.split("?")[0])) ===
      undefined || router.pathname === "/";

  if (!includeLayout) {
    return <>{children}</>;
  }

  const showItem = (name: string): boolean => {
    const itemReference = menuItems.find((item) => item.menuItem === name);
    if (!itemReference) {
      return false;
    }
    return store.roles
      ? store.roles.some((role: string) =>
          itemReference.rolesAllowed.includes(role)
        )
      : false;
  };

  return (
    <>
      <div className="tw-flex tw-h-full tw-bg-[#f7f7f7]">
        <Navbar.Mobile show={sidebarOpen} onClick={() => setSidebarOpen(false)}>
          <Navbar.Logo>
            <Logo></Logo>
          </Navbar.Logo>
          <Navbar.Links>
            {navigation.map(
              (item) =>
                showItem(item.name) && (
                  <Link
                    key={item.name}
                    href={item.href}
                    className={classNames(
                      currentPath.includes(item.href)
                        ? "tw-bg-primary-50 tw-text-gray-900"
                        : "tw-text-gray-400 hover:tw-text-gray-900",
                      "tw-group tw-flex tw-items-center tw-px-2 tw-py-4 tw-text-sm tw-font-medium tw-rounded-md"
                    )}
                  >
                    <item.icon
                      className={classNames(
                        currentPath.includes(item.href)
                          ? "tw-text-gray-900 group-hover:tw-text-gray-900"
                          : "tw-text-gray-400 group-hover:tw-text-gray-900",
                        "tw-mr-3 tw-flex-shrink-0 tw-h-8 tw-w-8"
                      )}
                      aria-hidden="true"
                    />

                    <span
                      className={classNames("tw-flex-1 tw-text-[16px] tw-px-4")}
                    >
                      {t(item.name)}
                    </span>
                  </Link>
                )
            )}
          </Navbar.Links>
          <Navbar.Footer>
            <div className="tw-flex-1">
              <p className="tw-text-base tw-font-medium tw-text-gray-700 tw-break-all">
                {store.email}
              </p>

              <Link href="/profile">
                <p className="tw-text-sm tw-font-medium tw-text-gray-700 hover:tw-text-black">
                  {t("ManageAccountLabel")}
                </p>
              </Link>
            </div>
            <div
              className="tw-cursor-pointer"
              onClick={async () => await logout()}
            >
              <ArrowRightOnRectangleIcon
                className={
                  "tw-text-gray-700 hover:tw-text-gray-900 tw-mr-3 tw-flex-shrink-0 tw-h-6 tw-w-6"
                }
                aria-hidden="true"
              />
            </div>
          </Navbar.Footer>
        </Navbar.Mobile>

        {/* Static sidebar for desktop */}
        <Navbar>
          <Navbar.Logo>
            <Logo></Logo>
          </Navbar.Logo>
          <Navbar.Links>
            {navigation.map(
              (item, index) =>
                showItem(item.name) && (
                  <Link
                    key={`${item.name}-${index}`}
                    href={item.href}
                    className={classNames(
                      currentPath === item.href
                        ? "tw-bg-primary-50 tw-text-gray-900"
                        : "tw-text-gray-400 hover:tw-text-gray-900",
                      "tw-group tw-flex tw-items-center tw-px-2 tw-py-4 tw-text-sm tw-font-medium tw-rounded-md"
                    )}
                  >
                    <item.icon
                      className={classNames(
                        currentPath === item.href
                          ? "tw-text-gray-900 group-hover:tw-text-gray-900"
                          : "tw-text-gray-400 group-hover:tw-text-gray-900",
                        "tw-mr-3 tw-flex-shrink-0 tw-h-8 tw-w-8"
                      )}
                      aria-hidden="true"
                    />
                    <span
                      className={classNames("tw-flex-1 tw-text-[16px] tw-px-4")}
                    >
                      {t(item.name)}
                    </span>
                  </Link>
                )
            )}
          </Navbar.Links>

          <Navbar.Footer>
            <div className="tw-flex-1">
              <p className="tw-text-sm tw-font-medium tw-text-gray-700 tw-break-all">
                {email}
              </p>
              <Link href="/profile">
                <p className="tw-text-xs tw-font-medium tw-text-gray-700 hover:tw-text-black">
                  {t("ManageAccountLabel")}
                </p>
              </Link>
            </div>
            <div
              className="tw-cursor-pointer"
              onClick={async () => await logout()}
            >
              <ArrowRightOnRectangleIcon
                className={
                  "tw-text-gray-700 hover:tw-text-gray-700 tw-ml-3 tw-flex-shrink-0 tw-h-6 tw-w-6"
                }
                aria-hidden="true"
              />
            </div>
          </Navbar.Footer>
        </Navbar>

        <div className="tw-flex tw-min-w-0 tw-flex-1 tw-flex-col tw-overflow-hidden">
          <div className="lg:tw-hidden">
            <div className="tw-flex tw-items-center tw-justify-between tw-border-b tw-border-white tw-bg-white tw-px-4 tw-py-1.5">
              <HamburguerMenu
                onClick={() => setSidebarOpen(true)}
              ></HamburguerMenu>
            </div>
          </div>
          <div className="tw-relative tw-z-0 tw-flex tw-flex-1 tw-overflow-hidden">
            <main className="tw-relative tw-z-0 tw-flex-1 tw-overflow-y-auto focus:tw-outline-none">
              {/* Start main area*/}
              <div className="tw-absolute tw-inset-0 tw-py-6 tw-px-4 sm:tw-px-6 lg:tw-px-8 lg:tw-container tw-pt-20">
                {children}
              </div>
              {/* End main area */}
            </main>
          </div>
        </div>

        <Modal
          IconComponent={
            <ArrowLeftOnRectangleIcon
              className="tw-h-6 tw-w-6 tw-text-red-600"
              aria-hidden="true"
            />
          }
          FooterComponent={
            <div className="tw-flex tw-justify-end tw-gap-2 tw-py-2 tw-px-6 tw-bg-gray-50">
              <Button
                variant="secondary"
                onClick={() => {
                  setShowLogout(false);
                }}
              >
                {t("LogoutCancel")}
              </Button>
              <Button
                variant="primary"
                className="disabled:tw-bg-gray-200"
                disabled={code.length < 4}
                onClick={logoutTotem}
              >
                {t("LogoutConfirm")}
              </Button>
            </div>
          }
          isOpen={showLogout}
          onClose={() => {
            setShowLogout(false);
          }}
          title={t("LogoutTotem")}
        >
          <div>
            <Totem
              isLogout={true}
              onChangeCode={(newCode) => {
                setCode(newCode);
              }}
            />
          </div>
        </Modal>
        <ToastContainer />
      </div>
    </>
  );
}


### components/LocalCalendar.tsx ###
import { DateHelper } from "@fusion/utils";
import DevExCalendar, { ICalendarOptions } from "devextreme-react/calendar";
import React, { ReactNode, useEffect } from "react";

//#region Default calendar types
type DefaultValue = string | number | Date | (string | number | Date)[];
type DefaultCellRenderType = (...params: any) => React.ReactNode;

type DefaultCalendarProps = ICalendarOptions & {
  hideHeader?: boolean;
  hideLeftArrow?: boolean;
  hideRightArrow?: boolean;
  currentDate?: Date;
};
//#endregion

//#region Custom calendar types
export type MultipleRangeValue = {
  startDate?: Date;
  endDate?: Date;
  rangeColorClass: string;
};

export type CustomValue = DefaultValue | MultipleRangeValue[];

export type CustomCellRenderType = (cell: {
  date: Date;
  text: string;
  rangeColorClass: string;
}) => ReactNode;

export type CalendarProps =
  | DefaultCalendarProps
  | (Omit<
      DefaultCalendarProps,
      | "cellRender"
      | "defaultValue"
      | "defaultZoomLevel"
      | "selectionMode"
      | "value"
      | "zoomLevel"
    > & {
      cellRender?: CustomCellRenderType;
      defaultValue?: Array<MultipleRangeValue>;
      defaultZoomLevel?: "month";
      value?: Array<MultipleRangeValue>;
      selectionMode?: "multiple-range";
      zoomLevel?: "month";
    });
//#endregion

export const LocalCalendar: React.FC<CalendarProps> = (props) => {
  const {
    currentDate,
    cellRender,
    defaultValue,
    selectionMode = "single",
    value,
    hideHeader = false,
    hideLeftArrow = false,
    hideRightArrow = false,
    ...rest
  } = props;

  const getClassName = () => {
    let className = "calendar ";

    if (hideHeader) className += " hide-header";
    if (hideLeftArrow) className += " hide-left-arrow";
    if (hideRightArrow) className += " hide-right-arrow";

    return className;
  };

  const getValue = (value: CustomValue): DefaultValue => {
    if (selectionMode !== "multiple-range") return value as DefaultValue;

    const multipleRangeValues = value as Array<MultipleRangeValue>;

    if (multipleRangeValues[0]?.startDate)
      return DateHelper.getDatesArrayFromRange(
        multipleRangeValues[0].startDate,
        multipleRangeValues[multipleRangeValues.length - 1].endDate
      );

    return value as DefaultValue;
  };

  const isMultipleRangeMode = selectionMode === "multiple-range";

  return (
    <DevExCalendar
      selectionMode={isMultipleRangeMode ? "multiple" : selectionMode}
      defaultValue={defaultValue ? getValue(defaultValue) : undefined}
      value={value ? getValue(value) : undefined}
      cellRender={
        cellRender
          ? (cell) => {
              if (isMultipleRangeMode) {
                const rangeColorClass = getRangeColorClassByDate(
                  value as Array<MultipleRangeValue>,
                  cell.date
                );

                return cellRender({
                  date: cell.date,
                  text: cell.text,
                  rangeColorClass: rangeColorClass,
                });
              }
              return (cellRender as DefaultCellRenderType)(cell);
            }
          : undefined
      }
      className={getClassName()}
      {...rest}
    />
  );
};

const getRangeColorClassByDate = (
  rangeValues: Array<MultipleRangeValue>,
  date: Date
): string => {
  // Filter the rangeValues based on the date provided
  const range = rangeValues.filter(({ startDate, endDate }) => {
    // Ensure startDate is defined
    if (!startDate) return false;

    // If endDate is undefined, default to the last day of the month of startDate
    const actualEndDate =
      endDate || new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0);

    return DateHelper.isDateBetween(startDate, actualEndDate, date);
  })[0];

  // Return the appropriate color class or a default value
  return range ? range.rangeColorClass : "tw-bg-transparent tw-text-gray-400";
};


### components/LocalDevExCalendar.tsx ###
/*!
 * devextreme-react
 * Version: 24.1.4
 * Build date: Mon Jul 15 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-react
 */

import * as React from "react";
import { Ref, ReactElement } from "react";
import dxCalendar, { Properties } from "devextreme/ui/calendar";

import type {
  DisposingEvent,
  InitializedEvent,
  ValueChangedEvent,
} from "devextreme/ui/calendar";
type ReplaceFieldTypes<TSource, TReplacement> = {
  [P in keyof TSource]: P extends keyof TReplacement
    ? TReplacement[P]
    : TSource[P];
};
type ICalendarOptionsNarrowedEvents = {
  onDisposing?: (e: DisposingEvent) => void;
  onInitialized?: (e: InitializedEvent) => void;
  onValueChanged?: (e: ValueChangedEvent) => void;
};
type ICalendarOptions = React.PropsWithChildren<
  ReplaceFieldTypes<Properties, ICalendarOptionsNarrowedEvents> &
    IHtmlOptions & {
      cellRender?: (...params: any) => React.ReactNode;
      cellComponent?: React.ComponentType<any>;
      defaultValue?: Array<Date | number | string> | Date | number | string;
      defaultZoomLevel?: "century" | "decade" | "month" | "year";
      onValueChange?: (
        value: Array<Date | number | string> | Date | number | string
      ) => void;
      onZoomLevelChange?: (
        value: "century" | "decade" | "month" | "year"
      ) => void;
      currentDate?: Date;
    }
>;
interface CalendarRef {
  instance: () => dxCalendar;
}
declare const Calendar: (
  props: React.PropsWithChildren<ICalendarOptions> & {
    ref?: Ref<CalendarRef>;
  }
) => ReactElement | null;
export default Calendar;
export { Calendar };
export type { ICalendarOptions, CalendarRef };
import type * as CalendarTypes from "devextreme/ui/calendar_types";
import { IHtmlOptions } from "devextreme-react/cjs/core/component";
export { CalendarTypes };


### components/LocalForm.tsx ###
import { classNames } from "@fusion/utils";
import React, { PropsWithChildren } from "react";
import { DefaultValues, FieldValues } from "react-hook-form";

export type FormProps<TFieldValues extends FieldValues> =
  React.DetailedHTMLProps<
    React.FormHTMLAttributes<HTMLFormElement>,
    HTMLFormElement
  > & {
    description?: string;
    defaultValues?: DefaultValues<any>;
  };

export const LocalForm = <TFieldValues extends FieldValues>(
  props: PropsWithChildren<FormProps<TFieldValues>>
) => {
  const { title, description, onSubmit, className, children, ...otherProps } =
    props;

  return (
    <form
      className={classNames(
        "tw-space-y-8 tw-divide-y tw-divide-gray-200 tw-max-w-5xl",
        className ?? ""
      )}
      {...otherProps}
    >
      <div className="tw-space-y-8 tw-divide-y tw-divide-gray-200 tw-w-full">
        <div>
          <div>
            {title ? (
              <h3 className="tw-text-lg tw-font-medium tw-leading-6 tw-text-gray-900">
                {title}
              </h3>
            ) : null}

            <p className="tw-mt-1 tw-text-sm tw-text-gray-500">{description}</p>
          </div>
          <div className="tw-mt-4 tw-flex tw-flex-col tw-gap-2">{children}</div>
        </div>
      </div>
    </form>
  );
};


### components/LocalGrid.tsx ###
import { createStore, CustomStore } from "devextreme-aspnet-data-nojquery";
import { DataGrid as DataGridDX } from "devextreme-react";
import {
  Column,
  DataGridTypes,
  Export,
  FilterRow,
  HeaderFilter,
  Pager,
  SearchPanel,
  StateStoring,
} from "devextreme-react/data-grid";
import { exportDataGrid } from "devextreme/excel_exporter";
import { Workbook } from "exceljs";
import React, { useEffect, useRef, useState } from "react";

export type DataGridProps<T extends {}[]> = {
  /**
   * Used when you need to render information without using the DevExtreme Loader
   */
  data?: T;
  /**
   * Used when you need to use the DevExtreme Loader
   */
  url?: string;
  ActionButtonsComponent?: any;
  hideActionButtons?: boolean;
  deferLoading?: boolean;
  identifier?: string;
  sortBy?: string;
  sortDirection?: "Asc" | "Desc";
  clientSide?: boolean;
  allowedPageSizes?: (number | "all")[];
  stateStoring?: {
    enabled: boolean;
    storageKey: string;
  };
  enableRowAlternation?: boolean;
  allowColumnReorder?: boolean;
  /**
   * `true` if you want to let users change the size of each column. `false` for fixed size
   */
  allowColumnResizing?: boolean;
  allowColumnHiding?: boolean;
  showHeaderFilter?: boolean;
  showColumnChooser?: boolean;
  showFilterRow?: boolean;
  showSearchPanel?: boolean;
  allowExcelExport?: boolean;
  hoverStateEnabled?: boolean;
  excelExportFilename?: string;
  excelExportWorksheetName?: string;
  locale?: {
    nameColumn?: {
      caption?: string;
    };
  };
  children?: JSX.Element | JSX.Element[];
  onRowClick?: (e: DataGridTypes.RowClickEvent) => void;
  onOptionChanged?: (e: DataGridTypes.OptionChangedEvent) => void;
  onRowPrepared?: (e: DataGridTypes.RowPreparedEvent) => void;
};

export const LocalGrid = <T extends {}[]>(props: DataGridProps<T>) => {
  const {
    children,
    url,
    data,
    stateStoring,
    enableRowAlternation = true,
    showHeaderFilter = true,
    showColumnChooser = true,
    showFilterRow = true,
    showSearchPanel = true,
    allowColumnReorder = true,
    allowColumnHiding = true,
    allowColumnResizing = true,
    allowExcelExport = true,
    hoverStateEnabled = false,
    excelExportFilename = "export.xlsx",
    excelExportWorksheetName = "Main sheet",
    locale = {
      nameColumn: {
        caption: "Name",
      },
    },
    allowedPageSizes = [5, 10, 50, "all"],
    onOptionChanged,
    onRowClick,
    onRowPrepared,
  } = props;

  const readyCalled = useRef(false);
  const [dataSource, setDataSource] = useState<CustomStore>();
  useEffect(() => {
    if (!readyCalled.current) {
      readyCalled.current = true;
      GetDataURLCreateStore();
    }
  }, [readyCalled]);

  function GetDataURLCreateStore() {
    const store = createStore({
      loadUrl: url,
      onBeforeSend: (method, ajaxOptions) => {
        ajaxOptions.headers = {
          ...ajaxOptions.headers,
          "Content-Type": "application/json",
        };
      },
    });
    setDataSource(store);
  }

  function RowClick(e: DataGridTypes.RowClickEvent) {
    if (e && onRowClick) {
      onRowClick(e);
    }
    GetDataURLCreateStore();
  }

  const onExporting = async (e: DataGridTypes.ExportingEvent) => {
    const workbook = new Workbook();
    const worksheet = workbook.addWorksheet(excelExportWorksheetName);

    await exportDataGrid({
      component: e.component,
      worksheet,
      autoFilterEnabled: true,
    });

    const buffer = await workbook.xlsx.writeBuffer();
  };

  useEffect(() => {
    document.querySelector("body")?.classList.add("dx-viewport");
  }, []);

  return (
    <DataGridDX
      columnChooser={{
        enabled: showColumnChooser,
      }}
      cacheEnabled={false}
      columnHidingEnabled={allowColumnHiding}
      columnResizingMode={"nextColumn"}
      showBorders={true}
      columnAutoWidth={true}
      allowColumnResizing={allowColumnResizing}
      allowColumnReordering={allowColumnReorder}
      remoteOperations={true}
      dataSource={dataSource}
      rowAlternationEnabled={enableRowAlternation}
      onExporting={onExporting}
      onOptionChanged={onOptionChanged}
      onRowClick={RowClick}
      onRowPrepared={onRowPrepared}
      hoverStateEnabled={hoverStateEnabled}
    >
      {showFilterRow ? <FilterRow visible={true}></FilterRow> : null}
      {showSearchPanel ? (
        <SearchPanel visible={showSearchPanel}></SearchPanel>
      ) : null}
      {stateStoring ? (
        <StateStoring
          enabled={stateStoring.enabled}
          storageKey={stateStoring.storageKey}
        ></StateStoring>
      ) : (
        <StateStoring enabled={false}></StateStoring>
      )}
      <HeaderFilter visible={showHeaderFilter}></HeaderFilter>
      {/* Improve using dayjs to get a better formatting for the date */}
      <Export
        enabled={allowExcelExport}
        allowExportSelectedData={allowExcelExport}
      ></Export>
      <Pager
        visible={true}
        allowedPageSizes={allowedPageSizes}
        displayMode="full"
        showPageSizeSelector={true}
        showInfo={true}
        showNavigationButtons={true}
      ></Pager>
      <Column
        name={"Name"}
        dataField={"name"}
        caption={locale?.nameColumn?.caption}
        dataType="string"
      ></Column>
      {children}
    </DataGridDX>
  );
};


### components/Logo.tsx ###
import Image from "next/image";
import Link from "next/link";
import logo from "../public/logo.png";

const Logo = () => {
  return (
    <Link href={"/"}>
      <div>
        <Image
          className="tw-h-12 tw-w-auto tw-object-contain"
          src={logo}
          alt="Your Company"
        />
      </div>
    </Link>
  );
};

export default Logo;


### components/Modal.tsx ###
import { classNames } from "@fusion/utils";
import { Dialog, Transition } from "@headlessui/react";
import React, { Fragment, ReactNode } from "react";

export type ModalProps = {
    children?: ReactNode;
    description?: string;
    descriptionClasses?: string;
    FooterComponent?: ReactNode;
    IconComponent?: ReactNode;
    isOpen: boolean;
    onClose: () => void;
    title: string;
    titleClasses?: string;
    size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl'
};

export const Modal: React.FC<ModalProps> = (props) => {
    const {
        children,
        description,
        descriptionClasses,
        FooterComponent,
        IconComponent,
        isOpen,
        onClose,
        title,
        titleClasses,
        size
    } = props;

    return (
        <Transition.Root show={isOpen} as={Fragment}>
            <Dialog as="div" className="tw-relative tw-z-10" onClose={onClose}>
                <Transition.Child
                    as={Fragment}
                    enter="tw-ease-out tw-duration-300"
                    enterFrom="tw-opacity-0"
                    enterTo="tw-opacity-100"
                    leave="tw-ease-in tw-duration-200"
                    leaveFrom="tw-opacity-100"
                    leaveTo="tw-opacity-0"
                >
                    <div className="tw-fixed tw-inset-0 tw-bg-gray-500 tw-bg-opacity-75 tw-transition-opacity" />
                </Transition.Child>

                <div className="tw-fixed tw-inset-0 tw-z-10 tw-overflow-y-auto">
                    <div className="tw-flex tw-min-h-full tw-items-end tw-justify-center tw-p-4 tw-text-center tw-mt-12 sm:tw-items-start sm:tw-p-0">
                        <Transition.Child
                            as={Fragment}
                            enter="tw-ease-out tw-duration-300"
                            enterFrom="tw-opacity-0 tw-translate-y-4 sm:tw-translate-y-0 sm:tw-scale-95"
                            enterTo="tw-opacity-100 tw-translate-y-0 sm:tw-scale-100"
                            leave="tw-ease-in tw-duration-200"
                            leaveFrom="tw-opacity-100 tw-translate-y-0 sm:tw-scale-100"
                            leaveTo="tw-opacity-0 tw-translate-y-4 sm:tw-translate-y-0 sm:tw-scale-95"
                        >
                            <Dialog.Panel className={`tw-relative tw-transform tw-overflow-hidden tw-rounded-lg tw-bg-white tw-text-left tw-shadow-xl tw-transition-all sm:tw-my-8 ${size ? 'sm:tw-w-' + size : 'sm:tw-w-full sm:tw-max-w-lg'}`}>
                                <div className="tw-bg-white tw-px-4 tw-pt-5 tw-pb-4 sm:tw-p-6 sm:tw-pb-4">
                                    <div className="sm:tw-flex sm:tw-items-start">
                                        {IconComponent ? (
                                            <div className="tw-mx-auto tw-flex tw-h-12 tw-w-12 tw-flex-shrink-0 tw-items-center tw-justify-center tw-rounded-full tw-bg-red-100 sm:tw-mx-0 sm:tw-h-10 sm:tw-w-10">
                                                {IconComponent}
                                            </div>
                                        ) : null}
                                        <div className="tw-mt-3 tw-text-center sm:tw-mt-0 sm:tw-ml-4 sm:tw-text-left">
                                            <Dialog.Title
                                                as="h3"
                                                className={classNames(
                                                    "tw-text-lg tw-font-medium tw-leading-6 tw-text-gray-900",
                                                    titleClasses ?? "",
                                                )}
                                            >
                                                {title}
                                            </Dialog.Title>
                                            {description ? (
                                                <div className="tw-mt-2">
                                                    <p
                                                        className={classNames(
                                                            "tw-text-sm tw-text-gray-500",
                                                            descriptionClasses ?? "",
                                                        )}
                                                    >
                                                        {description}
                                                    </p>
                                                </div>
                                            ) : null}
                                            {children}
                                        </div>
                                    </div>
                                </div>
                                {FooterComponent}
                            </Dialog.Panel>
                        </Transition.Child>
                    </div>
                </div>
            </Dialog>
        </Transition.Root>
    );
};


### components/Navbar.tsx ###
import { Dialog, Transition } from "@headlessui/react";
import { XMarkIcon } from "@heroicons/react/20/solid";
import React, { Fragment, ReactElement } from "react";

type NavbarProps = {
  children?: ReactElement | ReactElement[];
} & {
  Links?: React.FC<{ children: React.ReactNode }>;
  Footer?: React.FC<{ children: React.ReactNode }>;
  Logo?: React.FC<{ children: React.ReactNode }>;
  Mobile?: (props: MobileSidebarProps) => ReactElement;
};

const Navbar = (props: NavbarProps) => {
  const links = React.Children.toArray(props.children).find(
    (child) => (child as ReactElement).type === Navbar.Links
  );
  const footer = React.Children.toArray(props.children).find(
    (child) => (child as ReactElement).type === Navbar.Footer
  );
  const logo = React.Children.toArray(props.children).find(
    (child) => (child as ReactElement).type === Navbar.Logo
  );

  return (
    <div className="tw-fixed tw-top-0 tw-left-0 tw-w-full tw-bg-white tw-shadow-lg tw-px-4 tw-justify-between tw-items-center tw-max-h-16 tw-overflow-hidden tw-z-50 tw-hidden lg:tw-flex lg:tw-flex-shrink-0">
      <div className="tw-flex tw-items-center tw-overflow-hidden tw-w-full">
        <div className="tw-flex-shrink-0 tw-justify-self-start">{logo}</div>
        <nav
          className="tw-flex tw-space-x-4 tw-ml-auto tw-overflow-y-auto"
          aria-label="Navbar"
        >
          {links}
        </nav>
        <div className="tw-flex tw-items-center tw-ml-4">{footer}</div>
      </div>
    </div>
  );
};

type MobileSidebarProps = {
  show: boolean;
  onClick: () => void;
  children?: ReactElement | ReactElement[];
} & {
  Links?: React.FC<{ children: React.ReactNode }>;
  Footer?: React.FC<{ children: React.ReactNode }>;
  Logo?: React.FC<{ children: React.ReactNode }>;
};

const MobileNavbar = (props: MobileSidebarProps) => {
  const links = React.Children.toArray(props.children).find(
    (child) => (child as ReactElement).type === Navbar.Links
  );
  const footer = React.Children.toArray(props.children).find(
    (child) => (child as ReactElement).type === Navbar.Footer
  );
  const logo = React.Children.toArray(props.children).find(
    (child) => (child as ReactElement).type === Navbar.Logo
  );

  return (
    <Transition.Root show={props.show} as={Fragment}>
      <Dialog
        as="div"
        className="tw-relative tw-z-40 lg:tw-hidden"
        onClose={props.onClick}
      >
        <Transition.Child
          as={Fragment}
          enter="tw-transition-opacity tw-ease-linear tw-duration-300"
          enterFrom="tw-opacity-0"
          enterTo="tw-opacity-100"
          leave="tw-transition-opacity tw-ease-linear tw-duration-300"
          leaveFrom="tw-opacity-100"
          leaveTo="tw-opacity-0"
        >
          <div className="tw-fixed tw-inset-0 tw-bg-gray-600 tw-bg-opacity-75" />
        </Transition.Child>

        <div className="tw-fixed tw-inset-0 tw-z-40 tw-flex">
          <Transition.Child
            as={Fragment}
            enter="tw-transition tw-ease-in-out tw-duration-300 tw-transform"
            enterFrom="-tw-translate-x-full"
            enterTo="tw-translate-x-0"
            leave="tw-transition tw-ease-in-out tw-duration-300 tw-transform"
            leaveFrom="tw-translate-x-0"
            leaveTo="-tw-translate-x-full"
          >
            <Dialog.Panel className="tw-relative tw-flex tw-w-full tw-max-w-xs tw-flex-1 tw-flex-col tw-bg-white focus:tw-outline-none">
              <Transition.Child
                as={Fragment}
                enter="tw-ease-in-out tw-duration-300"
                enterFrom="tw-opacity-0"
                enterTo="tw-opacity-100"
                leave="tw-ease-in-out tw-duration-300"
                leaveFrom="tw-opacity-100"
                leaveTo="tw-opacity-0"
              >
                <div className="tw-absolute tw-top-0 tw-right-0 -tw-mr-12 tw-pt-2">
                  <button
                    type="button"
                    className="tw-ml-1 tw-flex tw-h-10 tw-w-10 tw-items-center tw-justify-center tw-rounded-full focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-inset focus:tw-ring-white"
                    onClick={() => props.onClick()}
                  >
                    <span className="tw-sr-only">Close sidebar</span>
                    <XMarkIcon
                      className="tw-h-6 tw-w-6 tw-text-black"
                      aria-hidden="true"
                    />
                  </button>
                </div>
              </Transition.Child>
              <div className="tw-h-0 tw-flex-1 tw-overflow-y-auto tw-pt-5 tw-pb-4">
                <div className="tw-flex tw-flex-shrink-0 tw-items-center tw-px-4">
                  {logo}
                </div>
                <nav aria-label="Sidebar" className="tw-mt-5">
                  <div className="tw-space-y-1 tw-px-2">{links}</div>
                </nav>
              </div>
              <div className="tw-border-t tw-border-gray-200 tw-p-4">
                <div className="tw-block tw-flex-shrink-0">
                  <div className="tw-flex tw-items-center">
                    <div>
                      {/* Replace with user image */}

                      {/* <img
                        className="tw-inline-block tw-h-10 tw-w-10 tw-rounded-full tw-mr-3"
                        src="https://images.unsplash.com/photo-1517365830460-955ce3ccd263?ixlib=rb-=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=8&w=256&h=256&q=80"
                        alt=""
                      /> */}
                    </div>
                    <div className="tw-flex tw-w-full tw-items-center">
                      {footer}
                    </div>
                  </div>
                </div>
              </div>
            </Dialog.Panel>
          </Transition.Child>
          <div className="tw-w-14 tw-flex-shrink-0" aria-hidden="true">
            {/* Force sidebar to shrink to fit close icon */}
          </div>
        </div>
      </Dialog>
    </Transition.Root>
  );
};

const NavbarFooter = (props: { children?: React.ReactNode }): JSX.Element => {
  return <>{props.children}</>;
};

NavbarFooter.displayName = "Navbar.Footer";

Navbar.Footer = NavbarFooter;

const NavbarLinks = (props: { children?: React.ReactNode }): JSX.Element => {
  return <>{props.children}</>;
};

NavbarLinks.displayName = "Navbar.Links";

Navbar.Links = NavbarLinks;

const NavbarLogo = (props: { children?: React.ReactNode }): JSX.Element => {
  return <>{props.children}</>;
};

NavbarLogo.displayName = "Navbar.Logo";

Navbar.Logo = NavbarLogo;

Navbar.Mobile = MobileNavbar;

export { Navbar };
export type { NavbarProps, MobileSidebarProps };


### components/NoResults.tsx ###
import { MagnifyingGlassIcon } from "@heroicons/react/20/solid";
import { useTranslation } from "react-i18next";

type NoResultsProps = {
  title?: string;
  description?: string;
};

const NoResults: React.FC<NoResultsProps> = (props) => {
  const { title, description } = props;
  const { t } = useTranslation("General");

  return (
    <div className="tw-bg-white tw-w-full tw-shadow tw-p-8 tw-flex tw-flex-col tw-space-y-3 tw-justify-center tw-items-center">
      <div className="tw-bg-gray-300 tw-p-3 tw-rounded-full">
        <MagnifyingGlassIcon className="tw-h-8 tw-w-8 tw-text-gray-700 tw-font-bold" />
      </div>
      <div>
        <h2 className="tw-text-center tw-text-2xl tw-font-semibold tw-text-gray-800">
          {title || t("NoResultsTitle")}
        </h2>
        <p className="tw-text-center tw-text-lg tw-text-gray-500">
          {description || t("NoResultsDescription")}
        </p>
      </div>
    </div>
  );
};

export default NoResults;


### components/SearchBox.tsx ###
import { MagnifyingGlassIcon, XMarkIcon } from "@heroicons/react/20/solid";
import React from "react";
import { useDebouncedCallback } from "use-debounce";

type SearchBoxProps = {
  defaultValue?: string;
  placeholder?: string;
  onChange?: (searchTerm?: string) => void;
  onSubmit?: (searchTerm?: string) => void;
  onBlur?: () => void;
  debounce?: number;
};

const SearchBox: React.FC<SearchBoxProps> = (props) => {
  const { onChange, onSubmit, defaultValue, placeholder } = props;
  const [internalValue, setInternalValue] = React.useState(defaultValue);

  const debouncedOnChange = useDebouncedCallback((value) => {
    onChange && onChange(value);
  }, props.debounce || 1000);

  return (
    <div className="tw-flex tw-items-center tw-space-x-2 tw-border-2 tw-border-gray-300 tw-bg-white tw-px-2">
      <div
        className="tw-p-2 tw-cursor-pointer"
        onClick={() => {
          onChange && onChange(internalValue);
          onSubmit && onSubmit(internalValue);
        }}
      >
        <MagnifyingGlassIcon className="tw-h-6 tw-w-6 tw-text-gray-500" />
      </div>

      <input
        value={internalValue}
        className="tw-p-0 tw-border-0 tw-m-0"
        placeholder={placeholder}
        onChange={(event) => {
          debouncedOnChange(event.currentTarget.value);
          setInternalValue(event.currentTarget.value);
        }}
        onKeyUp={(event) => {
          if (event.key === "Enter") {
            onSubmit && onSubmit(event.currentTarget.value);
            setInternalValue(event.currentTarget.value);
          }
        }}
        onBlur={() => {
          props.onBlur && props.onBlur();
        }}
      ></input>
      {internalValue && internalValue.length > 0 ? (
        <div
          className="tw-p-2 tw-cursor-pointer"
          onClick={() => {
            onChange && onChange(undefined);
            onSubmit && onSubmit(undefined);
            setInternalValue("");
          }}
        >
          <XMarkIcon className="tw-h-4 tw-w-4 tw-text-gray-500"></XMarkIcon>
        </div>
      ) : null}
    </div>
  );
};

export default SearchBox;


### components/Sidebar.tsx ###
import { Dialog, Transition } from "@headlessui/react";
import { XMarkIcon } from "@heroicons/react/20/solid";

import React, { Fragment, ReactElement } from "react";

type SidebarProps = {
  children?: ReactElement | ReactElement[];
} & {
  Links?: React.FC<{ children: React.ReactNode }>;
  Footer?: React.FC<{ children: React.ReactNode }>;
  Logo?: React.FC<{ children: React.ReactNode }>;
  Mobile?: (props: MobileSidebarProps) => ReactElement;
};

const Sidebar = (props: SidebarProps) => {
  const links = React.Children.toArray(props.children).find(
    (child) => (child as ReactElement).type === Sidebar.Links
  );
  const footer = React.Children.toArray(props.children).find(
    (child) => (child as ReactElement).type === Sidebar.Footer
  );
  const logo = React.Children.toArray(props.children).find(
    (child) => (child as ReactElement).type === Sidebar.Logo
  );
  return (
    <div className="tw-hidden lg:tw-flex lg:tw-flex-shrink-0 tw-shadow-lg">
      <div className="tw-flex tw-w-[280px] tw-flex-col">
        <div className="tw-flex tw-min-h-0 tw-flex-1 tw-flex-col tw-bg-white tw-px-4">
          <div className="tw-flex tw-flex-1 tw-flex-col tw-overflow-y-auto">
            <div className="tw-flex tw-flex-shrink-0 tw-items-center tw-px-4 tw-py-12">
              {logo}
            </div>
            <nav
              className="tw-flex-1 tw-space-y-1 tw-bg-white"
              aria-label="Sidebar"
            >
              {links}
            </nav>
          </div>
          <div className="tw-flex tw-flex-shrink-0 tw-bg-white tw-p-4">
            <div className="tw-block tw-w-full tw-flex-shrink-0">
              <div className="tw-flex tw-items-center">
                <div>
                  {/* Replace with user image */}
                  {/* <img
                    className="tw-inline-block tw-h-9 tw-w-9 tw-rounded-full tw-mr-3"
                    src="https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
                    alt=""
                  /> */}
                </div>
                <div className="tw-flex tw-w-full tw-items-center">
                  {footer}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

type MobileSidebarProps = {
  show: boolean;
  onClick: () => void;
  children?: ReactElement | ReactElement[];
} & {
  Links?: React.FC<{ children: React.ReactNode }>;
  Footer?: React.FC<{ children: React.ReactNode }>;
  Logo?: React.FC<{ children: React.ReactNode }>;
};

const MobileSidebar = (props: MobileSidebarProps) => {
  const links = React.Children.toArray(props.children).find(
    (child) => (child as ReactElement).type === Sidebar.Links
  );
  const footer = React.Children.toArray(props.children).find(
    (child) => (child as ReactElement).type === Sidebar.Footer
  );
  const logo = React.Children.toArray(props.children).find(
    (child) => (child as ReactElement).type === Sidebar.Logo
  );

  return (
    <Transition.Root show={props.show} as={Fragment}>
      <Dialog
        as="div"
        className="tw-relative tw-z-40 lg:tw-hidden"
        onClose={props.onClick}
      >
        <Transition.Child
          as={Fragment}
          enter="tw-transition-opacity tw-ease-linear tw-duration-300"
          enterFrom="tw-opacity-0"
          enterTo="tw-opacity-100"
          leave="tw-transition-opacity tw-ease-linear tw-duration-300"
          leaveFrom="tw-opacity-100"
          leaveTo="tw-opacity-0"
        >
          <div className="tw-fixed tw-inset-0 tw-bg-gray-600 tw-bg-opacity-75" />
        </Transition.Child>

        <div className="tw-fixed tw-inset-0 tw-z-40 tw-flex">
          <Transition.Child
            as={Fragment}
            enter="tw-transition tw-ease-in-out tw-duration-300 tw-transform"
            enterFrom="-tw-translate-x-full"
            enterTo="tw-translate-x-0"
            leave="tw-transition tw-ease-in-out tw-duration-300 tw-transform"
            leaveFrom="tw-translate-x-0"
            leaveTo="-tw-translate-x-full"
          >
            <Dialog.Panel className="tw-relative tw-flex tw-w-full tw-max-w-xs tw-flex-1 tw-flex-col tw-bg-white focus:tw-outline-none">
              <Transition.Child
                as={Fragment}
                enter="tw-ease-in-out tw-duration-300"
                enterFrom="tw-opacity-0"
                enterTo="tw-opacity-100"
                leave="tw-ease-in-out tw-duration-300"
                leaveFrom="tw-opacity-100"
                leaveTo="tw-opacity-0"
              >
                <div className="tw-absolute tw-top-0 tw-right-0 -tw-mr-12 tw-pt-2">
                  <button
                    type="button"
                    className="tw-ml-1 tw-flex tw-h-10 tw-w-10 tw-items-center tw-justify-center tw-rounded-full focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-inset focus:tw-ring-white"
                    onClick={() => props.onClick()}
                  >
                    <span className="tw-sr-only">Close sidebar</span>
                    <XMarkIcon
                      className="tw-h-6 tw-w-6 tw-text-black"
                      aria-hidden="true"
                    />
                  </button>
                </div>
              </Transition.Child>
              <div className="tw-h-0 tw-flex-1 tw-overflow-y-auto tw-pt-5 tw-pb-4">
                <div className="tw-flex tw-flex-shrink-0 tw-items-center tw-px-4">
                  {logo}
                </div>
                <nav aria-label="Sidebar" className="tw-mt-5">
                  <div className="tw-space-y-1 tw-px-2">{links}</div>
                </nav>
              </div>
              <div className="tw-border-t tw-border-gray-200 tw-p-4">
                <div className="tw-block tw-flex-shrink-0">
                  <div className="tw-flex tw-items-center">
                    <div>
                      {/* Replace with user image */}

                      {/* <img
                        className="tw-inline-block tw-h-10 tw-w-10 tw-rounded-full tw-mr-3"
                        src="https://images.unsplash.com/photo-1517365830460-955ce3ccd263?ixlib=rb-=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=8&w=256&h=256&q=80"
                        alt=""
                      /> */}
                    </div>
                    <div className="tw-flex tw-w-full tw-items-center">
                      {footer}
                    </div>
                  </div>
                </div>
              </div>
            </Dialog.Panel>
          </Transition.Child>
          <div className="tw-w-14 tw-flex-shrink-0" aria-hidden="true">
            {/* Force sidebar to shrink to fit close icon */}
          </div>
        </div>
      </Dialog>
    </Transition.Root>
  );
};

const SidebarFooter = (props: { children?: React.ReactNode }): JSX.Element => {
  return <>{props.children}</>;
};

SidebarFooter.displayName = "Sidebar.Footer";

Sidebar.Footer = SidebarFooter;

const SidebarLinks = (props: { children?: React.ReactNode }): JSX.Element => {
  return <>{props.children}</>;
};

SidebarLinks.displayName = "Sidebar.Links";

Sidebar.Links = SidebarLinks;

const SidebarLogo = (props: { children?: React.ReactNode }): JSX.Element => {
  return <>{props.children}</>;
};

SidebarLogo.displayName = "Sidebar.Logo";

Sidebar.Logo = SidebarLogo;

Sidebar.Mobile = MobileSidebar;

export { Sidebar };
export type { SidebarProps, MobileSidebarProps };


### components/SlideOver.tsx ###
import { Fragment, ReactNode } from "react";
import { Dialog, Transition } from "@headlessui/react";
import { XMarkIcon } from "@heroicons/react/24/outline";
import { Button } from "@fusion/ui";
import { useTranslation } from "react-i18next";
import { classNames } from "@fusion/utils";

export type SlideOverProps = {
  children?: ReactNode;
  confirmButtonLabel?: string;
  containerClasses?: string;
  isOpen: boolean;
  onClose: () => void;
  onConfirm?: () => void;
  title?: string;
  titleClasses?: string;
  showCancelButton?: boolean;
  showConfirmButton?: boolean;
  /**
   * Max size of the panel.
   * The panel will adjust to content if its width is minor.
   */
  size?: "xs" | "md" | "lg" | "xl" | "2xl" | "3xl" | "4xl";
};

const SIZE_CLASSNAME = {
  xs: "tw-max-w-xs",
  md: "tw-max-w-md",
  lg: "tw-max-w-lg",
  xl: "tw-max-w-xl",
  ["2xl"]: "tw-max-w-2xl",
  ["3xl"]: "tw-max-w-3xl",
  ["4xl"]: "tw-max-w-4xl",
};

const SlideOver: React.FC<SlideOverProps> = (props) => {
  const {
    children,
    confirmButtonLabel,
    containerClasses,
    isOpen,
    onClose,
    onConfirm,
    title,
    titleClasses,
    showCancelButton = true,
    showConfirmButton = true,
    size = "md",
  } = props;

  const { t } = useTranslation("Components");

  const getPanelSizeClassName = () => {
    return SIZE_CLASSNAME[size];
  };

  return (
    <Transition.Root show={isOpen} as={Fragment}>
      <Dialog as="div" className="tw-relative z-10" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="tw-ease-in-out tw-duration-500"
          enterFrom="tw-opacity-0"
          enterTo="tw-opacity-100"
          leave="tw-ease-in-out tw-duration-500"
          leaveFrom="tw-opacity-100"
          leaveTo="tw-opacity-0"
        >
          <div className="tw-fixed tw-inset-0 tw-bg-gray-500 tw-bg-opacity-75 tw-transition-opacity" />
        </Transition.Child>

        <div className="tw-fixed tw-inset-0 tw-overflow-hidden">
          <div className="tw-absolute tw-inset-0 tw-overflow-hidden">
            <div className="tw-pointer-events-none tw-fixed tw-inset-y-0 tw-right-0 tw-flex tw-max-w-full tw-pl-10">
              <Transition.Child
                as={Fragment}
                enter="tw-transform tw-transition tw-ease-in-out tw-duration-500 sm:tw-duration-700"
                enterFrom="tw-translate-x-full"
                enterTo="tw-translate-x-0"
                leave="tw-transform tw-transition tw-ease-in-out tw-duration-500 sm:tw-duration-700"
                leaveFrom="tw-translate-x-0"
                leaveTo="tw-translate-x-full"
              >
                <Dialog.Panel
                  className={classNames(
                    "tw-pointer-events-auto tw-relative tw-w-screen",
                    getPanelSizeClassName()
                  )}
                >
                  <div
                    className={classNames(
                      "tw-flex tw-h-full tw-flex-col tw-overflow-y-scroll tw-bg-white tw-px-4 tw-py-6 tw-shadow-xl",
                      containerClasses || ""
                    )}
                  >
                    <div className="tw-flex">
                      <Dialog.Title
                        className={classNames(
                          "tw-text-base tw-font-semibold tw-leading-6 tw-text-gray-900 tw-w-full",
                          titleClasses || ""
                        )}
                      >
                        {title}
                      </Dialog.Title>
                      <XMarkIcon
                        className="tw-h-6 tw-w-6 hover:tw-cursor-pointer"
                        onClick={onClose}
                      />
                    </div>
                    <div className="tw-relative tw-mt-6 tw-flex-1">
                      {children}
                    </div>
                    <div className="tw-justify-end tw-shrink-0 tw-flex tw-gap-4">
                      {showCancelButton ? (
                        <Button
                          variant="secondary"
                          className="tw-text-primary-500"
                          onClick={onClose}
                        >
                          {t("CancelLabel")}
                        </Button>
                      ) : null}
                      {showConfirmButton ? (
                        <Button onClick={onConfirm}>
                          {confirmButtonLabel || t("ConfirmLabel")}
                        </Button>
                      ) : null}
                    </div>
                  </div>
                </Dialog.Panel>
              </Transition.Child>
            </div>
          </div>
        </div>
      </Dialog>
    </Transition.Root>
  );
};

export default SlideOver;


### components/StepIndicator.tsx ###
import { AccentColor } from "@fusion/theme"
import { classNames } from "@fusion/utils"

type Size = "sm" | "md" | "lg"

type StepIndicatorProps = {
  accentColor?: AccentColor
  bulletClasses?: string
  bulletSize?: Size
  containerClasses?: string
  currentStep: number
  lineClasses?: string
  steps?: number
  stepsName?: string[]
}

const TW_BULLET_SIZE = {
  sm: "tw-w-4 tw-h-4",
  md: "tw-w-8 tw-h-8",
  lg: "tw-w-16 tw-h-16",
}

const StepIndicator: React.FC<StepIndicatorProps> = ({
  accentColor = "green",
  bulletClasses,
  bulletSize = "md",
  containerClasses,
  currentStep,
  lineClasses,
  steps = 3,
  stepsName = [],
}) => {
  const getBulletAlignment = (step: number) => {
    if (step === 1) return "tw-justify-start"
    if (step === steps) return "tw-justify-end"
    return "tw-justify-center"
  }

  const getTextAlignment = (index: number) => {
    if (index === 0) return "tw-text-left"

    if (index === steps - 1) return "tw-text-right"

    return "tw-text-center"
  }

  const getTextColor = (index: number) => {
    if (index + 1 === currentStep) return `tw-text-${accentColor}-400`

    return "tw-text-gray-600"
  }

  const Bullet = (step: number) => {
    const isCurrentStep = step === currentStep
    return (
      <div
        className={classNames(
          "tw-flex tw-flex-1 tw-z-10",
          getBulletAlignment(step),
        )}
        key={`stepper-step-${step}`}
      >
        <div
          className={classNames(
            isCurrentStep
              ? `tw-border-${accentColor}-400`
              : "tw-border-gray-500",
            `${TW_BULLET_SIZE[bulletSize]} tw-bg-white tw-border tw-rounded-full tw-flex tw-flex-col tw-justify-center tw-content-center`,
            bulletClasses || "",
          )}
        >
          <span
            className={classNames(
              isCurrentStep ? `tw-text-${accentColor}-400` : "",
              "tw-text-sm tw-font-bold tw-w-full tw-text-center",
            )}
          >
            {step.toString()}
          </span>
        </div>
      </div>
    )
  }

  const SeparatorLine = () => {
    return (
      <div
        className={classNames(
          "tw-absolute tw-bg-gray-500 tw-h-0.5 tw-w-full tw-self-center tw-z-0",
          lineClasses || "",
        )}
      />
    )
  }

  const RenderBullets = () => {
    let list: JSX.Element[] = []
    for (let index = 1; index <= steps; index++) {
      list.push(Bullet(index))
    }
    return list
  }

  return (
    <div
      className={classNames(
        "tw-w-full tw-flex tw-flex-col",
        containerClasses || "",
      )}
    >
      <div className="tw-flex tw-justify-between tw-relative">
        <SeparatorLine />
        {RenderBullets()}
      </div>
      <div className="tw-flex tw-justify-between">
        {stepsName.map((name, index) => (
          <span
            key={index}
            className={classNames(
              "tw-flex-1 tw-text-sm tw-font-semibold",
              getTextAlignment(index),
              getTextColor(index),
            )}
          >
            {name}
          </span>
        ))}
      </div>
    </div>
  )
}

export default StepIndicator


### components/TimeInput.tsx ###
import { FormError, FormServerSideErrors } from "@fusion/form-error";
import { FormLabel } from "@fusion/form-label";
import { AccentColor } from "@fusion/theme";
import { classNames } from "@fusion/utils";
import React, { CSSProperties, ReactComponentElement, useState } from "react";
import {
  Control,
  Controller,
  ControllerFieldState,
  ControllerRenderProps,
  FieldValues,
  Path,
} from "react-hook-form";

export type InputProps<
  TFieldValues extends FieldValues,
  TName extends Path<TFieldValues> = Path<TFieldValues>
> = React.DetailedHTMLProps<
  React.InputHTMLAttributes<HTMLInputElement>,
  HTMLInputElement
> & {
  /**
   * Component used for the label.
   *
   * Example:
   *
   * LabelComponent={<FormLabel>Name</FormLabel>}
   */
  LabelComponent?: ReactComponentElement<typeof FormLabel>;
  name: Path<TFieldValues>;
  control?: Control<TFieldValues, TName>;
  containerStyle?: CSSProperties;
  containerClasses?: string;
  iconLeft?: JSX.Element;
  iconRight?: JSX.Element;
  accentColor?: AccentColor;
  errors?: { [key: string]: string[] };
  showErrors?: boolean;
};

export const TimeInput = <
  TFieldValues extends FieldValues,
  TName extends Path<TFieldValues> = Path<TFieldValues>
>(
  props: InputProps<TFieldValues, TName>
) => {
  const { type = "text", ...otherProps } = props;

  if (props.control) {
    return (
      <Controller
        name={props.name}
        control={props.control}
        render={({ field, fieldState }) => {
          return (
            <Component
              field={field}
              fieldState={fieldState}
              type={type}
              {...otherProps}
            ></Component>
          );
        }}
      ></Controller>
    );
  }

  return <Component type={type} {...otherProps} />;
};

type ComponentProps<
  TFieldValues extends FieldValues,
  TName extends Path<TFieldValues> = Path<TFieldValues>
> = {
  field?: ControllerRenderProps<
    TFieldValues,
    (string | undefined) & Path<TFieldValues>
  >;
  fieldState?: ControllerFieldState;
  initTime?: number;
} & InputProps<TFieldValues, TName>;

const Component = <
  TFieldValues extends FieldValues,
  TName extends Path<TFieldValues> = Path<TFieldValues>
>(
  props: ComponentProps<TFieldValues, TName>
) => {
  const {
    field,
    fieldState,
    LabelComponent,
    containerStyle,
    containerClasses,
    iconLeft,
    iconRight,
    accentColor = "primary",
    errors,
    name,
    showErrors = true,
    initTime = "00:00",
    className,
    ...otherProps
  } = props;

  const [time, setTime] = useState(otherProps.defaultValue || initTime);

  let lastVal = "";

  const onChangeHandler = (val: string) => {
    if (val == time) {
      return;
    }

    if (val.length === 2 && lastVal.length !== 3 && val.indexOf(":") === -1) {
      val = val + ":";
    }

    if (val.length === 2 && lastVal.length === 3) {
      val = val.slice(0, 1);
    }

    if (val.length > 5) {
      return false;
    }

    lastVal = val;

    setTime(val);
  };

  return (
    <div
      style={containerStyle}
      className={classNames(
        "tw-flex-1 tw-flex-col tw-gap-1",
        containerClasses ?? ""
      )}
    >
      {LabelComponent ? LabelComponent : null}
      <div
        className={`tw-border-b-2 tw-border-gray-300 tw-flex tw-items-center tw-bg-white focus-within:tw-border-b-2 focus-within:tw-border-${accentColor}-500`}
      >
        {iconLeft ? <div className="tw-pl-2">{iconLeft}</div> : null}

        <input
          {...otherProps}
          name={field?.name ?? name}
          className={classNames(
            "tw-block tw-w-full tw-border-0 tw-border-transparent tw-bg-gray-50 focus:tw-ring-0 sm:tw-text-sm tw-px-2 tw-justify-center tw-text-center",
            className ?? ""
          )}
          type={otherProps.type}
          defaultValue={
            otherProps.defaultValue || otherProps.control?._defaultValues[name]
          }
          value={time}
          onChange={(e) => {
            onChangeHandler(e.target.value);
            {
              if (otherProps.value !== undefined) return;
              otherProps.onChange && otherProps.onChange(e);

              if (otherProps.type === "number") {
                field?.onChange && field?.onChange(parseInt(e.target.value));
                return;
              }

              field?.onChange && field?.onChange(e.target.value);
            }
          }}
          onBlur={(event) => {
            field?.onBlur && field?.onBlur();
            otherProps.onBlur && otherProps.onBlur(event);
          }}
          ref={field?.ref ?? otherProps.ref}
        />

        {iconRight}
      </div>

      {showErrors ? (
        <div className="errors">
          {fieldState?.error ? (
            <FormError message={fieldState.error.message}></FormError>
          ) : null}
          <FormServerSideErrors
            errors={errors}
            fieldKey={field?.name || name}
          ></FormServerSideErrors>
        </div>
      ) : null}
    </div>
  );
};


### components/WeekDayBoxes.tsx ###
import { DataGridColumnInformation } from "@fusion/utils";
import React from "react";
import { useTranslation } from "react-i18next";
import { DayBox } from "./DayBox";
import { WorkingHourDay } from "../services/WorkingHoursService";

export type WeekDayBoxesProps = {
  info?: DataGridColumnInformation<null>;
};

export const WeekDayBoxes = (props: WeekDayBoxesProps) => {
  const { info } = props;

  const { t } = useTranslation("WorkingHoursScreen");

  const isActive = (day: number) => {
    if (!info) return false;
    if (info.row.data.workingHourDays.length === 0) return false;
    
    return info.row.data.workingHourDays.some(
      (d: WorkingHourDay) => d.dayOfWeek === day && d.minutes > 0
    );
  };
    
  return (
    <div className="tw-grid tw-grid-cols-7 tw-gap-4">
      <DayBox
        label={t("Mo")}
        classNames="tw-px-0 tw-py-1"
        active={isActive(1)}
      ></DayBox>
      <DayBox
        label={t("Tu")}
        classNames="tw-px-0 tw-py-1"
        active={isActive(2)}
      ></DayBox>
      <DayBox
        label={t("We")}
        classNames="tw-px-0 tw-py-1"
        active={isActive(3)}
      ></DayBox>
      <DayBox
        label={t("Th")}
        classNames="tw-px-0 tw-py-1"
        active={isActive(4)}
      ></DayBox>
      <DayBox
        label={t("Fr")}
        classNames="tw-px-0 tw-py-1"
        active={isActive(5)}
      ></DayBox>
      <DayBox
        label={t("Sa")}
        classNames="tw-px-0 tw-py-1"
        active={isActive(6)}
      ></DayBox>
      <DayBox
        label={t("Su")}
        classNames="tw-px-0 tw-py-1"
        active={isActive(0)}
      ></DayBox>
    </div>
  );
};


### components/WorkingHoursForm.tsx ###
import React, { useMemo } from "react";
import { useTranslation } from "react-i18next";
import { DayBox } from "./DayBox";
import {
  Button,
  FormLabel,
  FormServerSideErrors,
  Input,
  Switch,
  useServerSideErrors,
} from "@fusion/ui";
import { TimeInput } from "./TimeInput";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm, useWatch } from "react-hook-form";
import { z } from "zod";
import WorkingHoursService, {
  WorkingHoursRes,
} from "../services/WorkingHoursService";
import router from "next/router";
import { useUserStore } from "../stores/UserStore";
import { Modal } from "./Modal";
import { LocalForm } from "./LocalForm";

export type WorkingHoursFormProps = {
  onClose: () => void;
  showModal?: boolean;
  workingHours?: WorkingHoursRes;
  mode: "create" | "edit";
};

export const WorkingHoursForm = (props: WorkingHoursFormProps) => {
  const { onClose, showModal = false, workingHours, mode } = props;
  const { errors, setErrors, clearErrors } =
    useServerSideErrors<WorkingHoursRes>();
  const store = useUserStore();
  const { t } = useTranslation("WorkingHoursScreen");

  function timeStringToMinutes(time: string): number {
    if (!time.includes(":")) {
      return 0;
    }
    const [hours, minutes] = time.split(":").map(Number);
    if (isNaN(hours) || isNaN(minutes)) {
      return 0;
    }
    return hours * 60 + minutes;
  }

  const formatMinutes = (totalMinutes: number) => {
    const hours = Math.floor(totalMinutes / 60);
    const minutes = totalMinutes % 60;

    const formattedHours = String(hours).padStart(2, "0");
    const formattedMinutes = String(minutes).padStart(2, "0");

    return `${formattedHours}:${formattedMinutes}`;
  };

  const timeRangeRefinement = (day: string) => {
    return (data: { [x: string]: any }) => {
      if (!data[`${day}TimeEnd`] || !data[`${day}TimeStart`]) return true;

      const endTime = timeStringToMinutes(data[`${day}TimeEnd`]);
      const startTime = timeStringToMinutes(data[`${day}TimeStart`]);
      const duration = endTime - startTime;
      const minutes = timeStringToMinutes(data[`${day}Minutes`] || "0");

      return duration <= minutes;
    };
  };

  const validationSchema = z
    .object({
      name: z
        .string({
          required_error: t("NameRequiredValidationMessage"),
        })
        .refine(
          (value) => {
            return value.trim() !== "";
          },
          { message: t("NameRequiredValidationMessage") }
        ),
      timeBreakMinutes: z.string().optional(),
      timeLimitIssues: z.string().optional(),
      timeAutoCloseAfterMinutes: z.string().optional(),
      isDefault: z.boolean().optional(),
      companyId: z.string().optional(),
      moMinutes: z.string().optional(),
      tuMinutes: z.string().optional(),
      weMinutes: z.string().optional(),
      thMinutes: z.string().optional(),
      frMinutes: z.string().optional(),
      saMinutes: z.string().optional(),
      suMinutes: z.string().optional(),
      inactive: z.boolean().optional(),
      moTimeStart: z.string().optional(),
      tuTimeStart: z.string().optional(),
      weTimeStart: z.string().optional(),
      thTimeStart: z.string().optional(),
      frTimeStart: z.string().optional(),
      saTimeStart: z.string().optional(),
      suTimeStart: z.string().optional(),
      moTimeEnd: z.string().optional(),
      tuTimeEnd: z.string().optional(),
      weTimeEnd: z.string().optional(),
      thTimeEnd: z.string().optional(),
      frTimeEnd: z.string().optional(),
      saTimeEnd: z.string().optional(),
      suTimeEnd: z.string().optional(),
    })
    .refine(timeRangeRefinement("mo"), {
      message: t("InvalidTimeRange"),
      path: ["moTimeEnd"],
    })
    .refine(timeRangeRefinement("tu"), {
      message: t("InvalidTimeRange"),
      path: ["tuTimeEnd"],
    })
    .refine(timeRangeRefinement("we"), {
      message: t("InvalidTimeRange"),
      path: ["weTimeEnd"],
    })
    .refine(timeRangeRefinement("th"), {
      message: t("InvalidTimeRange"),
      path: ["thTimeEnd"],
    })
    .refine(timeRangeRefinement("fr"), {
      message: t("InvalidTimeRange"),
      path: ["frTimeEnd"],
    })
    .refine(timeRangeRefinement("sa"), {
      message: t("InvalidTimeRange"),
      path: ["saTimeEnd"],
    })
    .refine(timeRangeRefinement("su"), {
      message: t("InvalidTimeRange"),
      path: ["suTimeEnd"],
    });

  type ValidationSchema = z.infer<typeof validationSchema>;

  const { reset } = useForm();

  const {
    control,
    handleSubmit,
    formState: { errors: clientErrors, isSubmitting },
    clearErrors: clearClientErrors,
  } = useForm<ValidationSchema>({
    defaultValues: workingHours
      ? {
          name: workingHours.name,
          timeBreakMinutes: workingHours.timeBreakMinutes.toString() || "",
          timeLimitIssues: formatMinutes(workingHours.timeLimitIssues) || "",
          timeAutoCloseAfterMinutes:
            formatMinutes(workingHours.timeAutoCloseAfterMinutes) || "",
          isDefault: workingHours.isDefault || false,
          companyId: workingHours.companyId || "",
          moMinutes:
            formatMinutes(
              workingHours.workingHourDays.find((x) => x.dayOfWeek === 1)
                ?.minutes || 0
            ) || "",
          tuMinutes:
            formatMinutes(
              workingHours.workingHourDays.find((x) => x.dayOfWeek === 2)
                ?.minutes || 0
            ) || "",
          weMinutes:
            formatMinutes(
              workingHours.workingHourDays.find((x) => x.dayOfWeek === 3)
                ?.minutes || 0
            ) || "",
          thMinutes:
            formatMinutes(
              workingHours.workingHourDays.find((x) => x.dayOfWeek === 4)
                ?.minutes || 0
            ) || "",
          frMinutes:
            formatMinutes(
              workingHours.workingHourDays.find((x) => x.dayOfWeek === 5)
                ?.minutes || 0
            ) || "",
          saMinutes:
            formatMinutes(
              workingHours.workingHourDays.find((x) => x.dayOfWeek === 6)
                ?.minutes || 0
            ) || "",
          suMinutes:
            formatMinutes(
              workingHours.workingHourDays.find((x) => x.dayOfWeek === 0)
                ?.minutes || 0
            ) || "",
          moTimeStart:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 1)
              ?.timeStart.substring(0, 5) || "00:00",
          tuTimeStart:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 2)
              ?.timeStart.substring(0, 5) || "00:00",
          weTimeStart:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 3)
              ?.timeStart.substring(0, 5) || "00:00",
          thTimeStart:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 4)
              ?.timeStart.substring(0, 5) || "00:00",
          frTimeStart:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 5)
              ?.timeStart.substring(0, 5) || "00:00",
          saTimeStart:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 6)
              ?.timeStart.substring(0, 5) || "00:00",
          suTimeStart:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 0)
              ?.timeStart.substring(0, 5) || "00:00",
          moTimeEnd:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 1)
              ?.timeEnd.substring(0, 5) || "00:00",
          tuTimeEnd:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 2)
              ?.timeEnd.substring(0, 5) || "00:00",
          weTimeEnd:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 3)
              ?.timeEnd.substring(0, 5) || "00:00",
          thTimeEnd:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 4)
              ?.timeEnd.substring(0, 5) || "00:00",
          frTimeEnd:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 5)
              ?.timeEnd.substring(0, 5) || "00:00",
          saTimeEnd:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 6)
              ?.timeEnd.substring(0, 5) || "00:00",
          suTimeEnd:
            workingHours.workingHourDays
              .find((x) => x.dayOfWeek === 0)
              ?.timeEnd.substring(0, 5) || "00:00",
        }
      : {
          inactive: true,
        },
    resolver: zodResolver(validationSchema),
  });

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearErrors();
      try {
        const dto: WorkingHoursRes = {
          id: workingHours?.id,
          name: data.name,
          timeBreakMinutes: parseInt(data.timeBreakMinutes ?? "0"),
          timeLimitIssues: timeStringToMinutes(data.timeLimitIssues ?? "0"),
          timeAutoCloseAfterMinutes: timeStringToMinutes(
            data.timeAutoCloseAfterMinutes ?? "0"
          ),
          isDefault: data.isDefault || false,
          companyId: store.tenantId || "",
          workingHourDays: [
            {
              name: "WorkingHour",
              workingHourId: undefined,
              dayOfWeek: 1,
              minutes: timeStringToMinutes(data.moMinutes ?? "0"),
              timeStart: "",
              timeEnd: "",
              marginTimeStartEnd: "00:00:00",
            },
          ],
        };

        if (
          data.moMinutes != "" &&
          data.moMinutes != "00:00" &&
          data.moMinutes != undefined
        )
          dto.workingHourDays = [
            {
              name: "WorkingHour",
              workingHourId:
                workingHours?.workingHourDays.find((x) => x.dayOfWeek === 1)
                  ?.workingHourId || undefined,
              dayOfWeek: 1,
              minutes: timeStringToMinutes(data.moMinutes ?? "0"),
              timeStart: data.moTimeStart
                ? `${data.moTimeStart}:00`
                : "00:00:00",
              timeEnd: data.moTimeEnd ? `${data.moTimeEnd}:00` : "00:00:00",
              marginTimeStartEnd: "00:00:00",
            },
          ];
        else dto.workingHourDays = [];

        if (
          data.tuMinutes != "" &&
          data.tuMinutes != "00:00" &&
          data.tuMinutes != undefined
        )
          dto.workingHourDays.push({
            name: "WorkingHour",
            workingHourId:
              workingHours?.workingHourDays.find((x) => x.dayOfWeek === 2)
                ?.workingHourId || undefined,
            dayOfWeek: 2,
            minutes: timeStringToMinutes(data.tuMinutes ?? "0"),
            timeStart: data.tuTimeStart ? `${data.tuTimeStart}:00` : "00:00:00",
            timeEnd: data.tuTimeEnd ? `${data.tuTimeEnd}:00` : "00:00:00",
            marginTimeStartEnd: "00:00:00",
          });

        if (
          data.weMinutes != "" &&
          data.weMinutes != "00:00" &&
          data.weMinutes != undefined
        )
          dto.workingHourDays.push({
            name: "WorkingHour",
            workingHourId:
              workingHours?.workingHourDays.find((x) => x.dayOfWeek === 3)
                ?.workingHourId || undefined,
            dayOfWeek: 3,
            minutes: timeStringToMinutes(data.weMinutes ?? "0"),
            timeStart: data.weTimeStart ? `${data.weTimeStart}:00` : "00:00:00",
            timeEnd: data.weTimeEnd ? `${data.weTimeEnd}:00` : "00:00:00",
            marginTimeStartEnd: "00:00:00",
          });

        if (
          data.thMinutes != "" &&
          data.thMinutes != "00:00" &&
          data.thMinutes != undefined
        )
          dto.workingHourDays.push({
            name: "WorkingHour",
            workingHourId:
              workingHours?.workingHourDays.find((x) => x.dayOfWeek === 4)
                ?.workingHourId || undefined,
            dayOfWeek: 4,
            minutes: timeStringToMinutes(data.thMinutes ?? "0"),
            timeStart: data.thTimeStart ? `${data.thTimeStart}:00` : "00:00:00",
            timeEnd: data.thTimeEnd ? `${data.thTimeEnd}:00` : "00:00:00",
            marginTimeStartEnd: "00:00:00",
          });

        if (
          data.frMinutes != "" &&
          data.frMinutes != "00:00" &&
          data.frMinutes != undefined
        )
          dto.workingHourDays.push({
            name: "WorkingHour",
            workingHourId:
              workingHours?.workingHourDays.find((x) => x.dayOfWeek === 5)
                ?.workingHourId || undefined,
            dayOfWeek: 5,
            minutes: timeStringToMinutes(data.frMinutes ?? "0"),
            timeStart: data.frTimeStart ? `${data.frTimeStart}:00` : "00:00:00",
            timeEnd: data.frTimeEnd ? `${data.frTimeEnd}:00` : "00:00:00",
            marginTimeStartEnd: "00:00:00",
          });

        if (
          data.saMinutes != "" &&
          data.saMinutes != "00:00" &&
          data.saMinutes != undefined
        )
          dto.workingHourDays.push({
            name: "WorkingHour",
            workingHourId:
              workingHours?.workingHourDays.find((x) => x.dayOfWeek === 6)
                ?.workingHourId || undefined,
            dayOfWeek: 6,
            minutes: timeStringToMinutes(data.saMinutes ?? "0"),
            timeStart: data.saTimeStart ? `${data.saTimeStart}:00` : "00:00:00",
            timeEnd: data.saTimeEnd ? `${data.saTimeEnd}:00` : "00:00:00",
            marginTimeStartEnd: "00:00:00",
          });

        if (
          data.suMinutes != "" &&
          data.suMinutes != "00:00" &&
          data.suMinutes != undefined
        )
          dto.workingHourDays.push({
            name: "WorkingHour",
            workingHourId:
              workingHours?.workingHourDays.find((x) => x.dayOfWeek === 0)
                ?.workingHourId || undefined,
            dayOfWeek: 0,
            minutes: timeStringToMinutes(data.suMinutes ?? "0"),
            timeStart: data.suTimeStart ? `${data.suTimeStart}:00` : "00:00:00",
            timeEnd: data.suTimeEnd ? `${data.suTimeEnd}:00` : "00:00:00",
            marginTimeStartEnd: "00:00:00",
          });
        mode === "edit"
          ? workingHours?.id &&
            (await WorkingHoursService.update(workingHours.id, dto))
          : await WorkingHoursService.create(dto);
        router.reload();
      } catch (error) {
        setErrors(error);
        console.error("An unexpected error happened:", error);
      }
    },
    (error, event) => {
      event?.preventDefault();
    }
  );

  const moMinutes = useWatch({
    control,
    name: "moMinutes",
    defaultValue: formatMinutes(
      workingHours?.workingHourDays.find((h) => h.dayOfWeek == 1)?.minutes || 0
    ),
  });

  const tuMinutes = useWatch({
    control,
    name: "tuMinutes",
    defaultValue: formatMinutes(
      workingHours?.workingHourDays.find((h) => h.dayOfWeek == 2)?.minutes || 0
    ),
  });

  const weMinutes = useWatch({
    control,
    name: "weMinutes",
    defaultValue: formatMinutes(
      workingHours?.workingHourDays.find((h) => h.dayOfWeek == 3)?.minutes || 0
    ),
  });

  const thMinutes = useWatch({
    control,
    name: "thMinutes",
    defaultValue: formatMinutes(
      workingHours?.workingHourDays.find((h) => h.dayOfWeek == 4)?.minutes || 0
    ),
  });

  const frMinutes = useWatch({
    control,
    name: "frMinutes",
    defaultValue: formatMinutes(
      workingHours?.workingHourDays.find((h) => h.dayOfWeek == 5)?.minutes || 0
    ),
  });

  const saMinutes = useWatch({
    control,
    name: "saMinutes",
    defaultValue: formatMinutes(
      workingHours?.workingHourDays.find((h) => h.dayOfWeek == 6)?.minutes || 0
    ),
  });

  const suMinutes = useWatch({
    control,
    name: "suMinutes",
    defaultValue: formatMinutes(
      workingHours?.workingHourDays.find((h) => h.dayOfWeek == 0)?.minutes || 0
    ),
  });

  const timeBreakMinutes = useWatch({
    control,
    name: "timeBreakMinutes",
    defaultValue: workingHours?.timeBreakMinutes.toString(),
  });

  const centralHours = useMemo(() => {
    const countDaysWithTime = (times: string[]) => {
      return times.filter((time) => timeStringToMinutes(time ?? "00:00") > 0)
        .length;
    };

    const totalMinutes =
      timeStringToMinutes(moMinutes ?? "00:00") +
      timeStringToMinutes(tuMinutes ?? "00:00") +
      timeStringToMinutes(weMinutes ?? "00:00") +
      timeStringToMinutes(thMinutes ?? "00:00") +
      timeStringToMinutes(frMinutes ?? "00:00") +
      timeStringToMinutes(saMinutes ?? "00:00") +
      timeStringToMinutes(suMinutes ?? "00:00") +
      timeStringToMinutes(timeBreakMinutes ?? "00:00") *
        countDaysWithTime([
          moMinutes ?? "00:00",
          tuMinutes ?? "00:00",
          weMinutes ?? "00:00",
          thMinutes ?? "00:00",
          frMinutes ?? "00:00",
          saMinutes ?? "00:00",
          suMinutes ?? "00:00",
        ]);

    const hours = Math.floor(totalMinutes / 60);
    const minutes = totalMinutes % 60;

    return `${hours}:${minutes.toString().padStart(2, "0")}`;
  }, [
    moMinutes,
    tuMinutes,
    weMinutes,
    thMinutes,
    frMinutes,
    saMinutes,
    suMinutes,
    showModal,
    timeBreakMinutes,
  ]);

  return (
    <Modal
      title={t("CreateWorkinHoursTitle")}
      isOpen={showModal}
      onClose={() => {
        onClose(), reset();
      }}
      titleClasses={"tw-pt-5"}
      size={"md"}
    >
      <LocalForm className="tw-gap-1">
        <Input
          name="name"
          defaultValue={workingHours?.name}
          control={control}
          type="text"
          LabelComponent={<FormLabel required>{t("NameLabel")}</FormLabel>}
          placeholder={t("NamePlaceholder")}
          errors={errors}
        ></Input>
        <div className="tw-flex tw-gap-4">
          <FormLabel>{t("IsDefaultLabel")}</FormLabel>
          <Switch
            name="isDefault"
            control={control}
            defaultChecked={workingHours?.isDefault}
            errors={errors}
          ></Switch>
        </div>
        <div className="tw-grid tw-grid-cols-7 tw-gap-4">
          <DayBox label={t("Mo")} classNames="tw-px-2.5 tw-py-1.5"></DayBox>
          <DayBox label={t("Tu")}></DayBox>
          <DayBox label={t("We")}></DayBox>
          <DayBox label={t("Th")}></DayBox>
          <DayBox label={t("Fr")}></DayBox>
          <DayBox label={t("Sa")}></DayBox>
          <DayBox label={t("Su")}></DayBox>
          <div className="tw-w-fit">
            <TimeInput
              name={"moMinutes"}
              defaultValue={formatMinutes(
                workingHours?.workingHourDays.find((h) => h.dayOfWeek == 1)
                  ?.minutes || 0
              )}
              control={control}
              errors={errors}
              containerClasses="tw-w-full"
              className="tw-px-2.5 tw-py-1.5"
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"tuMinutes"}
              defaultValue={formatMinutes(
                workingHours?.workingHourDays.find((h) => h.dayOfWeek == 2)
                  ?.minutes || 0
              )}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"weMinutes"}
              defaultValue={formatMinutes(
                workingHours?.workingHourDays.find((h) => h.dayOfWeek == 3)
                  ?.minutes || 0
              )}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"thMinutes"}
              defaultValue={formatMinutes(
                workingHours?.workingHourDays.find((h) => h.dayOfWeek == 4)
                  ?.minutes || 0
              )}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"frMinutes"}
              defaultValue={formatMinutes(
                workingHours?.workingHourDays.find((h) => h.dayOfWeek == 5)
                  ?.minutes || 0
              )}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"saMinutes"}
              defaultValue={formatMinutes(
                workingHours?.workingHourDays.find((h) => h.dayOfWeek == 6)
                  ?.minutes || 0
              )}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"suMinutes"}
              defaultValue={formatMinutes(
                workingHours?.workingHourDays.find((h) => h.dayOfWeek == 0)
                  ?.minutes || 0
              )}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
        </div>
        <div className="tw-bg-white tw-px-8 tw-py-3 tw-border-2 shadow tw-border-gray-200 tw-w-full">
          <div className="tw-grid tw-grid-cols-3">
            <p className="tw-mt-2 tw-font-medium">{t("IncludeBreaksLabel")}</p>
            <div className="tw-w-fit">
              <TimeInput
                name={"timeBreakMinutes"}
                defaultValue={formatMinutes(
                  workingHours?.timeBreakMinutes || 0
                )}
                control={control}
                errors={errors}
              ></TimeInput>
            </div>
          </div>
        </div>
        <p className="tw-font-medium">
          {t("TotalHours").replace("{0}", centralHours)}
        </p>
        <p className="tw-font-medium">{t("ConfigureCentralHoursTitle")}</p>
        <p className="tw-font-medium">{t("StartTimeLabel")}</p>
        <div className="tw-grid tw-grid-cols-7 tw-gap-4">
          <div className="tw-w-fit">
            <TimeInput
              name={"moTimeStart"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 1)
                ?.timeStart.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"tuTimeStart"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 2)
                ?.timeStart.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"weTimeStart"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 3)
                ?.timeStart.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"thTimeStart"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 4)
                ?.timeStart.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"frTimeStart"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 5)
                ?.timeStart.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"saTimeStart"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 6)
                ?.timeStart.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"suTimeStart"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 0)
                ?.timeStart.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
        </div>
        <p className="tw-font-medium">{t("EndTimeLabel")}</p>
        <div className="tw-grid tw-grid-cols-7 tw-gap-4">
          <div className="tw-w-fit">
            <TimeInput
              name={"moTimeEnd"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 1)
                ?.timeEnd.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"tuTimeEnd"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 2)
                ?.timeEnd.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"weTimeEnd"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 3)
                ?.timeEnd.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"thTimeEnd"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 4)
                ?.timeEnd.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"frTimeEnd"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 5)
                ?.timeEnd.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"saTimeEnd"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 6)
                ?.timeEnd.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
          <div className="tw-w-fit">
            <TimeInput
              name={"suTimeEnd"}
              defaultValue={workingHours?.workingHourDays
                .find((h) => h.dayOfWeek == 0)
                ?.timeEnd.substring(0, 5)}
              control={control}
              errors={errors}
            ></TimeInput>
          </div>
        </div>
        <div className="tw-bg-white tw-px-8 tw-py-1 tw-border-2 shadow tw-border-gray-200 tw-w-full">
          <p className="tw-mt-2 tw-font-medium">{t("AutoCloseLabel")}</p>
          <div className="tw-grid tw-grid-cols-3 tw-pb-4">
            <p className="tw-mt-2 tw-font-medium tw-w-full tw-col-span-2">
              {t("SendReportAfterLabel")}
            </p>
            <div className="tw-w-fit">
              <TimeInput
                name={"timeLimitIssues"}
                defaultValue={formatMinutes(workingHours?.timeLimitIssues || 0)}
                control={control}
                errors={errors}
              ></TimeInput>
            </div>
          </div>
          <div className="tw-grid tw-grid-cols-3">
            <p className="tw-mt-2 tw-font-medium tw-w-full tw-col-span-2">
              {t("StopTrackingAfterLabel")}
            </p>

            <div className="tw-w-fit">
              <TimeInput
                name={"timeAutoCloseAfterMinutes"}
                defaultValue={formatMinutes(
                  workingHours?.timeAutoCloseAfterMinutes || 0
                )}
                control={control}
                errors={errors}
              ></TimeInput>
            </div>
          </div>
        </div>
        {/* Show general errors that are not related to any specific field */}
        <div className="errors">
          {errors && Object.keys(errors).length > 0 ? (
            <FormServerSideErrors
              errors={errors}
              fieldKey={""}
            ></FormServerSideErrors>
          ) : null}
        </div>
        <div className="tw-flex tw-justify-end tw-gap-2">
          <Button
            variant="secondary"
            disabled={isSubmitting}
            onClick={() => {
              onClose(), reset({ moMinutes: "00:00", tuMinutes: "00:00" });
            }}
          >
            {t("Cancel")}
          </Button>
          <Button
            onClick={onSubmit}
            disabled={isSubmitting}
            loading={isSubmitting}
          >
            {t("Save")}
          </Button>
        </div>
      </LocalForm>
    </Modal>
  );
};


### components/badges/ScoreBadge.tsx ###
type ScoreBadgeProps = {
  score: number | null;
};

const ScoreBadge: React.FC<ScoreBadgeProps> = (props) => {
  const {
    score,
  } = props;

  const defineBadgeColour = (score : number) => {
    switch (true) {
      case score < 4:
        return "tw-bg-red-500";
      case score < 7:
        return "tw-bg-amber-500";
      default:
        return "tw-bg-green-500";
    }
  }

  if (score !== null && score !== undefined) {
      return (
       <div className={`tw-w-7 tw-h-5 tw-rounded-full ${defineBadgeColour(score)}`}>
         <p className="tw-min-w-full tw-flex tw-flex-col tw-flex-wrap tw-justify-center tw-content-center tw-h-full tw-text-xs tw-font-bold tw-text-white">
           {score}
         </p>
       </div>
      )
  }

  return(null)
};

export default ScoreBadge;


### components/charts/BaseChart.tsx ###
import React from "react"
import Highcharts from "highcharts"
import HighchartsReact from "highcharts-react-official"

type BaseChartProps = {
  title?: string
  subtitle?: string
  options: Highcharts.Options
}

export default function BaseChart(props: BaseChartProps) {
  const { title, options, subtitle } = props

  const defaultOptions: Highcharts.Options = {
    title: {
      text: title,
      align: "center",
    },
    subtitle: {
      text: subtitle,
      align: "center",
    },
    credits: {
      enabled: false,
    },
    ...options,
    chart: {
      style: {
        fontFamily: "Montserrat, sans-serif",
      },
      ...options.chart,
    },
  }

  return <HighchartsReact highcharts={Highcharts} options={defaultOptions} />
}


### components/charts/ColumnChart.tsx ###
import React from "react";
import Highcharts, { PlotColumnOptions, PlotPieOptions } from "highcharts";
import BaseChart from "./BaseChart";

export type ColumnChartSeries = {
  y: number;
  name?: string;
  color?: string;
};

type ColumnChartProps = {
  title?: string;
  subtitle?: string;
  data: Array<ColumnChartSeries>;
  plotColumnOptions?: PlotColumnOptions;
  tooltipFormat?: string;
  chartOptions?: Highcharts.Options;
};

export default function ColumnChart(props: ColumnChartProps) {
  const {
    data,
    title,
    plotColumnOptions,
    subtitle,
    tooltipFormat,
    chartOptions,
  } = props;

  const columnOptions: Highcharts.Options = {
    chart: {
      type: "column",
    },
    series: [{ data: data, type: "column" }],
    plotOptions: {
      column: {
        allowPointSelect: true,
        cursor: "pointer",
        dataLabels: {
          enabled: true,
          format: "<b>{point.name}</b>: {point.percentage:f}%",
        },
        ...plotColumnOptions,
      },
    },
    tooltip: {
      format: tooltipFormat || "<b>{point.name}</b>: {point.percentage:f}%",
    },
    ...chartOptions,
  };

  return (
    <BaseChart options={columnOptions} title={title} subtitle={subtitle} />
  );
}


### components/charts/PieChart.tsx ###
import React from "react"
import Highcharts, { PlotPieOptions } from "highcharts"
import BaseChart from "./BaseChart"

export type PieChartSeries = {
  y: number
  name?: string
  color?: string
}

type PieChartProps = {
  title?: string
  subtitle?: string
  data: Array<PieChartSeries>
  plotPieOptions?: PlotPieOptions
  tooltipFormat?: string
  chartOptions?: Highcharts.Options
}

export default function PieChart(props: PieChartProps) {
  const { data, title, plotPieOptions, subtitle, tooltipFormat, chartOptions } =
    props

  const pieOptions: Highcharts.Options = {
    chart: {
      type: "pie",
    },
    series: [{ data: data, type: "pie" }],
    plotOptions: {
      pie: {
        allowPointSelect: true,
        cursor: "pointer",
        dataLabels: {
          enabled: true,
          format: "<b>{point.name}</b>: {point.percentage:f}%",
        },
        ...plotPieOptions,
      },
    },
    tooltip: {
      format: tooltipFormat || "<b>{point.name}</b>: {point.percentage:f}%",
    },
    ...chartOptions,
  }

  return <BaseChart options={pieOptions} title={title} subtitle={subtitle} />
}


### components/chat/AcceptCommunications.tsx ###
import useChat from "./useChat";

const AcceptCommunications = () => {
  const {
    options: { locale },
    updateCommunications,
  } = useChat();

  return (
    <div
      className={
        "tw-flex tw-items-center tw-gap-2 tw-px-2 tw-py-2 tw-rounded tw-bg-primary-600 tw-text-white"
      }
    >
      <input
        type="checkbox"
        onChange={async (e) => {
          updateCommunications &&
            (await updateCommunications(e.target.checked));
        }}
      ></input>
      {locale.acceptCommunicationsMessage ? (
        <div
          dangerouslySetInnerHTML={{
            __html: locale.acceptCommunicationsMessage,
          }}
        ></div>
      ) : null}
    </div>
  );
};

export default AcceptCommunications;


### components/chat/AudioRecorder.tsx ###
import { useEffect, useRef, useState } from "react";
import { useAudioRecorder } from "react-audio-voice-recorder";
import useChat from "./useChat";
import {
  MicrophoneIcon,
  PaperAirplaneIcon,
  PauseIcon,
  TrashIcon,
  InformationCircleIcon,
} from "@heroicons/react/24/outline";
import { Spinner } from "@fusion/ui";

const AudioRecorder: React.FC = () => {
  const [showMicrophonePermissionError, setShowMicrophonePermissionError] =
    useState<boolean>(false);
  const [isUploading, setIsUploading] = useState<boolean>(false);
  const isRecordingCanceledRef = useRef<boolean>(false);
  const onMicrophonePermissionDenied = () =>
    setShowMicrophonePermissionError(true);

  const {
    options: { locale },
    onSendAudioRecording,
    setIsRecording,
  } = useChat();

  const {
    startRecording,
    stopRecording,
    isPaused,
    recordingTime,
    togglePauseResume,
    recordingBlob,
  } = useAudioRecorder(undefined, onMicrophonePermissionDenied);

  const getButtonClasses = () => {
    if (isUploading) {
      return "tw-bg-primary-200 tw-border-none tw-p-1 tw-cursor-not-allowed tw-rounded tw-m-l-2";
    }

    return "tw-bg-primary-500 tw-border-none tw-cursor-pointer tw-p-1 tw-rounded tw-m-l-2";
  };

  const sendMessage = async () => {
    if (!recordingBlob || !onSendAudioRecording) return;

    try {
      setIsUploading(true);

      await onSendAudioRecording(recordingBlob);
    } finally {
      setIsUploading(false);
      setIsRecording(false);
    }
  };

  const getRecorderMessage = () => {
    if (isUploading)
      return (
        <div className="tw-flex tw-gap-2 tw-items-center">
          <span>{locale.uploadingAudioLabel}</span>
          <Spinner mode="inline"></Spinner>
        </div>
      );

    return `ðŸ”´ ${
      isPaused ? locale.recorderPausedLabel : locale.recordingLabel
    }: ${formatSecondsToMinutes(recordingTime)}`;
  };

  useEffect(() => {
    // This will run twice in dev because of reactStricMode
    if (onSendAudioRecording) {
      startRecording();
    }
  }, []);

  useEffect(() => {
    if (isRecordingCanceledRef.current) {
      isRecordingCanceledRef.current = false;
      return;
    }
    sendMessage();
  }, [recordingBlob]);

  if (!onSendAudioRecording) return null;

  return (
    <div className="tw-py-3 tw-px-3 tw-bg-white">
      <div className="tw-flex tw-rounded tw-overflow-hidden tw-space-x-2 tw-border tw-border-gray-400 tw-py-2 tw-px-2">
        {showMicrophonePermissionError ? (
          <div className="tw-bg-pink-200 tw-flex tw-space-x-1 tw-justify-center tw-py-0.5 tw-px-1 tw-items-center">
            <InformationCircleIcon
              width={32}
              height={32}
              color="#b91c1c"
            ></InformationCircleIcon>

            <span className="tw-text-red-700 tw-font-semibold tw-text-xs">
              {locale.microphonePermissionDeniedMessage}
            </span>
          </div>
        ) : (
          <div className="tw-flex tw-w-full tw-self-center">
            {getRecorderMessage()}
          </div>
        )}
        <div className="tw-flex tw-gap-2 tw-justify-end">
          <button
            onClick={() => {
              isRecordingCanceledRef.current = true;
              setIsRecording(false);
              stopRecording();
            }}
            className={getButtonClasses()}
            disabled={isUploading}
          >
            <TrashIcon width={20} height={20} color="white"></TrashIcon>
          </button>
          {!showMicrophonePermissionError ? (
            <button
              onClick={togglePauseResume}
              className={getButtonClasses()}
              disabled={isUploading}
            >
              {isPaused ? (
                <MicrophoneIcon
                  width={20}
                  height={20}
                  color="white"
                ></MicrophoneIcon>
              ) : (
                <PauseIcon width={20} height={20} color="white"></PauseIcon>
              )}
            </button>
          ) : null}
          {!showMicrophonePermissionError ? (
            <button
              onClick={() => stopRecording()}
              className={getButtonClasses()}
              disabled={isUploading}
            >
              <PaperAirplaneIcon
                width={20}
                height={20}
                color="white"
              ></PaperAirplaneIcon>
            </button>
          ) : null}
        </div>
      </div>
    </div>
  );
};

export default AudioRecorder;

const formatSecondsToMinutes = (totalSeconds: number) => {
  const minutes = Math.floor(totalSeconds / 60).toLocaleString(undefined, {
    minimumIntegerDigits: 2,
  });
  const restSeconds = (totalSeconds - Number(minutes) * 60).toLocaleString(
    undefined,
    { minimumIntegerDigits: 2 }
  );

  return `${minutes}:${restSeconds}`;
};


### components/chat/Chat.tsx ###
import { classNames } from "@fusion/utils";
import { ChatProvider } from "./context/ChatProvider";
import useChat from "./useChat";
import Body from "./body";
import Footer from "./Footer";
import Header from "./Header";
import { ChatOptions } from "./types";

const ChatWrapper = (props: { options: ChatOptions }) => {
  return (
    <ChatProvider {...props.options}>
      <Chat></Chat>
    </ChatProvider>
  );
};

const Chat = () => {
  const {
    mode,
    options: { includeHeader },
  } = useChat();

  const getContainerClasses = () => {
    let containerClasses = "";
    if (mode === "compact") containerClasses += "tw-shadow-lg ";
    if (!includeHeader)
      containerClasses += "tw-border-t-8 tw-border-t-primary-500";

    return containerClasses;
  };

  return (
    <div
      className={classNames(
        "tw-flex tw-flex-col tw-flex-1 tw-bg-transparent tw-bg-white tw-rounded-md tw-overflow-hidden tw-border tw-border-gray-200 tw-shadow",
        getContainerClasses()
      )}
    >
      {includeHeader ? <Header></Header> : null}
      <Body></Body>
      <Footer></Footer>
    </div>
  );
};

export default ChatWrapper;


### components/chat/CountdownTimer.tsx ###
import React, { useEffect, useState } from "react";
import useChat from "./useChat";

function CountdownTimer({ targetTimestamp }: { targetTimestamp: number }) {
  const {
    options: { locale },
    clearTimer,
  } = useChat();

  const calculateTimeRemaining = () => {
    const now = new Date().getTime();
    const timeRemaining = Math.max(
      0,
      Math.floor((targetTimestamp - now) / 1000)
    );
    if (timeRemaining === 0) {
      clearTimer();
    }
    return timeRemaining;
  };

  const [timeRemaining, setTimeRemaining] = useState(calculateTimeRemaining());

  useEffect(() => {
    const timerInterval = setInterval(() => {
      setTimeRemaining(calculateTimeRemaining());
    }, 1000);

    return () => {
      clearInterval(timerInterval);
    };
  }, []);

  const formatTime = (time: number) => {
    return time < 10 ? `0${time}` : `${time}`;
  };

  const hours = Math.floor(timeRemaining / 3600);
  const minutes = Math.floor((timeRemaining % 3600) / 60);
  const seconds = timeRemaining % 60;

  return (
    <div className="tw-flex tw-gap-1 tw-flex-col">
      <p className="tw-m-0 tw-font-bold tw-text-blue-500 tw-text-xs">
        {locale.limitExceededMessage}
      </p>
      <p className="tw-m-0">
        {locale.waitUntilMessage}{" "}
        {new Date(targetTimestamp).toLocaleString(undefined, {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          hour12: true,
        })}
      </p>
      <div>
        {locale.remainingMessage}: {formatTime(hours)}:{formatTime(minutes)}:
        {formatTime(seconds)}{" "}
      </div>
    </div>
  );
}

export default CountdownTimer;


### components/chat/Dots.tsx ###
import React from "react"
import { motion } from "framer-motion"

const Dots = () => {
  const container = {
    visible: {
      transition: {
        staggerChildren: 0.25,
      },
    },
  }

  const item = {
    visible: {
      y: ["-4px", "4px", "-4px"],
      transition: {
        duration: 0.75,
        repeat: Infinity,
      },
    },
  }

  return (
    <motion.div
      className="tw-flex tw-items-center tw-justify-center"
      variants={container}
      animate="visible"
    >
      {[0, 1, 2].map((i) => (
        <motion.span
          key={`dot-${i}`}
          className="tw-inline-block tw-w-2 tw-h-2 tw-rounded-full tw-bg-gray-700 tw-mr-1"
          variants={item}
        />
      ))}
    </motion.div>
  )
}

export default Dots


### components/chat/Footer.tsx ###
import { useEffect, useRef } from "react";
import {
  ExclamationTriangleIcon,
  ArrowUpTrayIcon,
  PaperAirplaneIcon,
  TrashIcon,
  MicrophoneIcon,
} from "@heroicons/react/24/outline";
import useChat from "./useChat";
import { Spinner } from "@fusion/ui";
import AudioRecorder from "./AudioRecorder";

const Footer = () => {
  const {
    expanded,
    onUploadFile,
    onMessage,
    uploadErrors,
    messages,
    options: {
      locale,
      showAcceptCommunications,
      showTermsAndConditions,
      allowUpload,
    },
    uploading,
    finalized,
    isChatDisabled,
    areCommunicationsAccepted,
    areTermsAndConditionsAccepted,
    onSendAudioRecording,
    isRecording,
    setIsRecording,
  } = useChat();

  const inputRef = useRef<HTMLInputElement>(null);
  const fileRef = useRef<HTMLInputElement>(null);

  const sendMessage = (message: string) => {
    if (!inputRef.current?.value) return;

    onMessage({
      createdAt: new Date(),
      sender: "user",
      type: "text",
      value: message,
    });
    inputRef.current!.value = "";
  };

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files) return;
    await onUploadFile(e.target.files);
    if (fileRef.current) {
      fileRef.current.value = "";
    }
  };

  const preconditionsAreMet = (): boolean => {
    if (showTermsAndConditions && !areTermsAndConditionsAccepted) {
      return false;
    }

    if (showAcceptCommunications && !areCommunicationsAccepted) {
      return false;
    }

    return true;
  };

  const getButtonClasses = () => {
    if (uploading || isChatDisabled || !preconditionsAreMet()) {
      return "tw-bg-primary-200 tw-border-none tw-p-1 tw-cursor-not-allowed tw-rounded";
    }

    return "tw-bg-primary-500 tw-border-none tw-cursor-pointer tw-p-1 tw-rounded";
  };

  useEffect(() => {
    !isChatDisabled && inputRef.current?.focus();
  }, [messages, isChatDisabled]);

  if (!expanded) {
    return null;
  }

  if (isRecording) {
    return <AudioRecorder />;
  }

  return (
    <div className="tw-py-3 tw-px-3 tw-bg-white">
      <Attachments></Attachments>
      {uploadErrors.length > 0 &&
        uploadErrors.map((fileError, index) => (
          <div className="tw-mb-1" key={index}>
            <p className="tw-bg-rose-200 tw-text-red-500 tw-py-0.5 tw-px-1.5 tw-rounded tw-max-w-4xl tw-inline-block tw-m-0">
              <ExclamationTriangleIcon
                width={12}
                height={12}
                className="tw-align-middle tw-mr-1"
              ></ExclamationTriangleIcon>
              <span className="tw-m-0 tw-p-0 tw-flex tw-text-xs">
                {fileError.error.message}
              </span>
            </p>
          </div>
        ))}

      <div className="tw-flex tw-rounded tw-overflow-hidden tw-items-center tw-space-x-2 tw-border tw-border-gray-400 tw-pr-2">
        {finalized ? (
          <div className="tw-flex tw-border-l-8 tw-border-l-primary-500 tw-border-solid">
            <p className="tw-inline-block tw-py-2 tw-px-3 tw-rounded-md tw-text-primary-500 tw-m-0">
              {locale.finalizedMessage}
            </p>
          </div>
        ) : (
          <input
            ref={inputRef}
            className="tw-flex tw-border-none tw-py-2 tw-px-2 focus-visible:tw-outline-none focus-visible:tw-ring-transparent tw-w-full tw-bg-white"
            onKeyDown={(e) => {
              if (e.key === "Enter" && inputRef.current?.value && !uploading) {
                sendMessage(inputRef.current.value);
              }
            }}
            type="text"
            placeholder={locale.chatInputPlaceholder}
            disabled={finalized || isChatDisabled || !preconditionsAreMet()}
          ></input>
        )}

        {onSendAudioRecording && !finalized ? (
          <button
            disabled={uploading || isChatDisabled || !preconditionsAreMet()}
            className={getButtonClasses()}
            onClick={() => setIsRecording(true)}
          >
            <MicrophoneIcon
              width={20}
              height={20}
              color="white"
            ></MicrophoneIcon>
          </button>
        ) : null}

        {allowUpload && !finalized ? (
          <button
            disabled={uploading || isChatDisabled || !preconditionsAreMet()}
            className={getButtonClasses()}
            onClick={() => fileRef.current?.click()}
          >
            <input
              onChange={handleFileChange}
              ref={fileRef}
              multiple
              type="file"
              hidden
              accept=".pdf,image/*"
            ></input>
            <ArrowUpTrayIcon
              width={20}
              height={20}
              color="white"
            ></ArrowUpTrayIcon>
          </button>
        ) : null}

        {!finalized ? (
          <button
            disabled={uploading || isChatDisabled || !preconditionsAreMet()}
            onClick={() => {
              if (!inputRef.current?.value) return;
              sendMessage(inputRef.current.value);
            }}
            className={getButtonClasses()}
          >
            <PaperAirplaneIcon
              width={20}
              height={20}
              color="white"
            ></PaperAirplaneIcon>
          </button>
        ) : null}
      </div>
    </div>
  );
};

const Attachments = () => {
  const { files, onRemoveFile, isUploaded, uploadErrors } = useChat();

  const removeExtension = (filename: string) => {
    if (!filename || !filename.includes(".")) return filename;
    const parts = filename.split(".");
    parts.pop();
    return parts.join(".");
  };

  return (
    <div className="tw-flex tw-items-center tw-gap-2 tw-flex-wrap">
      {files.map((file) => (
        <div
          key={file.name}
          className="tw-flex tw-items-stretch tw-gap-3 tw-border-primary-500 tw-border tw-border-solid tw-border-l-8 tw-rounded-md tw-text-xs tw-overflow-hidden tw-mb-3"
        >
          <div className="tw-py-2 tw-px-3 tw-flex tw-flex-col">
            <p className="tw-m-0 tw-p-0">{removeExtension(file.name)}</p>
            <div className="tw-flex tw-gap-1">
              <div className="tw-bg-gray-200 tw-py-0.5 tw-px-1 tw-rounded tw-self-start tw-mt-0.5">
                {(file.size / 1024).toFixed(2)} kb
              </div>
              {uploadErrors
                .filter((e) => e.file?.name === file.name)
                .map((e) => (
                  <div
                    key={e.file?.name}
                    className="tw-bg-pink-200 tw-text-red-500 tw-self-start tw-py-0.5 tw-px-1 tw-mt-0.5"
                  >
                    Error
                  </div>
                ))}
            </div>
          </div>

          {isUploaded(file) ? (
            <div
              onClick={() => {
                onRemoveFile(file);
              }}
              className="tw-border-l tw-border-l-black tw-min-h-full tw-flex"
            >
              <button className="tw-bg-transparent tw-border-none tw-self-center tw-cursor-pointer tw-flex tw-items-center tw-justify-center">
                <TrashIcon></TrashIcon>
              </button>
            </div>
          ) : (
            <div className="tw-border-l tw-border-l-black tw-min-h-full tw-flex">
              <Spinner></Spinner>
            </div>
          )}
        </div>
      ))}
    </div>
  );
};

export default Footer;


### components/chat/Header.tsx ###
import { MinusIcon, PlusIcon } from "@heroicons/react/24/outline";
import useChat from "./useChat";
import { classNames } from "@fusion/utils";

const Header = () => {
  const {
    expanded,
    toggleExpanded,
    options: { locale },
    mode,
  } = useChat();

  return (
    <div
      onClick={() => toggleExpanded()}
      className={classNames(
        "tw-bg-primary-700 tw-text-white tw-py-1 tw-px-3 tw-flex tw-justify-between tw-items-center tw-cursor-pointer",
        expanded ? "max-md:tw-block" : "max-md:tw-hidden"
      )}
    >
      <p className="tw-mt-1">{locale.headerTitle}</p>
      {mode === "fullscreen" ? null : (
        <button
          className="tw-bg-transparent tw-border-none tw-text-white tw-cursor-pointer max-md:tw-hidden"
          onClick={() => toggleExpanded()}
        >
          {expanded ? (
            <MinusIcon width={16} height={16} fill="white"></MinusIcon>
          ) : (
            <PlusIcon width={16} height={16} fill="white"></PlusIcon>
          )}
        </button>
      )}
    </div>
  );
};

export default Header;


### components/chat/TermsAndConditions.tsx ###
import useChat from "./useChat";

const TermsAndConditions = () => {
  const {
    options: { locale },
    updateTermsAndConditions,
  } = useChat();
  return (
    <div className="tw-flex tw-items-center tw-gap-2 tw-py-2 tw-px-2 tw-rounded tw-bg-primary-600 tw-text-white">
      <input
        type="checkbox"
        onChange={async (e) => {
          updateTermsAndConditions &&
            (await updateTermsAndConditions(e.target.checked));
        }}
      ></input>
      {locale.termsAndConditionsMessage ? (
        <div
          dangerouslySetInnerHTML={{
            __html: locale.termsAndConditionsMessage,
          }}
        ></div>
      ) : null}
    </div>
  );
};

export default TermsAndConditions;


### components/chat/body/Body.module.css ###
.scroll {
  min-height: 400px;
  overflow-y: scroll;
  display: inline-block;
}

.scrollSimple::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}
.scrollSimple::-webkit-scrollbar-track {
  border-radius: 10px;
  background: rgba(0, 0, 0, 0.1);
}
.scrollSimple::-webkit-scrollbar-thumb {
  border-radius: 10px;
  background: rgba(0, 0, 0, 0.2);
}
.scrollSimple::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.4);
}
.scrollSimple::-webkit-scrollbar-thumb:active {
  background: rgba(0, 0, 0, 0.9);
}


### components/chat/body/index.tsx ###
import { motion } from "framer-motion";
import React from "react";
import { useEffect } from "react";
import styles from "./Body.module.css";
import sanitizeHtml from "sanitize-html";
import CountdownTimer from "../CountdownTimer";
import TermsAndConditions from "../TermsAndConditions";
import AcceptCommunications from "../AcceptCommunications";
import { ArrowDownTrayIcon } from "@heroicons/react/24/outline";
import useChat from "../useChat";
import Dots from "../Dots";
import { FileRes } from "../types";
import { classNames } from "@fusion/utils";

const Body = () => {
  const refContainer = React.useRef<HTMLDivElement>(null);

  const {
    expanded,
    messages,
    isLimitExceeded,
    limitTimestamp,
    waitingResponse,
    options,
    readOnly,
    mode,
    onMessage,
  } = useChat();

  useEffect(() => {
    if (!refContainer.current) return;
    if (!options.scrollToBottom) return;
    refContainer.current!.scrollTop = refContainer.current?.scrollHeight;
  }, [messages]);

  const getMessageClasses = (sender: "bot" | "user") => {
    const commonClasses =
      "tw-font-normal tw-text-sm tw-gap-4 tw-py-2 tw-px-4 tw-max-w-[80%] tw-mb-3 tw-rounded-md tw-whitespace-pre-wrap";
    return classNames(
      commonClasses,
      sender === "bot"
        ? "tw-bg-primary-500 tw-bg-opacity-20 tw-mr-auto tw-items-start"
        : "tw-bg-gray-100 tw-ml-auto tw-break-words"
    );
  };

  if (!expanded) {
    return null;
  }

  const containerHeight =
    options.maxHeight && mode === "compact" ? `${options.maxHeight}px` : "100%";
  const bodyHeight =
    options.maxHeight && mode === "compact" ? `${options.maxHeight}px` : "auto";

  return (
    <div
      className={`tw-min-h-[400px] tw-flex-grow tw-overflow-y-scroll tw-inline-block ${styles.scrollSimple}`}
      style={{
        maxHeight: containerHeight,
        minHeight: containerHeight,
      }}
      ref={refContainer}
    >
      <div
        className="tw-px-8 tw-py-6 tw-overflow-hidden tw-relative tw-w-full tw-content-['.']"
        style={{
          minHeight: bodyHeight,
        }}
      >
        <div className="tw-flex tw-flex-col tw-mb-4 tw-gap-4">
          {options.locale.title ? (
            <span className="tw-font-bold tw-text-3xl tw-capitalize">
              {options.locale.title}
            </span>
          ) : null}
          {options.locale.subtitle ? (
            <span className="tw-text-neutral-600 tw-font-normal tw-text-sm">
              {options.locale.subtitle}
            </span>
          ) : null}
        </div>
        {!readOnly ? (
          <PreconditionsAndFirstMessage></PreconditionsAndFirstMessage>
        ) : null}
        <div className="tw-flex tw-flex-col tw-items-start tw-mt-0 tw-mx-auto tw-mb-4">
          {messages.map((message, index) => {
            if (message.type === "additionalMessage") {
              return (
                <motion.div
                  key={index}
                  initial={{
                    top: index === messages.length - 1 ? 20 : 0,
                  }}
                  animate={{
                    top: 0,
                  }}
                  transition={{
                    duration: 0.25,
                    ease: "easeInOut",
                  }}
                  className="tw-border-l-8 tw-py-1.5 tw-px-3 tw-mb-2 tw-bg-white tw-inline-block tw-border-l-primary-500 tw-relative"
                >
                  <div
                    dangerouslySetInnerHTML={{
                      __html: sanitizeHtml(message.value),
                    }}
                  ></div>
                </motion.div>
              );
            }

            return (
              <motion.div
                key={index}
                initial={{
                  top: index === messages.length - 1 ? 20 : 0,
                }}
                animate={{
                  top: 0,
                }}
                transition={{
                  duration: 0.25,
                  ease: "easeInOut",
                }}
                className={getMessageClasses(message.sender)}
              >
                {message.attachments && message.attachments.length > 0 ? (
                  <InlineAttachments
                    files={message.attachments}
                  ></InlineAttachments>
                ) : null}
                {message.value}
                {message.sender === "bot" && message.options ? (
                  <div className="tw-flex tw-flex-col tw-items-center tw-gap-2 tw-mt-3">
                    <p className="tw-m-0 tw-font-bold">
                      {options.locale.chooseAnOptionMessage}
                    </p>
                    {message.options.map((option) => (
                      <button
                        className="tw-rounded-md tw-border-0 tw-bg-primary-500 tw-text-white tw-py-1 tw-px-2 tw-cursor-pointer"
                        key={option}
                        onClick={() => {
                          onMessage({
                            createdAt: new Date(),
                            sender: "user",
                            type: "text",
                            value: option,
                          });
                        }}
                      >
                        {option}
                      </button>
                    ))}
                  </div>
                ) : null}
              </motion.div>
            );
          })}

          {waitingResponse ? (
            <motion.div
              key={"chatbot-processing"}
              className="tw-font-normal tw-text-sm tw-gap-4 tw-py-2 tw-px-4 tw-max-w-[80%] tw-mb-3 tw-rounded-md tw-whitespace-pre-wrap tw-bg-primary-200 tw-mr-auto tw-items-start"
            >
              <Dots></Dots>
            </motion.div>
          ) : null}

          {!waitingResponse && isLimitExceeded ? (
            <div className="tw-font-normal tw-text-sm tw-gap-4 tw-py-2 tw-px-4 tw-max-w-[80%] tw-mb-3 tw-rounded-md tw-whitespace-pre-wrap tw-bg-primary-200 tw-mr-auto tw-items-start">
              <CountdownTimer targetTimestamp={limitTimestamp}></CountdownTimer>
            </div>
          ) : null}
        </div>
      </div>
    </div>
  );
};

type InlineAttachmentsProps = {
  files: FileRes[];
};

const InlineAttachments = (props: InlineAttachmentsProps) => {
  const removeExtension = (filename: string) => {
    if (!filename || !filename.includes(".")) return filename;
    const parts = filename.split(".");
    parts.pop();
    return parts.join(".");
  };

  return (
    <div className="tw-flex tw-items-center tw-gap-2 tw-flex-wrap tw-mb-2">
      {props.files.map((file) => (
        <div
          key={file.name}
          className="tw-flex tw-items-center tw-max-w-none tw-gap-3 tw-border tw-border-primary-400 tw-border-solid tw-bg-white tw-border-l-8 tw-text-black tw-rounded-md tw-text-xs tw-overflow-hidden"
        >
          <div className="tw-py-2 tw-px-3 tw-flex tw-flex-col">
            <p className="tw-m-0 tw-p-0">{removeExtension(file.name)}</p>
            {file.size ? (
              <div className="tw-mt-0.5">
                {(file.size / 1024).toFixed(2)} kb
              </div>
            ) : null}
          </div>
          <a
            href={`${process.env.NEXT_PUBLIC_WEB_URL}/api/file/download/${file.id}`}
            target="_blank"
            rel="noreferrer"
            className="tw-p-2 tw-text-primary-500"
          >
            <ArrowDownTrayIcon width={24} height={24}></ArrowDownTrayIcon>
          </a>
        </div>
      ))}
    </div>
  );
};

const PreconditionsAndFirstMessage = () => {
  const {
    areTermsAndConditionsAccepted,
    areCommunicationsAccepted,
    options: { showAcceptCommunications, showTermsAndConditions },
  } = useChat();

  const preconditionsAreMet = (): boolean => {
    if (showTermsAndConditions && !areTermsAndConditionsAccepted) {
      return false;
    }

    if (showAcceptCommunications && !areCommunicationsAccepted) {
      return false;
    }

    return true;
  };

  return (
    <div>
      {!preconditionsAreMet() ? (
        <div>
          <div className="tw-mb-2">
            <TermsAndConditions></TermsAndConditions>
          </div>

          <div className="tw-mb-2">
            <AcceptCommunications></AcceptCommunications>
          </div>
        </div>
      ) : null}
    </div>
  );
};

export default Body;


### components/chat/context/ChatContext.tsx ###
import { createContext } from "react";
import { ChatOptions, FileError, Message, UserMessage } from "../types";

const ChatContext = createContext<{
  messages: Message[];
  onMessage: (message: Message) => void;
  expanded: boolean;
  mode: "fullscreen" | "compact";
  finalized: boolean;
  readOnly: boolean;
  setExpanded: (expanded: boolean) => void;
  setFinalized: (finalized: boolean) => void;
  toggleExpanded: () => void;
  setMessages: (messages: Message[]) => void;
  onUploadFile: (files: FileList) => Promise<void>;
  updateTermsAndConditions: (value: boolean) => void;
  updateCommunications: (value: boolean) => void;
  areTermsAndConditionsAccepted: boolean;
  areCommunicationsAccepted: boolean;
  onRemoveFile: (file: File) => void;
  files: File[];
  uploading: boolean;
  isChatDisabled: boolean;
  isLimitExceeded: boolean;
  limitTimestamp: number;
  clearTimer: () => void;
  isUploaded: (file: File) => boolean;
  waitingResponse: boolean;
  uploadErrors: FileError[];
  onSendAudioRecording?: (audio: Blob) => Promise<void>;
  options: ChatOptions;
  isRecording: boolean;
  setIsRecording: (value: boolean) => void;
}>({
  messages: [],
  onMessage: () => {},
  expanded: false,
  finalized: false,
  setExpanded: () => {},
  setFinalized: () => {},
  toggleExpanded: () => {},
  setMessages: () => {},
  onUploadFile: () => Promise.resolve(),
  updateTermsAndConditions: () => {},
  updateCommunications: () => {},
  areTermsAndConditionsAccepted: false,
  areCommunicationsAccepted: false,
  onRemoveFile: () => {},
  files: [],
  uploading: false,
  isChatDisabled: false,
  isLimitExceeded: false,
  limitTimestamp: 0,
  clearTimer: () => {},
  isUploaded: () => false,
  waitingResponse: false,
  uploadErrors: [],
  options: {
    onGetBotResponse: async () => {
      return {
        answer: "",
        finalized: false,
      };
    },
    showTermsAndConditions: false,
    showAcceptCommunications: false,
    locale: {
      headerTitle: "",
    },
  },
  mode: "compact",
  readOnly: false,
  isRecording: false,
  setIsRecording: () => {},
});

export default ChatContext;


### components/chat/context/ChatProvider.tsx ###
import { PropsWithChildren, useEffect, useRef, useState } from "react";
import {
  ChatOptions,
  Message,
  UnauthorizedError,
  ValidationError,
} from "../types";
import { BotResponse, FileError, FileRes } from "../types";
import ChatContext from "./ChatContext";

export const ChatProvider: React.FC<PropsWithChildren<ChatOptions>> = ({
  children,
  ...chatOptions
}) => {
  const options: ChatOptions = {
    allowUpload: true,
    readOnly: false,
    mode: "compact",
    expanded: true,
    headerBgColor: "#2f877d",
    scrollToBottom: true,
    ...chatOptions,
    locale: {
      headerTitle: "Asistente",
      chatErrorMessage:
        "There was an error trying to get a response from our assistant",
      uploadFileErrorMessage: "There was an error trying to upload the file",
      uploadFilesErrorMessage: "There was an error trying to upload the files",
      chooseAnOptionMessage: "Choose an option",
      limitExceededMessage:
        "You have exceeded the limit of messages you can send",
      waitUntilMessage: "Wait until: ",
      remainingMessage: "Remaining",
      ...chatOptions.locale,
    },
  };

  const mounted = useRef(false);
  const [expanded, setExpanded] = useState(options.expanded || false);
  const [finalized, setFinalized] = useState(false);
  const [messages, setMessages] = useState<Message[]>(options.messages || []);
  const [files, setFiles] = useState<File[]>([]);
  const [uploading, setUploading] = useState(false);
  const [isRecording, setIsRecording] = useState<boolean>(false);
  const [uploadedFiles, setUploadedFiles] = useState<FileRes[]>([]);
  const [uploadErrors, setUploadErrors] = useState<FileError[]>([]);
  const [waitingResponse, setWaitingResponse] = useState(false);
  const [isChatDisabled, setIsChatDisabled] = useState(false);
  const [limitExceeded, setLimitExceeded] = useState(false);
  const [limitTimestamp, setLimitTimestamp] = useState(0);
  const [termsAndConditionsAccepted, setTermsAndConditionsAccepted] =
    useState(false);
  const [communicationsAccepted, setCommunicationsAccepted] = useState(false);

  const isUploaded = (file: File): boolean => {
    const wasSuccessfullyUploaded =
      uploadedFiles.find((f) => f.name === file.name) !== undefined;
    const wasUploadedWithErrors =
      uploadErrors.find((fileError) => fileError.file?.name === file.name) !==
      undefined;
    return wasSuccessfullyUploaded || wasUploadedWithErrors;
  };

  const onUploadFile = async (fileList: FileList) => {
    if (!options.onUploadFile) return;

    setUploading(true);

    const errors: FileError[] = [];

    try {
      let fileArray = Array.from(fileList);

      const newFiles = fileArray.filter(
        (file) =>
          !files.find(
            (f) =>
              f.name === file.name &&
              f.size === file.size &&
              f.type === file.type
          )
      );

      setFiles([...files, ...newFiles]);

      for (const newFile of newFiles) {
        const formData = new FormData();
        formData.append("formFile", newFile);

        try {
          const response = await options.onUploadFile(newFile);

          if (response.success) {
            response.data.size = newFile.size;
            setUploadedFiles((prev) => [...prev, response.data]);
          } else {
            errors.push({
              file: newFile,
              error: new Error(getErrorMessage(newFile, response.error)),
            });
          }
        } catch (error) {
          if (error instanceof Error) {
            errors.push({
              file: newFile,
              error: new Error(
                `${options.locale.uploadFileErrorMessage} ${newFile.name}`
              ),
            });
            break;
          }
        }
      }
    } catch (error) {
      if (error instanceof Error) {
        errors.push({
          error: new Error(
            options.locale.uploadFilesErrorMessage
              ? options.locale.uploadFilesErrorMessage
              : "Unexpected error trying to upload files"
          ),
        });
      }
    } finally {
      setUploadErrors((prev) => [...prev, ...errors]);
      setUploading(false);
    }
  };

  const onRemoveFile = (file: File) => {
    const remainingFiles = files.filter(
      (f) =>
        f.name !== file.name || f.size !== file.size || f.type !== file.type
    );

    setFiles(remainingFiles);

    const remainingUploadedFiles = uploadedFiles.filter(
      (f) => f.name !== file.name || f.size !== file.size
    );

    setUploadedFiles(remainingUploadedFiles);
    setUploadErrors((prev) =>
      prev.filter((fileError) => fileError.file?.name !== file.name)
    );
  };

  const clearFiles = () => {
    setFiles([]);
    setUploadedFiles([]);
    setUploadErrors([]);
  };

  const getBotResponse = async (message: Message): Promise<void> => {
    let botResponse: BotResponse;

    try {
      setIsChatDisabled(true);

      const response = await options.onGetBotResponse({
        message: message.value,
        fileIds: message.attachments?.map((file) => file.id),
      });

      botResponse = response;
    } catch (error) {
      const response = error as globalThis.Response;

      const limitExceeded = response.status === 429;

      if (limitExceeded) {
        const retryAfter = parseInt(
          response.headers.get("Retry-After") as string
        );
        setLimitExceeded(true);
        setIsChatDisabled(true);
        setWaitingResponse(false);
        return;
      }

      const body = await response.json();
      botResponse = {
        finalized: false,
        answer:
          body?.message ||
          options.locale.chatErrorMessage ||
          "Unexpected error",
      };
    }

    setMessages((prev) => {
      const additionalMessages = botResponse.additionalMessages
        ? botResponse.additionalMessages.map((am) => {
            return {
              sender: "bot",
              value: am,
              createdAt: new Date(),
              type: "additionalMessage",
            } as Message;
          })
        : [];

      return [
        ...prev,
        {
          sender: "bot",
          options: botResponse.options,
          value: botResponse.answer,
          createdAt: new Date(),
          type: "text",
        },
        ...additionalMessages,
      ];
    });

    if (botResponse.finalized) {
      setFinalized(true);
    }

    // Only enable the chat again if the bot response doesn't have options
    if (!botResponse.options) {
      setIsChatDisabled(false);
    }

    setWaitingResponse(false);
  };

  const onMessage = async (message: Message) => {
    if (uploadedFiles.length > 0) {
      const uploadedFilesWithoutErrors = uploadedFiles.filter(
        (file) =>
          !uploadErrors.find((fileError) => fileError.file?.name === file.name)
      );
      message.attachments = uploadedFilesWithoutErrors;
    }
    setMessages((prev) => [...prev, message]);
    clearFiles();
    setWaitingResponse(true);
  };

  const clearTimer = async () => {
    setLimitExceeded(false);
    setLimitTimestamp(0);
    setIsChatDisabled(false);
  };

  const onSendAudioRecording = async (audio: Blob) => {
    const { onUploadAudioRecording } = options;

    if (!onUploadAudioRecording) return;

    try {
      const transcript = await onUploadAudioRecording(audio);

      if (!transcript) return;

      setMessages([
        ...messages,
        {
          createdAt: new Date(),
          sender: "user",
          type: "text",
          value: transcript,
        },
      ]);
      setWaitingResponse(true);
    } catch (error) {
      if (error instanceof Error) {
        alert(error.message);
      }
    }
  };

  useEffect(() => {
    if (mounted.current) return;
    mounted.current = true;
    if (options.readOnly) {
      setIsChatDisabled(true);
    }
  }, []);

  useEffect(() => {
    if (!options.messages || messages.length > 0) return;
    setMessages(options.messages);
  }, [options.messages]);

  useEffect(() => {
    if (messages.length === 0) return;

    const lastMessage = messages[messages.length - 1];

    if (lastMessage.sender === "bot") return;

    getBotResponse(lastMessage);
  }, [messages]);

  const toggleExpanded = () => {
    setExpanded(!expanded);
  };

  return (
    <ChatContext.Provider
      value={{
        isLimitExceeded: limitExceeded,
        clearTimer,
        limitTimestamp,
        expanded,
        finalized,
        messages: messages,
        onMessage,
        toggleExpanded,
        setMessages,
        setExpanded,
        setFinalized,
        files,
        onUploadFile,
        updateTermsAndConditions: (value: boolean) =>
          setTermsAndConditionsAccepted(value),
        areTermsAndConditionsAccepted: termsAndConditionsAccepted,
        updateCommunications: (value: boolean) =>
          setCommunicationsAccepted(value),
        areCommunicationsAccepted: communicationsAccepted,
        onRemoveFile,
        uploading,
        isUploaded,
        waitingResponse,
        uploadErrors,
        options,
        isChatDisabled,
        readOnly: options.readOnly || false,
        mode: options.mode || "compact",
        onSendAudioRecording: onSendAudioRecording,
        isRecording,
        setIsRecording,
      }}
    >
      {children}
    </ChatContext.Provider>
  );
};

const getErrorMessage = (
  file: File,
  error: UnauthorizedError | ValidationError
) => {
  switch (error.statusCode) {
    case 401: {
      const body = error as UnauthorizedError;
      return `${file.name}: ${body.message}`;
    }
    case 400: {
      const body = error as ValidationError;
      return `${file.name}: ${body.message}`;
    }
    default: {
      return `${file.name}: Unexpected error`;
    }
  }
};


### components/chat/types.ts ###
export type FileRes = {
  id: string;
  extension: string;
  name: string;
  size: number;
};

export type Message = (
  | {
      sender: "user";
    }
  | {
      sender: "bot";
      options?: string[];
    }
) & {
  createdAt: Date;
  type: "text" | "image" | "additionalMessage";
  value: string;
  attachments?: FileRes[];
};

export type FileError = {
  file?: File;
  error: Error;
};

export type UserMessage = {
  message: string;
  fileIds?: string[];
};

export type ChatLocalizations = {
  title?: string;
  subtitle?: string;
  uploadFileErrorMessage?: string;
  uploadFilesErrorMessage?: string;
  chatErrorMessage?: string;
  headerTitle?: string;
  finalizedMessage?: string;
  chooseAnOptionMessage?: string;
  limitExceededMessage?: string;
  waitUntilMessage?: string;
  remainingMessage?: string;
  termsAndConditionsMessage?: string;
  acceptCommunicationsMessage?: string;
  chatInputPlaceholder?: string;
  microphonePermissionDeniedMessage?: string;
  recorderPausedLabel?: string;
  recordingLabel?: string;
  uploadingAudioLabel?: string;
};

export type FileUploadResult =
  | {
      success: true;
      data: FileRes;
    }
  | {
      success: false;
      error: any;
    };

export type ChatOptions = {
  expanded?: boolean;
  mode?: "fullscreen" | "compact";
  readOnly?: boolean;
  messages?: Message[];
  maxHeight?: number;
  backendBaseURL?: string;
  scrollToBottom?: boolean;
  allowUpload?: boolean;
  locale: ChatLocalizations;
  showTermsAndConditions?: boolean;
  showAcceptCommunications?: boolean;
  headerBgColor?: string;
  onUploadFile?: (file: File) => Promise<FileUploadResult>;
  onGetBotResponse: (message: UserMessage) => Promise<BotResponse>;
  onUploadAudioRecording?: (audio: Blob) => Promise<string | undefined>;
  includeHeader?: boolean;
};

export type UnauthorizedError = {
  message: string;
  statusCode: number;
};

export type ValidationError = {
  message: string;
  statusCode: number;
};

export type ResponseError = {
  message: string;
  statusCode: number;
};

export type BotResponse = {
  finalized: boolean;
  additionalMessages?: string[];
  answer: string;
  options?: string[];
};


### components/chat/useChat.tsx ###
import { useContext, useEffect } from "react";
import { Message } from "./types";
import ChatContext from "./context/ChatContext";

const useChat = (props?: { messages?: Message[] }) => {
  const {
    expanded,
    finalized,
    messages,
    onMessage,
    toggleExpanded,
    setMessages,
    setExpanded,
    setFinalized,
    files,
    onUploadFile,
    onRemoveFile,
    uploading,
    isUploaded,
    waitingResponse,
    uploadErrors,
    options,
    isChatDisabled,
    isLimitExceeded,
    limitTimestamp,
    clearTimer,
    updateTermsAndConditions,
    areTermsAndConditionsAccepted,
    updateCommunications,
    areCommunicationsAccepted,
    readOnly,
    mode,
    onSendAudioRecording,
    isRecording,
    setIsRecording,
  } = useContext(ChatContext);

  useEffect(() => {
    if (props?.messages !== undefined) {
      setMessages(props.messages);
    }
  }, []);

  return {
    expanded,
    finalized,
    messages,
    onMessage,
    toggleExpanded,
    setMessages,
    setExpanded,
    setFinalized,
    files,
    onUploadFile,
    onRemoveFile,
    uploading,
    isUploaded,
    waitingResponse,
    uploadErrors,
    options,
    isChatDisabled,
    isLimitExceeded,
    limitTimestamp,
    clearTimer,
    updateTermsAndConditions,
    areTermsAndConditionsAccepted,
    updateCommunications,
    areCommunicationsAccepted,
    readOnly,
    mode,
    onSendAudioRecording,
    isRecording,
    setIsRecording,
  };
};

export default useChat;


### components/slider/Slider.tsx ###
import ReactSlider, { ReactSliderProps } from "react-slider";

type SliderProps = ReactSliderProps;

const Slider: React.FC<SliderProps> = (props) => {
  const getTrackStyles = (key?: string) => {
    if (key && key.endsWith("0"))
      return "tw-bg-primary-500 tw-rounded-l-lg tw-h-2";
    return "tw-bg-gray-300 tw-rounded-r-lg tw-h-2";
  };

  return (
    <ReactSlider
      className="tw-w-full tw-flex tw-flex-row tw-relative tw-justify-center tw-items-center"
      renderTrack={(props) => (
        <div {...props} className={getTrackStyles(props.key as string)} />
      )}
      renderThumb={(props, state) => {
        return (
          <div
            {...props}
            className="tw-absolute focus-visible:tw-outline-none hover:tw-cursor-pointer"
          >
            <Thumb value={state.valueNow} />
          </div>
        );
      }}
      max={10}
      {...props}
    />
  );
};

type ThumbProps = {
  value: number;
};

const Thumb: React.FC<ThumbProps> = ({ value }) => {
  return (
    <div className="tw-w-6 tw-h-6 tw-bg-primary-500 tw-rounded-full tw-flex tw-flex-col tw-justify-center tw-content-center">
      <p className="tw-min-w-full tw-flex tw-flex-col tw-flex-wrap tw-justify-center tw-content-center tw-h-full tw-text-xs tw-text-white">
        {value}
      </p>
    </div>
  );
};

export default Slider;


### components/track/Checking.tsx ###
import { useEffect, useState } from "react";
import { ButtonType, CustomButton } from "./CustomButton";
import { Button, FormLabel, Select, TextArea } from "@fusion/ui";
import { Modal } from "../Modal";
import { GetGeolocaltion } from "../../helpers/Geolocation";
import { useToast } from "@fusion/ui";
import 'react-toastify/dist/ReactToastify.css';
import { useTranslation } from "react-i18next";
import { useUserStore } from "../../stores/UserStore";
import UserEntryService, { StatusRes } from "../../services/UserEntryService";

const INTERVAL_REFRESH_SECONDS = 60;

type TrackReq = {
    action?: ButtonType,
    typeValue: string,
    motiveMessage: string,
    lat: number,
    lng: number
};

export default function Checking() {

    const { entryTypes } = useUserStore();
    const toast = useToast();
    const { t } = useTranslation("Track");

    const [entryStatus, setEntryStatus] = useState({
        startDisabled: false,
        pauseDisabled: false,
        exitDisabled: false,
        isInProgress: false,
        isPaused : false,
        entryTypeId: "",
        remainingSeconds: 0,
        totalSeconds: 0
    });
    const [showModal, setShowModal] = useState(false);
    const [geoLoading, setGeoLoading] = useState(false)
    const [fetchLoading, setFetchLoading] = useState(false)

    const defaultReqTrack: TrackReq = {
        action: undefined,
        typeValue: entryTypes ?
            entryTypes.filter(e => e.isDefault)[0].id.toString() : "",
        motiveMessage: "",
        lat: 0,
        lng: 0
    };
    const [reqTrack, setReqTrack] = useState(defaultReqTrack)

    const totalTime = {
        hours: entryStatus.totalSeconds > 0 ? Math.floor(entryStatus.totalSeconds / 3600).toString() : '00',
        minutes: entryStatus.totalSeconds > 0 ? Math.floor((entryStatus.totalSeconds % 3600) / 60).toString().padStart(2, '0') : '00'
    }

    const remainingTime = {
        hours: entryStatus.remainingSeconds > 0 ? Math.floor(entryStatus.remainingSeconds / 3600).toString() : '00',
        minutes: entryStatus.remainingSeconds > 0 ? Math.floor((entryStatus.remainingSeconds % 3600) / 60).toString().padStart(2, '0') : '00',
        seconds: entryStatus.remainingSeconds > 0 ? (entryStatus.remainingSeconds % 60).toString().padStart(2, '0') : '00'
    }

    const onButtonTrackClick = async (type: ButtonType) => {

        setReqTrack({ ...defaultReqTrack, action: type })
        if (type=== ButtonType.Exit  ){
            setEntryStatus(prev => { return { ...prev, isInProgress: false, isPaused: false } })
        }
        if (type === ButtonType.Pause || (entryStatus.isInProgress && type === ButtonType.Start)) {
            return await fetchTrack(type)
        }

        setShowModal(true)
        loadStatus()
    }

    const fetchTrack = async (type?: ButtonType) => {

        let selectedType = entryStatus.isInProgress
            ? entryTypes?.find(e => e.id === entryStatus.entryTypeId)
            : entryTypes?.find(e => e.id === reqTrack.typeValue);

        if (!selectedType) {
            showToast(t("ErrorTracking"), "error");
            return;
        }

        let request = reqTrack;

        if (selectedType.requestGeoLocation) {
            setGeoLoading(true);

            try {
                const geo = await GetGeolocaltion();
                request = { ...request, ...geo };
                setReqTrack(request);
            } catch (error) {
                showToast(t("GeoPermission"), "error");
                throw error;
            } finally {
                setGeoLoading(false);
            }
        }

        try {
            setFetchLoading(true);

            const status = await UserEntryService.saveEntry({
                isStart: type === ButtonType.Start,
                isPaused: type === ButtonType.Pause,
                motiveMessage: request.motiveMessage,
                entryTypeId: selectedType.id,
                lat: request.lat,
                lng: request.lng,
            });

            await loadStatus(status);
            showToast(t("CheckingSuccess"));
        } catch (error) {
            showToast(t("ErrorTracking"), "error");
        } finally {
            setFetchLoading(false);
            setShowModal(false);
        }
    };

    const showToast = (message: string, type: "success" | "error" = "success", closeTime = 2000) => {

        toast(message, {
            position: "bottom-center",
            autoClose: closeTime,
            hideProgressBar: true,
            closeOnClick: true,
            pauseOnHover: false,
            draggable: false,
            progress: undefined,
            theme: "colored",
            type: type,
        });
    }

    const loadStatus = async (statusProp: StatusRes | null = null) => {

        let status = statusProp || await UserEntryService.getStatus();

        setEntryStatus({
            startDisabled: !status.startEnabled,
            pauseDisabled: status.startEnabled,
            exitDisabled: status.startEnabled,
            isInProgress: status.isInProgress,
            isPaused: status.isPaused,
            entryTypeId: status.entryTypeId,
            remainingSeconds: status.remainingMinutes ? status.remainingMinutes * 60 : 0,
            totalSeconds: status.totalMinutes ? status.totalMinutes * 60 : 0
        })
    }

    //refresh status from api each INTERVAL_REFRESH_SECONDS * 1000
    useEffect(() => {

        loadStatus()

        const timerId = setInterval(loadStatus, INTERVAL_REFRESH_SECONDS * 1000)

        //clean interval
        return () => clearInterval(timerId);
    }, []);

    // refresh timer each 1 second
    useEffect(() => {
        if (entryStatus.remainingSeconds > 0 &&
            entryStatus.pauseDisabled == false &&
            entryStatus.startDisabled
        ) {
            const timerId = setInterval(() => {
                setEntryStatus(prev => { return { ...prev, remainingSeconds: prev.remainingSeconds - 1 } })
            }, 1000);

            // clean interval
            return () => clearInterval(timerId);
        }
    }, [entryStatus.remainingSeconds, entryStatus.pauseDisabled, entryStatus.startDisabled]);

    return (
        <div className="tw-flex tw-flex-col tw-items-center tw-pt-5 ">
            <div className={`tw-flex tw-flex-col tw-justify-between tw-w-full tw-max-w-md tw-bg-primary-100 tw-p-5 tw-rounded-md tw-bg-gray-100 tw-min-h-[300px]`}>
                <div className="tw-flex tw-justify-center tw-flex-wrap tw-gap-4 tw-py-4">
                    {entryStatus.isInProgress &&
                        <CustomButton
                            disabled={entryStatus.pauseDisabled}
                            type={ButtonType.Pause}
                            loading={(geoLoading || fetchLoading) && reqTrack.action == ButtonType.Pause}
                            text={"Pausa"}
                            onClick={async () => await onButtonTrackClick(ButtonType.Pause)}
                        />}
                    <CustomButton
                        disabled={entryStatus.startDisabled}
                        type={ButtonType.Start}
                        loading={geoLoading && reqTrack.action == ButtonType.Start}
                        text={"Iniciar"}
                        onClick={async () => await onButtonTrackClick(ButtonType.Start)}
                    />
                    {entryStatus.isInProgress &&
                        <CustomButton
                            disabled={entryStatus.exitDisabled}
                            type={ButtonType.Exit}
                            loading={geoLoading && reqTrack.action == ButtonType.Exit}
                            text={"Finalizar"}
                            onClick={async () => await onButtonTrackClick(ButtonType.Exit)}
                        />
                    }
                </div>
                <div className="tw-flex tw-justify-between tw-gap-4 tw-px-10">
                    <span className="tw-text-xl">
                        {`${totalTime.hours}h ${totalTime.minutes}min`}
                    </span>
                    <span className="tw-text-xl">
                        {`${remainingTime.hours}:${remainingTime.minutes}`}
                    </span>
                </div>
            </div>
            <Modal
                FooterComponent={
                    <div className="tw-flex tw-justify-end tw-gap-2 tw-py-2 tw-px-6 tw-bg-gray-50">
                        <Button
                            variant="secondary"
                            onClick={() => { setShowModal(false) }}
                        >
                            {"Cancelar"}
                        </Button>
                        <Button
                            variant="primary"
                            className="disabled:tw-bg-gray-200"
                            onClick={async () => { await fetchTrack(reqTrack.action) }}
                            loading={fetchLoading || geoLoading}
                            disabled={reqTrack.typeValue == "" && reqTrack.action == ButtonType.Start}
                        >
                            {"Confirmar"}
                        </Button>
                    </div>
                }
                isOpen={showModal}
                onClose={() => { setShowModal(false) }}
                title={"Fichada"}
                size="sm"
            >
                <div className="tw-flex tw-flex-col tw-items-center tw-pt-5 tw-gap-5">
                    {reqTrack.action == ButtonType.Start && <Select
                        multiple={false}
                        LabelComponent={<FormLabel required>{"Tipo"}</FormLabel>}
                        name="typeValue"
                        displayExpr={"name"}
                        valueExpr={"id"}
                        items={entryTypes}
                        defaultValue={reqTrack.typeValue}
                        value={reqTrack.typeValue}
                        onSelectionChanged={e => setReqTrack((prev) => { return { ...prev, typeValue: e.selectedItem.id } })}
                    />}
                    {(reqTrack.action == ButtonType.Exit || reqTrack.action == ButtonType.Start) && <TextArea
                        className="tw-min-w-fit"
                        name="motiveMessage"
                        rows={5}
                        LabelComponent={<FormLabel>{t("MotiveMessage")}</FormLabel>}
                        value={reqTrack.motiveMessage}
                        onChange={e => setReqTrack((prev) => { return { ...prev, motiveMessage: e.target.value } })
                        }
                    />
                    }
                </div>
            </Modal>
        </div>
    );
}

### components/track/CustomButton.tsx ###
import { ArrowRightOnRectangleIcon, ArrowLeftOnRectangleIcon, PauseIcon } from "@heroicons/react/20/solid"

export enum ButtonType {
    Start = 'start',
    Exit = 'exit',
    Pause = 'pause'
}

type CustomButtonProps = {
    text?: string,
    disabled: boolean,
    loading?: boolean,
    type: ButtonType,
    onClick: () => void
}

const getIcon = (type: ButtonType) => {

    const className = "tw-h-5 tw-w-5 tw-text-white"

    switch (type) {
        case 'start':
            return <ArrowRightOnRectangleIcon className={className} />
        case 'exit':
            return <ArrowLeftOnRectangleIcon className={className} />
        case 'pause':
            return <PauseIcon className={className} />
        default:
            return <></>
    }
}

const getColorButtonClass = (type: ButtonType) => {

    switch (type) {
        case 'start':
            return 'tw-bg-primary-500 hover:tw-bg-primary-600 active:tw-bg-primary-700'
        case 'exit':
            return 'tw-bg-red-600 hover:tw-bg-red-700 active:tw-bg-red-800'
        case 'pause':
            return 'tw-bg-yellow-500 hover:tw-bg-yellow-600 active:tw-bg-yellow-700'
        default:
            return ''
    }

}

export const CustomButton = ({ text, disabled, loading, type, onClick }: CustomButtonProps) => {

    const icon = getIcon(type)
    const colorButton = getColorButtonClass(type);

    return (
        <>
            <button
                className={`${colorButton} tw-flex tw-w-28 tw-flex-col tw-items-center tw-direc tw-px-8 tw-py-3 tw-font-bold tw-text-white tw-rounded-lg tw-shadow-md disabled:tw-bg-gray-300`}
                disabled={disabled || loading}
                onClick={onClick}
            >
                <span>{text}</span>
                {
                    !loading ?
                        icon
                        :
                        <div className="tw-pl-2">
                            <svg
                                aria-hidden="true"
                                className={"tw-w-4 tw-h-4 tw-mr-2 tw-text-gray-200 tw-animate-spin dark:tw-text-gray-600"}
                                viewBox="0 0 100 100"
                                fill="none"
                                xmlns="http://www.w3.org/2000/svg"
                            >
                                <path
                                    d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z"
                                    fill="currentColor"
                                />
                                <path
                                    d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z"
                                    fill="currentFill"
                                />
                            </svg>
                        </div>
                }

            </button>
        </>
    )
}


### components/track/Totem.tsx ###
import {Button, FormLabel, Select, TextArea, useToast} from "@fusion/ui";
import { BackspaceIcon } from "@heroicons/react/20/solid";
import { useEffect, useState } from "react";
import { useTranslation } from "react-i18next";
import { ButtonType, CustomButton } from "./CustomButton";
import UserEntryService, {StatusRes} from "../../services/UserEntryService";
import {Modal} from "../Modal";
import {useUserStore} from "../../stores/UserStore";
import {GetGeolocaltion} from "../../helpers/Geolocation";

type TotemProps = {
    isLogout?: boolean;
    onChangeCode?: (newCode: string) => void
};
type TrackReq = {
    action?: ButtonType,
    typeValue: string,
    motiveMessage: string,
    lat: number,
    lng: number
};
type User = {
    name : string,
    lastName : string
}
export default function Totem({ onChangeCode, isLogout = false }: TotemProps) {

    const [code, setCode] = useState('');
    const [name, setName] = useState('');
    const [startLoading, setStartLoading] = useState(false);
    const [exitLoading, setExitLoading] = useState(false);

    const { entryTypes } = useUserStore();
    const [showModal, setShowModal] = useState(false);
    const defaultReqTrack: TrackReq = {
        action: undefined,
        typeValue: entryTypes ?
            entryTypes.filter(e => e.isDefault)[0].id.toString() : "",
        motiveMessage: "",
        lat: 0,
        lng: 0
    };
    const [reqTrack, setReqTrack] = useState(defaultReqTrack)
    const [geoLoading, setGeoLoading] = useState(false)
    const [fetchLoading, setFetchLoading] = useState(false)
    const [entryStatus, setEntryStatus] = useState({
        startDisabled: false,
        pauseDisabled: false,
        exitDisabled: false,
        isInProgress: false,
        isPaused : false,
        entryTypeId: "",
        remainingSeconds: 0,
        totalSeconds: 0
    });
    const fetchTrack = async (type?: ButtonType) => {

        let selectedType = entryStatus.isInProgress
            ? entryTypes?.find(e => e.id === entryStatus.entryTypeId)
            : entryTypes?.find(e => e.id === reqTrack.typeValue);

        if (!selectedType) {
            showToast(t("ErrorTracking"), "error");
            return;
        }

        let request = reqTrack;

        if (selectedType.requestGeoLocation) {
            setGeoLoading(true);

            try {
                const geo = await GetGeolocaltion();
                request = { ...request, ...geo };
                setReqTrack(request);
            } catch (error) {
                showToast(t("GeoPermission"), "error");
                throw error;
            } finally {
                setGeoLoading(false);
            }
        }

        try {
            setFetchLoading(true);

            const status = await UserEntryService.saveEntry({
                isStart: type === ButtonType.Start,
                isPaused: type === ButtonType.Pause,
                motiveMessage: request.motiveMessage,
                entryTypeId: selectedType.id,
                lat: request.lat,
                lng: request.lng,
                entryKey: code
            });

            await loadStatus(status);
            showToast(true);
        } catch (error: any) {
            error.json().then((p:any)=>{
                const message = p.message.toString();
                setCode('');
                showToast(false, message);
            });

        } finally {
            setCode('');
            setFetchLoading(false);
            setShowModal(false);
        }
    };
    const loadStatus = async (statusProp: StatusRes | null = null) => {

        let status = statusProp || await UserEntryService.getStatus();

        setEntryStatus({
            startDisabled: !status.startEnabled,
            pauseDisabled: status.startEnabled,
            exitDisabled: status.startEnabled,
            isInProgress: status.isInProgress,
            isPaused: status.isPaused,
            entryTypeId: status.entryTypeId,
            remainingSeconds: status.remainingMinutes ? status.remainingMinutes * 60 : 0,
            totalSeconds: status.totalMinutes ? status.totalMinutes * 60 : 0
        })
    }

    const toast = useToast();
    const { t } = useTranslation("Track");

    const handleButtonClick = (digit: string) => {
        if (code.length < 15) {
            let newCode = code + digit;
            setCode(newCode)
        }
    };

    const showToast = (success: boolean, type: "success" | "error" = "success", message? : string) => {

        if (success) {
            const toastMessage = t("CheckingSuccess");
            toast(toastMessage, {
                position: "bottom-center",
                autoClose: 4000,
                hideProgressBar: true,
                closeOnClick: true,
                pauseOnHover: false,
                draggable: false,
                progress: undefined,
                theme: "colored",
                type: "success"
            });

        } else {

            const toastMessage = type ?? t("CheckingFailed");
            toast(toastMessage, {
                position: "bottom-center",
                autoClose: 4000,
                hideProgressBar: true,
                closeOnClick: true,
                pauseOnHover: false,
                draggable: false,
                progress: undefined,
                theme: "colored",
                type: "error"
            });
        }
    }

    const onButtonTrackClick = async (type: ButtonType) => {

        try {
            const user : any = await UserEntryService.getTotemEntry({ entryKey: code, isStart: true });

            // Safely parse user data
            const parsedUser: User = {
                name: user?.name ?? '', // Using optional chaining for safety
                lastName: user?.lastName ?? ''
            };

            setName(`${parsedUser.name} ${parsedUser.lastName}`);
            setReqTrack({ ...defaultReqTrack, action: type });

            // Handle different button types
            if (type === ButtonType.Exit) {
                setEntryStatus(prev => ({ ...prev, isInProgress: false, isPaused: false }));
            }

            if (type === ButtonType.Pause || (entryStatus.isInProgress && type === ButtonType.Start)) {
                await fetchTrack(type); // Await fetchTrack to ensure execution before returning
                return;
            }

            // Show modal for other cases
            setShowModal(true);
        } catch (error : any) {
            try {
                const errorData = await error.json();
                const message = errorData?.message?.toString() ?? 'An error occurred';
                setCode('');
                showToast(false, message);
            } catch (jsonError) {
                console.error('Failed to parse error response', jsonError);
                showToast(false,"error", 'An unexpected error occurred');
            }
        }

    }

    useEffect(() => {
        if (onChangeCode) {
            onChangeCode(code)
        }
    }, [code, onChangeCode])

    return (
        <>
            <div className="tw-flex tw-flex-col tw-items-center tw-pt-5">
                <div className={`tw-w-full tw-max-w-sm tw-bg-primary-100 tw-p-5 tw-rounded-md ${isLogout ? 'tw-bg-red-100' : 'tw-bg-gray-100'}`}>
                    <input
                        type="password"
                        className="tw-w-full tw-px-4 tw-py-1 tw-mb-4 tw-text-2xl tw-text-center tw-border tw-border-gray-300 tw-rounded-md tw-shadow-sm focus:tw-outline-none focus:tw-ring-0"
                        placeholder="****"
                        value={code}
                        readOnly
                    />

                    <div className="tw-grid tw-grid-cols-3 tw-gap-4">
                        {[1, 2, 3, 4, 5, 6, 7, 8, 9].map((digit) => (
                            <button
                                key={digit}
                                className="tw-px-8 tw-py-3 tw-text-2xl tw-font-bold tw-text-white tw-bg-primary-500 tw-rounded-lg tw-shadow-lg hover:tw-bg-primary-600 active:tw-bg-primary-700"
                                onClick={() => handleButtonClick(digit.toString())}
                            >
                                {digit}
                            </button>
                        ))}
                    </div>
                    <div className="tw-py-5 tw-grid tw-grid-cols-2 tw-gap-4">
                        <button
                            className="tw-px-8 tw-py-3 tw-text-2xl tw-font-bold tw-text-white tw-bg-primary-500 tw-rounded-lg tw-shadow-lg hover:tw-bg-primary-600 active:tw-bg-primary-700 focus:tw-outline-none focus:tw-ring-4 focus:tw-ring-primary-300"
                            onClick={() => handleButtonClick('0')}
                        >
                            0
                        </button>
                        <button
                            className="tw-flex tw-justify-evenly tw-px-8 tw-py-3 tw-font-bold tw-text-white tw-bg-red-600 tw-rounded-lg tw-shadow-lg hover:tw-bg-red-700 active:tw-bg-red-800 disabled:tw-bg-gray-300"
                            onClick={() => setCode('')}
                            disabled={code == ""}
                        >
                            <BackspaceIcon
                                className="tw-h-10 tw-w-10 tw-text-white"
                            />
                        </button>
                    </div>

                </div>
            </div>
            {!isLogout && <div className="tw-flex tw-justify-center tw-gap-4 tw-py-4">
                <CustomButton
                    disabled={code.length < 4 || exitLoading}
                    type={ButtonType.Start}
                    loading={startLoading}
                    text={t("Start")}
                    //onClick={() => { handleRegister(true) }}
                    onClick={async () => await onButtonTrackClick(ButtonType.Start)}
                />
                <CustomButton
                    disabled={code.length < 4 || startLoading}
                    type={ButtonType.Exit}
                    loading={exitLoading}
                    text={t("Exit")}
                    //onClick={() => { handleRegister(false) }}
                    onClick={async () => await onButtonTrackClick(ButtonType.Exit)}
                />
            </div>}
            <Modal
                FooterComponent={
                    <div className="tw-flex tw-justify-end tw-gap-2 tw-py-2 tw-px-6 tw-bg-gray-50">
                        <Button
                            variant="secondary"
                            onClick={() => { setShowModal(false) }}
                        >
                            {"Cancelar"}
                        </Button>
                        <Button
                            variant="primary"
                            className="disabled:tw-bg-gray-200"
                            onClick={async () => { await fetchTrack(reqTrack.action) }}
                            loading={fetchLoading || geoLoading}
                            disabled={reqTrack.typeValue == "" && reqTrack.action == ButtonType.Start}
                        >
                            {"Confirmar"}
                        </Button>
                    </div>
                }
                isOpen={showModal}
                onClose={() => { setShowModal(false) }}
                title={"Fichada"}
                size="sm"
            >
                <div className="tw-flex tw-flex-col tw-items-center tw-pt-5 tw-gap-5">
                    {reqTrack.action == ButtonType.Start && <Select
                        multiple={false}
                        LabelComponent={<FormLabel required>{name}</FormLabel>}
                        name="typeValue"
                        displayExpr={"name"}
                        valueExpr={"id"}
                        items={entryTypes}
                        defaultValue={reqTrack.typeValue}
                        value={reqTrack.typeValue}
                        onSelectionChanged={e => setReqTrack((prev) => { return { ...prev, typeValue: e.selectedItem.id } })}
                    />}
                    <div className="tw-items-start">
                        <FormLabel>{t("Name")} : {name}</FormLabel>
                    </div>
                    {(reqTrack.action == ButtonType.Exit || reqTrack.action == ButtonType.Start) && <TextArea
                        className="tw-min-w-fit"
                        name="motiveMessage"
                        rows={5}
                        LabelComponent={<FormLabel>{t("MotiveMessage")}</FormLabel>}
                        value={reqTrack.motiveMessage}
                        onChange={e => setReqTrack((prev) => { return { ...prev, motiveMessage: e.target.value } })
                        }
                    />
                    }
                </div>
            </Modal>
        </>

    );
};

### constants/CalendarDayTypes.tsx ###
const calendarDayTypes = [
  {
    id: "7c3c5a61-f312-41c5-8c5f-8ecd323fb301",
    name: "Local",
    companyId: null,
    // color: "#ff9d92",
    color: "tw-bg-red-500",
  },
  {
    id: "7c3c5a61-f312-41c5-8c5f-8ecd323fb302",
    name: "Regional",
    companyId: null,
    // color: "#939af3",
    color: "tw-bg-blue-500",
  },
  {
    id: "7c3c5a61-f312-41c5-8c5f-8ecd323fb303",
    name: "Nacional",
    companyId: null,
    // color: "#c82829",
    color: "tw-bg-green-500",
  },
];

export { calendarDayTypes };


### context/NotificationsComponentContext.tsx ###
import React, { createContext, PropsWithChildren, useState } from "react";
import { useTranslation } from "react-i18next";
import { Modal, Button, Alert } from "@fusion/ui";
import { ExclamationCircleIcon } from "@heroicons/react/24/outline";

type NotificationProps = {
  component: "modal" | "toast";
  errors: string[];
  onClose?: () => void;
  locale?: {
    title?: string;
    confirmButton?: string;
  };
};

type NotificationContextProps = {
  show: (options: NotificationProps) => void;
  hide: () => void;
};

const NotificationContext = createContext<NotificationContextProps>({
  show: () => {},
  hide: () => {},
});

const NotificationsComponentContext: React.FC<PropsWithChildren> = (props) => {
  const { t } = useTranslation("NotificationComponent");
  const [showModal, setShowModal] = useState(false);
  const [errors, setErrors] = useState<NotificationProps>();

  const onClose = () => {
    errors?.onClose && errors.onClose();
    setShowModal(false);
  };

  return (
    <NotificationContext.Provider
      value={{
        show: (options: NotificationProps) => {
          setShowModal(true);
          setErrors(options);
        },
        hide: () => {
          setShowModal(false);
          setErrors(undefined);
        },
      }}
    >
      <Modal
        FooterComponent={
          <div className="tw-bg-gray-50 tw-px-4 tw-py-3 sm:tw-flex sm:tw-flex-row-reverse sm:tw-px-4">
            <Button
              className="tw-bg-red-600 hover:tw-bg-red-700 focus:tw-ring-transparent"
              onClick={onClose}
            >
              {errors?.locale?.confirmButton
                ? errors.locale.confirmButton
                : t("Confirm")}
            </Button>
          </div>
        }
        IconComponent={
          <ExclamationCircleIcon
            className="tw-h-6 tw-w-6 tw-text-red-600"
            aria-hidden="true"
          />
        }
        title={errors?.locale?.title ? errors.locale.title : t("Title")}
        isOpen={showModal}
        onClose={onClose}
      >
        {errors?.errors.map((item, index) => (
          <p className="tw-mt-2 tw-font-medium" key={index}>
            {item}
          </p>
        ))}
      </Modal>
      {props.children}
    </NotificationContext.Provider>
  );
};

export { NotificationContext, NotificationsComponentContext };


### declaration.d.ts ###
declare global {
  interface File {
    toObject(): {
      lastModified: number;
      name: string;
      size: number;
      type: string;
    };
  }
}

File.prototype.toObject = function () {
  return Object({
    lastModified: this.lastModified,
    name: String(this.name),
    size: this.size,
    type: String(this.type),
  });
};

declare module "@uppy/locales/lib/es_MX" {
  import { Locale } from "@uppy/core";
  const es_MX: Locale;
  export default es_MX;
}

declare module "@uppy/locales/lib/en_US" {
  import { Locale } from "@uppy/core";
  const en_US: Locale;
  export default en_US;
}


### ecosystem.config.js ###
require("dotenv/config");

module.exports = {
  apps: [
    {
      name: process.env.NAME_APP,
      script: "./server.js",
      env: {
        ...process.env,
      },
    },
  ],
};


### helpers/DateHelper.ts ###
import dayjs from "dayjs";
import isBetween from "dayjs/plugin/isBetween";
import utc from "dayjs/plugin/utc";

dayjs.extend(utc);
dayjs.extend(isBetween);

export class DateHelper {
  static getDateAsString = (date: Date) => {
    return dayjs(date).utcOffset(0).format("YYYY-MM-DD");
  };

  static addDaysToDate = (date: Date, value: number) => {
    return dayjs(date).utcOffset(0).add(value, "days").toDate();
  };

  /**
   * Return a standard string in the provided format
   * @param dateToFormat
   * @param format default: "DD/MM/YYYY"
   */
  static formatDateString = (
    dateToFormat: string | Date,
    format: string = "DD/MM/YYYY"
  ): string => {
    const parsedTime = dayjs(dateToFormat).format(format);
    return parsedTime;
  };

  /**
   * Return a boolean indicating if a date is between
   * two limit dates. Limits are included.
   */
  static isDateBetween(startDate: Date, endDate: Date, value: Date): boolean {
    const start = dayjs(startDate);
    const end = dayjs(endDate);
    const date = dayjs(value);

    return date.isBetween(start, end, null, "[]");
  }

  /**
   * Return an array with every date between two limit dates.
   * Limits are included.
   */
  static getDatesArrayFromRange(startDate: Date, endDate?: Date): Array<Date> {
    const start = dayjs(startDate);
    const end = endDate ? dayjs(endDate) : start.add(1, "month").set("day", 0);

    const differenceInDays = end.diff(start, "day") + 1; // Add 1 to include start date

    return Array.from({ length: differenceInDays }, (_, index) => {
      let date = start;
      date.add(index, "day");
      return date.toDate();
    });
  }

  /**
   * Returns a string with the date time in HH:MM format
   */
  static formatTime(date: Date): string {
    const hours = date.getHours().toString().padStart(2, "0"); // Get hours and pad with 0 if needed
    const minutes = date.getMinutes().toString().padStart(2, "0"); // Get minutes and pad with 0 if needed

    return `${hours}:${minutes}`;
  }

  /**
   * Returns a date with the date time in HH:MM string format entered
   */
  static setDateTime(date: Date, timeString: string): Date {
    const [hours, minutes] = timeString.split(":").map(Number);

    date.setHours(hours);
    date.setMinutes(minutes);
    date.setSeconds(0);
    date.setMilliseconds(0);

    return date;
  }

  static toLocalISOString = (date: Date) => {
    const pad = (num: number) => (num < 10 ? '0' + num : num); // AÃ±ade un cero si es necesario
    return (
      date.getFullYear() +
      '-' +
      pad(date.getMonth() + 1) + // Los meses comienzan desde 0
      '-' +
      pad(date.getDate()) +
      'T' +
      pad(date.getHours()) +
      ':' +
      pad(date.getMinutes()) +
      ':' +
      pad(date.getSeconds())
    );
  };

  // Return only date (without time)
  static toLocalDateString = (date: Date) => {
    return `${date.toLocaleDateString('en-CA')}T00:00:00.000Z`;
  };
  
}


### helpers/Geolocation.ts ###
export type GeoLocationProps = {
    lat: number,
    lng: number
}

export const GetGeolocaltion = (): Promise<GeoLocationProps> => {
    return new Promise((resolve, reject) => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const { latitude, longitude } = position.coords;
                    resolve({ lat: latitude, lng: longitude });
                },
                (error) => {
                    reject(error);
                }
            );
        } else {
            reject(new Error("Unsopported"));
        }
    });
};


### helpers/OptionsHelper.ts ###
type OptionsMap = { [key: string | number]: string }

type Options = Array<{ [key: string]: any }>

export default class OptionsHelper {
  static convertArrayToMap(
    array: Options,
    textExpr: string = "text",
    valueExpr: string = "value",
  ): OptionsMap {
    let map = {}

    for (const item of array) {
      map = {
        ...map,
        [item[valueExpr]]: item[textExpr],
      }
    }

    return map
  }
}


### helpers/TimeHelper.ts ###
import dayjs from "dayjs";
import isBetween from "dayjs/plugin/isBetween";
import utc from "dayjs/plugin/utc";

dayjs.extend(utc);
dayjs.extend(isBetween);

export class TimeHelper {
  /**
   * Receive time in HH:MM format and return a number representing minutes
   * @param time
   */
  static timeStringToMinutes(time: string): number {
    if (!time.includes(":")) {
      return 0;
    }
    const [hours, minutes] = time.split(":").map(Number);
    if (isNaN(hours) || isNaN(minutes)) {
      return 0;
    }
    return hours * 60 + minutes;
  }

  /**
   * Receive minutes and return the time in HH:MM format
   * @param totalMinutes
   */
  static formatMinutes = (totalMinutes: number) => {
    const hours = Math.floor(totalMinutes / 60);
    const minutes = totalMinutes % 60;

    const formattedHours = String(hours).padStart(2, "0");
    const formattedMinutes = String(minutes).padStart(2, "0");

    return `${formattedHours}:${formattedMinutes}`;
  };
}


### hooks/useCookieConsentBanner.tsx ###
import { AccentColor } from "@fusion/theme";
import { CookieConsent } from "@fusion/ui";
import Link from "next/link";
import { useEffect, useState } from "react";
import { useTranslation } from "react-i18next";
import AccountService, { CookieConsentRes } from "../services/AccountService";
import { useUserStore } from "../stores/UserStore";

type CookieConsentOptions = {
  accentColor?: AccentColor;
};

const useCookieConsentBanner = (options?: CookieConsentOptions) => {
  const store = useUserStore();
  const { t } = useTranslation("CookieConsent");
  const [cookieConsent, setCookieConsent] = useState<CookieConsentRes>();
  const [isClientRender, setIsClientRender] = useState(false); //prevent error: Text content does not match server-rendered HTML

  const getCookieConsentInfo = async () => {
    try {
      const response = await AccountService.getCookieConsentInfo();
      setCookieConsent(response);
      if (response.accepted === true) store.setCookieConsentAccepted(true);
    } catch (error) {}
  };

  const onAccept = async () => {
    await AccountService.acceptCookie();
    store.setCookieConsentAccepted(true);
  };

  const onReject = () => {
    //post reject to server
    store.setCookieConsentAccepted(false);
  };

  useEffect(() => {
    setIsClientRender(true);
    if (store.cookieConsentAccepted === undefined) {
      getCookieConsentInfo();
    }
  }, [store.cookieConsentAccepted]);

  const CookieConsentBanner = () =>
    !isClientRender ? null : store.cookieConsentAccepted === false ? (
      <CookieConsent
        accentColor={options?.accentColor}
        onAccept={onAccept}
        onReject={onReject}
        rejectLabel={t("RejectAll")}
        acceptLabel={t("AcceptAll")}
        description={t("BannerDescription")}
        LinkComponent={
          <Link
            href={
              cookieConsent?.cookiePolicyUrl
                ? cookieConsent.cookiePolicyUrl
                : "#"
            }
          >
            <span
              className={`tw-font-semibold tw-text-${
                options?.accentColor ?? "primary"
              }-600`}
            >
              {t("PrivacyPolicyLinkLabel")}
            </span>
          </Link>
        }
      />
    ) : null;

  return CookieConsentBanner;
};

export default useCookieConsentBanner;


### hooks/useLocalizedChat.tsx ###
import { useTranslation } from "react-i18next";
import { ChatLocalizations } from "../components/chat/types";

const useLocalizedChat = () => {
  const { t } = useTranslation("Chat");

  const defaultTranslations: ChatLocalizations = {
    chatErrorMessage: t("ChatErrorMessage"),
    chatInputPlaceholder: t("ChatInputPlaceholder"),
    chooseAnOptionMessage: t("ChooseAnOptionMessage"),
    headerTitle: t("HeaderTitle"),
    limitExceededMessage: t("LimitExceededMessage"),
    remainingMessage: t("RemainingMessage"),
    uploadFileErrorMessage: t("UploadFileErrorMessage"),
    uploadFilesErrorMessage: t("UploadFilesErrorMessage"),
    waitUntilMessage: t("WaitUntilMessage"),
    title: t("Title"),
    subtitle: t("Subtitle"),
    microphonePermissionDeniedMessage: t("MicrophonePermissionDeniedMessage"),
    recorderPausedLabel: t("RecorderPausedLabel"),
    recordingLabel: t("RecordingLabel"),
    uploadingAudioLabel: t("UploadingAudioLabel"),
  };

  return defaultTranslations;
};

export default useLocalizedChat;


### hooks/useLocalizedCountries.tsx ###
import { useTranslation } from "react-i18next";

type CountryPhoneCodeOption = [string, string, string, number?, string[]?];

export type CountriesInfo = { text: string; value: string };

const useLocalizedCountries = () => {
  const { t } = useTranslation("CountriesLocalization");

  const countriesPhoneCodes: CountryPhoneCodeOption[] = [
    [t("Afghanistan"), "af", "93"],
    [t("Albania"), "al", "355"],
    [t("Algeria"), "dz", "213"],
    [t("AmericanSamoa"), "as", "1684"],
    [t("Andorra"), "ad", "376"],
    [t("Angola"), "ao", "244"],
    [t("Anguilla"), "ai", "1264"],
    [t("AntiguaAndBarbuda"), "ag", "1268"],
    [t("Argentina"), "ar", "54"],
    [t("Armenia"), "am", "374"],
    [t("Aruba"), "aw", "297"],
    [t("Australia"), "au", "61", 0],
    [t("Austria"), "at", "43"],
    [t("Azerbaijan"), "az", "994"],
    [t("Bahamas"), "bs", "1242"],
    [t("Bahrain"), "bh", "973"],
    [t("Bangladesh"), "bd", "880"],
    [t("Barbados"), "bb", "1246"],
    [t("Belarus"), "by", "375"],
    [t("Belgium"), "be", "32"],
    [t("Belize"), "bz", "501"],
    [t("Benin"), "bj", "229"],
    [t("Bermuda"), "bm", "1441"],
    [t("Bhutan"), "bt", "975"],
    [t("Bolivia"), "bo", "591"],
    [t("BosniaAndHerzegovina"), "ba", "387"],
    [t("Botswana"), "bw", "267"],
    [t("Brazil"), "br", "55"],
    [t("BritishIndianOceanTerritory"), "io", "246"],
    [t("BritishVirginIslands"), "vg", "1284"],
    [t("Brunei"), "bn", "673"],
    [t("Bulgariat"), "bg", "359"],
    [t("BurkinaFaso"), "bf", "226"],
    [t("Burundi"), "bi", "257"],
    [t("Cambodia"), "kh", "855"],
    [t("Cameroon"), "cm", "237"],
    [
      t("Canada"),
      "ca",
      "1",
      1,
      [
        "204",
        "226",
        "236",
        "249",
        "250",
        "289",
        "306",
        "343",
        "365",
        "367",
        "387",
        "403",
        "416",
        "418",
        "431",
        "437",
        "438",
        "450",
        "506",
        "514",
        "519",
        "548",
        "579",
        "581",
        "587",
        "604",
        "613",
        "639",
        "647",
        "672",
        "705",
        "709",
        "742",
        "778",
        "780",
        "782",
        "807",
        "819",
        "825",
        "867",
        "873",
        "902",
        "905",
      ],
    ],
    [t("CapeVerde"), "cv", "238"],
    [t("CaribbeanNetherlands"), "bq", "599", 1],
    [t("CaymanIslands"), "ky", "1345"],
    [t("CentralAfricanRepublic"), "cf", "236"],
    [t("Chad"), "td", "235"],
    [t("Chile"), "cl", "56"],
    [t("China"), "cn", "86"],
    [t("ChristmasIsland"), "cx", "61", 2],
    [t("CocosIslands"), "cc", "61", 1],
    [t("Colombia"), "co", "57"],
    [t("Comoros"), "km", "269"],
    [t("Congo"), "cd", "243"],
    [t("Congo"), "cg", "242"],
    [t("CookIslands"), "ck", "682"],
    [t("CostaRica"), "cr", "506"],
    [t("CÃ´teIvoire"), "ci", "225"],
    [t("Croatia"), "hr", "385"],
    [t("Cuba"), "cu", "53"],
    [t("CuraÃ§ao"), "cw", "599", 0],
    [t("Cyprus"), "cy", "357"],
    [t("CzechRepublic"), "cz", "420"],
    [t("Denmark"), "dk", "45"],
    [t("Djibouti"), "dj", "253"],
    [t("Dominica"), "dm", "1767"],
    [t("DominicanRepublic"), "do", "1", 2, ["809", "829", "849"]],
    [t("Ecuador"), "ec", "593"],
    [t("Egypt"), "eg", "20"],
    [t("ElSalvador"), "sv", "503"],
    [t("EquatorialGuinea"), "gq", "240"],
    [t("Eritrea"), "er", "291"],
    [t("Estonia"), "ee", "372"],
    [t("Ethiopia"), "et", "251"],
    [t("FalklandIslands"), "fk", "500"],
    [t("FaroeIslands"), "fo", "298"],
    [t("Fiji"), "fj", "679"],
    [t("Finland"), "fi", "358", 0],
    [t("France"), "fr", "33"],
    [t("FrenchGuiana"), "gf", "594"],
    [t("FrenchPolynesia"), "pf", "689"],
    [t("Gabon"), "ga", "241"],
    [t("Gambia"), "gm", "220"],
    [t("Georgia"), "ge", "995"],
    [t("Germany"), "de", "49"],
    [t("Ghana"), "gh", "233"],
    [t("Gibraltar"), "gi", "350"],
    [t("Greece"), "gr", "30"],
    [t("Greenland"), "gl", "299"],
    [t("Grenada"), "gd", "1473"],
    [t("Guadeloupe"), "gp", "590", 0],
    [t("Guam"), "gu", "1671"],
    [t("Guatemala"), "gt", "502"],
    [t("Guernsey"), "gg", "44", 1],
    [t("Guinea"), "gn", "224"],
    [t("Guinea-Bissau"), "gw", "245"],
    [t("Guyana"), "gy", "592"],
    [t("Haiti"), "ht", "509"],
    [t("Honduras"), "hn", "504"],
    [t("HongKong"), "hk", "852"],
    [t("Hungary"), "hu", "36"],
    [t("Iceland"), "is", "354"],
    [t("India"), "in", "91"],
    [t("Indonesia"), "id", "62"],
    [t("Iran"), "ir", "98"],
    [t("Iraq"), "iq", "964"],
    [t("Ireland"), "ie", "353"],
    [t("IsleofMan"), "im", "44", 2],
    [t("Israel"), "il", "972"],
    [t("Italy"), "it", "39", 0],
    [t("Jamaica"), "jm", "1876"],
    [t("Japan"), "jp", "81"],
    [t("Jersey"), "je", "44", 3],
    [t("Jordan"), "jo", "962"],
    [t("Kazakhstan"), "kz", "7", 1],
    [t("Kenya"), "ke", "254"],
    [t("Kiribati"), "ki", "686"],
    [t("Kosovo"), "xk", "383"],
    [t("Kuwait"), "kw", "965"],
    [t("Kyrgyzstan"), "kg", "996"],
    [t("Laos"), "la", "856"],
    [t("Latvia"), "lv", "371"],
    [t("Lebanon"), "lb", "961"],
    [t("Lesotho"), "ls", "266"],
    [t("Liberia"), "lr", "231"],
    [t("Libya"), "ly", "218"],
    [t("Liechtenstein"), "li", "423"],
    [t("Lithuania"), "lt", "370"],
    [t("Luxembourg"), "lu", "352"],
    [t("Macau"), "mo", "853"],
    [t("Macedonia"), "mk", "389"],
    [t("Madagascar"), "mg", "261"],
    [t("Malawi"), "mw", "265"],
    [t("Malaysia"), "my", "60"],
    [t("Maldives"), "mv", "960"],
    [t("Mali"), "ml", "223"],
    [t("Malta"), "mt", "356"],
    [t("MarshallIslands"), "mh", "692"],
    [t("Martinique"), "mq", "596"],
    [t("Mauritania"), "mr", "222"],
    [t("Mauritius"), "mu", "230"],
    [t("Mayotte"), "yt", "262", 1],
    [t("Mexico"), "mx", "52"],
    [t("Micronesia"), "fm", "691"],
    [t("Moldova"), "md", "373"],
    [t("Monaco"), "mc", "377"],
    [t("Mongolia"), "mn", "976"],
    [t("Montenegro"), "me", "382"],
    [t("Montserrat"), "ms", "1664"],
    [t("Morocco"), "ma", "212", 0],
    [t("Mozambique"), "mz", "258"],
    [t("Myanma"), "mm", "95"],
    [t("Namibia"), "na", "264"],
    [t("Nauru"), "nr", "674"],
    [t("Nepal"), "np", "977"],
    [t("Netherlands"), "nl", "31"],
    [t("NewCaledonia"), "nc", "687"],
    [t("NewZealand"), "nz", "64"],
    [t("Nicaragua"), "ni", "505"],
    [t("Niger"), "ne", "227"],
    [t("Nigeria"), "ng", "234"],
    [t("Niue"), "nu", "683"],
    [t("NorfolkIsland"), "nf", "672"],
    [t("NorthKorea"), "kp", "850"],
    [t("NorthernMarianaIslands"), "mp", "1670"],
    [t("Norway"), "no", "47", 0],
    [t("Oman"), "om", "968"],
    [t("Pakistan"), "pk", "92"],
    [t("Palau"), "pw", "680"],
    [t("Palestine"), "ps", "970"],
    [t("Panama"), "pa", "507"],
    [t("PapuaNewGuinea"), "pg", "675"],
    [t("Paraguay"), "py", "595"],
    [t("Peru"), "pe", "51"],
    [t("Philippines"), "ph", "63"],
    [t("Poland"), "pl", "48"],
    [t("Portugal"), "pt", "351"],
    [t("PuertoRico"), "pr", "1", 3, ["787", "939"]],
    [t("Qatar"), "qa", "974"],
    [t("RÃ©union"), "re", "262", 0],
    [t("Romania"), "ro", "40"],
    [t("Russia"), "ru", "7", 0],
    [t("Rwanda"), "rw", "250"],
    [t("SaintBarthÃ©lemy"), "bl", "590", 1],
    [t("SaintHelena"), "sh", "290"],
    [t("SaintKittsandNevis"), "kn", "1869"],
    [t("SaintLucia"), "lc", "1758"],
    [t("SaintMartin"), "mf", "590", 2],
    [t("SaintPierreAndMiquelon"), "pm", "508"],
    [t("SaintVincentAndTheGrenadines"), "vc", "1784"],
    [t("Samoa"), "ws", "685"],
    [t("San Marino"), "sm", "378"],
    [t("SaoTomeAndPrÃ­ncipe"), "st", "239"],
    [t("SaudiArabia"), "sa", "966"],
    [t("Senegal"), "sn", "221"],
    [t("Serbia"), "rs", "381"],
    [t("Seychelles"), "sc", "248"],
    [t("SierraLeone"), "sl", "232"],
    [t("Singapore"), "sg", "65"],
    [t("SintMaarten"), "sx", "1721"],
    [t("Slovakia"), "sk", "421"],
    [t("Slovenia"), "si", "386"],
    [t("SolomonIslands"), "sb", "677"],
    [t("Somalia"), "so", "252"],
    [t("SouthAfrica"), "za", "27"],
    [t("SouthKorea"), "kr", "82"],
    [t("SouthSudan"), "ss", "211"],
    [t("Spain"), "es", "34"],
    [t("SriLanka"), "lk", "94"],
    [t("Sudan"), "sd", "249"],
    [t("Suriname"), "sr", "597"],
    [t("SvalbardAndJanMayen"), "sj", "47", 1],
    [t("Swaziland"), "sz", "268"],
    [t("Sweden"), "se", "46"],
    [t("Switzerland"), "ch", "41"],
    [t("Syria"), "sy", "963"],
    [t("Taiwan"), "tw", "886"],
    [t("Tajikistan"), "tj", "992"],
    [t("Tanzania"), "tz", "255"],
    [t("Thailand"), "th", "66"],
    [t("Timor-Leste"), "tl", "670"],
    [t("Togo"), "tg", "228"],
    [t("Tokelau"), "tk", "690"],
    [t("Tonga"), "to", "676"],
    [t("TrinidadAndTobago"), "tt", "1868"],
    [t("Tunisia"), "tn", "216"],
    [t("Turkey"), "tr", "90"],
    [t("Turkmenistan"), "tm", "993"],
    [t("TurksAndCaicosIslands"), "tc", "1649"],
    [t("Tuvalu"), "tv", "688"],
    [t("U.S.VirginIslands"), "vi", "1340"],
    [t("Uganda"), "ug", "256"],
    [t("Ukraine"), "ua", "380"],
    [t("UnitedArabEmirates"), "ae", "971"],
    [t("UnitedKingdom"), "gb", "44", 0],
    [t("United States"), "us", "1", 0],
    [t("Uruguay"), "uy", "598"],
    [t("Uzbekistan"), "uz", "998"],
    [t("Vanuatu"), "vu", "678"],
    [t("VaticanCity"), "va", "39", 1],
    [t("Venezuela"), "ve", "58"],
    [t("Vietnam"), "vn", "84"],
    [t("WallisAndFutuna"), "wf", "681"],
    [t("WesternSahara"), "eh", "212", 1],
    [t("Yemen"), "ye", "967"],
    [t("Zambia"), "zm", "260"],
    [t("Zimbabwe"), "zw", "263"],
    [t("Ã…landIslands"), "ax", "358", 1],
  ];

  const countries: CountriesInfo[] = [
    { text: t("Argentina"), value: "Argentina" },
    { text: t("Brazil"), value: "Brazil" },
    { text: t("Canada"), value: "Canada" },
    { text: t("China"), value: "China" },
    { text: t("France"), value: "France" },
    { text: t("Germany"), value: "Germany" },
    { text: t("India"), value: "India" },
    { text: t("Italy"), value: "Italy" },
    { text: t("Japan"), value: "Japan" },
    { text: t("Mexico"), value: "Mexico" },
    { text: t("Russia"), value: "Russia" },
    { text: t("Spain"), value: "Spain" },
    { text: t("United Kingdom"), value: "United Kingdom" },
    { text: t("United States"), value: "United States" },
  ];

  return { countriesPhoneCodes, countries };
};

export default useLocalizedCountries;


### hooks/useLocalizedFileUploader.tsx ###
import { useUserStore } from "../stores/UserStore";
import { useEffect, useState } from "react";
import { Locale } from "@uppy/core";

const useLocalizedFileUploader = () => {
  const [localizations, setLocalizations] = useState<Locale>();

  const { preferredLanguage } = useUserStore();

  useEffect(() => {
    const loadLanguageModule = async () => {
      let languageModule;
      switch (preferredLanguage) {
        case "es":
          languageModule = await import("@uppy/locales/lib/es_MX");
          break;
        case "en":
          languageModule = await import("@uppy/locales/lib/en_US");
          break;
        default:
          languageModule = await import("@uppy/locales/lib/es_MX");
          break;
      }
      setLocalizations(languageModule.default);
    };

    loadLanguageModule();
  }, [preferredLanguage]);

  return { localizations };
};

export default useLocalizedFileUploader;


### hooks/useNetworkErrorHandler.tsx ###
import { useRouter } from "next/router";
import useNotification from "./useNotificationsComponent";
import { useTranslation } from "react-i18next";
import { routes } from "../routes";
import AccountService from "../services/AccountService";

type Errors = { [key: string]: string[] };

type InnerException = {
  className: string;
  message: string;
};

type Exception = {
  errors: Errors | null;
  message: string;
  data: object;
  innerException: InnerException | null;
  helpLink: string | null;
  source: string;
  hResult: number;
  stackTrace: string;
};

type ServerError = {
  statusCode: number;
  message: string;
  errors: Errors | null;
  exception: Exception | null;
};

const useNetworkErrorHandler = () => {
  const modalError = useNotification();
  const { t } = useTranslation("NotificationComponent");
  const router = useRouter();

  const handleError = async (error: any, onClose?: () => void) => {
    if (error instanceof Response) {
      let currentErrors: string[] = [];

      try {
        // Check the content type of the response
        const contentType = error.headers.get("content-type");
        let responseData;

        if (contentType && contentType.includes("application/json")) {
          responseData = await error.json();
        } else {
          responseData = await error.text();
        }

        if (error.status === 500) {
          currentErrors = [t("InternalServerError")];
        } else if (error.status === 403) {
          currentErrors = [t("Unauthorized")];
        } else if (error.status === 401) {
          await AccountService.logout(null);
          router.push(routes.LOGIN);
        } else if (error.status === 400) {
          if (contentType && contentType.includes("application/json")) {
            if (Array.isArray(responseData.errors)) {
              currentErrors = responseData.errors.map((err: string) => err);
            } else if (typeof responseData.message === "string") {
              currentErrors = [responseData.message || t("BadRequest")];
            } else {
              currentErrors = [t("BadRequest")];
            }
          } else {
            currentErrors = [responseData || t("BadRequest")];
          }
        }

        modalError.show({
          errors: currentErrors,
          component: "modal",
          onClose: onClose,
        });
      } catch (e) {
        modalError.show({
          errors: [t("UnexpectedError")],
          component: "modal",
          onClose: onClose,
        });
      }
    } else {
      modalError.show({
        errors: [t("UnexpectedError")],
        component: "modal",
        onClose: onClose,
      });
    }
  };

  return { handleError };
};

export default useNetworkErrorHandler;


### hooks/useNotificationsComponent.tsx ###
import { useContext } from "react";
import { NotificationContext } from "../context/NotificationsComponentContext";

const useNotificationsComponent = () => {
  const context = useContext(NotificationContext);

  return context;
};

export default useNotificationsComponent;


### hooks/useTermsAndConditionsModal.tsx ###
import { AccentColor } from "@fusion/theme";
import { TermsAndConditionsModal } from "@fusion/ui";
import Link from "next/link";
import { useState } from "react";
import AccountService from "../services/AccountService";

type TermsAndConditionsOptions = {
  accepted: boolean;
  url?: string;
  accentColor?: AccentColor;
};

const useTermsAndConditionsModal = ({
  accepted,
  url,
  accentColor = "primary",
}: TermsAndConditionsOptions) => {
  const [isOpen, setIsOpen] = useState<boolean>(!accepted);

  const onCancel = () => {
    setIsOpen(false);
  };

  const onConfirm = async () => {
    try {
      await AccountService.acceptTermsAndConditions();
      setIsOpen(false);
    } catch (error) {
      console.error(error);
    }
  };

  const TermsModal = !url ? null : (
    <TermsAndConditionsModal
      cancelLabel={"Cancel"}
      confirmLabel={"Accept"}
      description="Please review and accept our Terms and Conditions to continue"
      isOpen={isOpen}
      LinkComponent={
        <Link
          className={`tw-text-${accentColor}-500 focus:tw-outline-none hover:tw-text-${accentColor}-600`}
          href={url}
          target="_blank"
        >
          Read terms and conditions
        </Link>
      }
      onCancel={onCancel}
      onConfirm={onConfirm}
      title={"Terms and conditions"}
    />
  );

  return { TermsModal } as const;
};

export default useTermsAndConditionsModal;


### i18n.ts ###
import i18n from "i18next";
import { initReactI18next } from "react-i18next";
import en from "./translate/en/common.json";
import es from "./translate/es-AR/common.json";

i18n
  .use(initReactI18next)
  .init({
    lng: "es",
    fallbackLng: "en",
    interpolation: {
      escapeValue: false,
    },
    saveMissing: false,
    resources: {
      es: es,
      en: en,
    },
  })
  .catch((err) => {
    console.error(err);
  });

export default i18n;


### middleware.ts ###
import { NextRequest, NextResponse } from "next/server";
import { publicRoutes, routes } from "./routes";

export function middleware(request: NextRequest) {
  const { pathname, protocol, host } = request.nextUrl;

  console.log('--------------------- host:' + host)
  // Intercept API calls
  if (pathname.startsWith("/api")) {
    return NextResponse.next();
  }

  const cookie = request.cookies.get(process.env.COOKIE_NAME!);

  // If the user is logged in, redirect to the home page when they try to access the login page
  if (cookie && pathname === routes.LOGIN) {
    return NextResponse.redirect(`${protocol}//${host}${routes.HOME}`);
  }

  const isPrivatePath = !publicRoutes.includes(pathname);

  // If the user is not logged in, redirect to the login page when they try to access a private page
  if (!cookie && isPrivatePath) {
    return NextResponse.redirect(`${protocol}//${host}${routes.LOGIN}`);
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    "/((?!_next/static|_next/image|favicon.ico).*)",
  ],
};


### network-client.ts ###
import { FetchClient } from "@fusion/network";

const client = new FetchClient({
  apiVersion: "1",
});

export default client;


### next-env.d.ts ###
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.


### next.config.js ###
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: false,
  swcMinify: false,
  output: 'standalone'
};

module.exports = nextConfig;


### package.json ###
{
  "name": "fleebe-tt",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "build:windows": "next build && npm run copy-files:windows --output-path=./Standalone",
    "copy-files:windows": "powershell -File scripts/copy-files-windows.ps1",
    "build:linux": "next build && npm run copy-files:linux",
    "copy-files:linux": "bash scripts/copy-files-linux.sh"
  },
  "engines": {
    "node": "^16"
  },
  "dependencies": {
    "@fusion/network": "0.0.24",
    "@fusion/theme": "0.0.24",
    "@fusion/ui": "0.0.24",
    "@fusion/utils": "0.0.24",
    "@headlessui/react": "^1.7.4",
    "@heroicons/react": "^2.0.13",
    "@highcharts/dashboards": "^1.2.1",
    "@hookform/error-message": "^2.0.1",
    "@hookform/resolvers": "^2.9.10",
    "@tailwindcss/forms": "^0.5.3",
    "@types/node": "18.11.9",
    "@uppy/dashboard": "^2.4.2",
    "@uppy/drag-drop": "^2.1.2",
    "@uppy/file-input": "^2.1.2",
    "@uppy/image-editor": "^1.4.2",
    "@uppy/locales": "^3.5.2",
    "@uppy/progress-bar": "^2.1.2",
    "@uppy/react": "^2.2.3",
    "@uppy/status-bar": "^2.2.2",
    "@uppy/tus": "^2.4.3",
    "@uppy/webcam": "^2.2.2",
    "@uppy/xhr-upload": "^2.1.2",
    "apexcharts": "^3.45.2",
    "cookies": "^0.8.0",
    "cookies-next": "^2.1.1",
    "dayjs": "^1.11.7",
    "devextreme": "24.1.4",
    "devextreme-react": "24.1.4",
    "dotenv": "16.4.5",
    "eslint": "8.27.0",
    "eslint-config-next": "13.0.3",
    "framer-motion": "10.18.0",
    "highcharts": "^11.3.0",
    "highcharts-react-official": "^3.2.1",
    "http-proxy-middleware": "^2.0.6",
    "i18next": "^19.6.3",
    "next": "13.0.3",
    "next-connect": "^1.0.0-next.4",
    "next-http-proxy-middleware": "^1.2.6",
    "react": "^18.2.0",
    "react-apexcharts": "^1.4.1",
    "react-audio-voice-recorder": "^2.2.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.40.0",
    "react-i18next": "^11.18.6",
    "react-intl-tel-input-18": "0.0.0",
    "react-slider": "2.0.6",
    "sanitize-html": "2.11.0",
    "typescript": "4.9.3",
    "use-debounce": "^10.0.0",
    "zod": "^3.20.0",
    "zustand": "^4.1.4"
  },
  "devDependencies": {
    "@types/cookies": "^0.7.7",
    "@types/highcharts": "^7.0.0",
    "@types/http-proxy": "^1.17.11",
    "@types/http-proxy-middleware": "^1.0.0",
    "@types/react": "^18.2.42",
    "@types/react-dom": "^18.2.17",
    "@types/react-slider": "1.3.6",
    "@types/sanitize-html": "2.9.5",
    "autoprefixer": "^10.4.13",
    "deepmerge": "4.3.1",
    "postcss": "^8.4.19",
    "tailwindcss": "^3.2.4"
  }
}

### pages/401.tsx ###
import { Button } from "@fusion/ui";
import { useRouter } from "next/router";
import { useTranslation } from "react-i18next";
import { routes } from "../routes";
import AccountService from "../services/AccountService";

const Unauthorized = () => {
  const router = useRouter();
  const { t } = useTranslation("UnauthorizedScreen");

  return (
    <main className="tw-grid tw-min-h-full tw-place-items-center tw-bg-white tw-px-6 tw-py-24 sm:tw-py-32 lg:tw-px-8">
      <div className="tw-text-center">
        <p className="tw-text-base tw-font-semibold tw-text-primary-600">401</p>
        <h1 className="tw-mt-4 tw-text-3xl tw-font-bold tw-tracking-tight tw-text-gray-900 sm:tw-text-5xl">
          {t("TitleLabel")}
        </h1>
        <p className="tw-mt-6 tw-text-base tw-leading-7 tw-text-gray-600">
          {t("BodyLabel")}
        </p>
        <div className="tw-mt-10 tw-flex tw-items-center tw-justify-center tw-gap-x-6">
          <Button
            onClick={async () => {
              await AccountService.logout(null);
              router.push(routes.LOGIN);
            }}
          >
            {t("ConfirmLabel")}
          </Button>
        </div>
      </div>
    </main>
  );
};

export default Unauthorized;


### pages/500.tsx ###
import ErrorMessage from "../components/ErrorMessage";

export default function Error() {
  return <ErrorMessage />;
}


### pages/_app.tsx ###
import "@uppy/core/dist/style.min.css";
import "@uppy/dashboard/dist/style.min.css";
import "@uppy/image-editor/dist/style.css";
import "@uppy/webcam/dist/style.min.css";
import "devextreme/dist/css/dx.light.css";
import { GetServerSideProps } from "next";
import type { AppProps } from "next/app";
import { I18nextProvider } from "react-i18next";
import "react-intl-tel-input-18/dist/main.css";
import ErrorBoundary from "../components/ErrorBoundary";
import Layout from "../components/Layout";
import { NotificationsComponentContext } from "../context/NotificationsComponentContext";
import i18n from "../i18n";
import "../styles/forms.css";
import "../styles/globals.css";
import "../styles/variables.css";
import { useUserStore } from "../stores/UserStore";
import { useEffect, useState } from "react";
import devexConfig from "devextreme/core/config";

devexConfig({ licenseKey: process.env.NEXT_PUBLIC_DEVEXTREME_LICENSE_KEY });

export const getServerSideProps: GetServerSideProps = async (props) => {
  return {
    props: props,
  };
};

export default function App({ Component, pageProps }: AppProps) {
  const { preferredLanguage } = useUserStore();
  const [ready, setReady] = useState(false);

  const checkLanguage = () => {
    if (preferredLanguage) {
      i18n.changeLanguage(preferredLanguage);
    }
    setReady(true);
  };

  useEffect(() => {
    checkLanguage();
  }, []);

  if (!ready) {
    return null;
  }

  return (
    <I18nextProvider i18n={i18n}>
      <ErrorBoundary>
        <NotificationsComponentContext>
          <Layout>
            <Component {...pageProps} />
          </Layout>
        </NotificationsComponentContext>
      </ErrorBoundary>
    </I18nextProvider>
  );
}


### pages/_document.tsx ###
import { Html, Head, Main, NextScript } from "next/document";
import React from "react";

export default function Document() {
  return (
    <Html className="tw-h-full tw-bg-white tw-font-sans">
      <Head />
      <body className="tw-h-full">
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}


### pages/api/[...slot].ts ###
import type { NextApiRequest, NextApiResponse } from "next";
import {
  cloneRequestHeaders,
  handleRefreshToken,
  isTokenExpired,
  setResponseHeaders,
} from "../../server/proxy";

export default async (
  req: NextApiRequest,
  res: NextApiResponse
): Promise<void> => {
  let headers = cloneRequestHeaders(req);

  let fetchResponse = await fetch(`${process.env.API_URL}${req.url}`, {
    headers,
    method: req.method,
    body:
      (req.method === "POST" || req.method === "PUT") && req.body !== undefined
        ? JSON.stringify(req.body)
        : undefined,
  });

  if (fetchResponse === undefined) {
    res.status(404).end();
    return;
  }

  if (fetchResponse.ok) {
    await handleResponse(res, fetchResponse);
    return;
  }

  if (isTokenExpired(fetchResponse)) {
    try {
      const { accessToken, refreshToken } = await handleRefreshToken(req);

      // retry request with new access token
      headers.set("Authorization", `Bearer ${accessToken}`);

      fetchResponse = await fetch(`${process.env.API_URL}${req.url}`, {
        headers,
        method: req.method,
        body:
          req.method === "POST" || (req.method === "PUT" && req.body)
            ? JSON.stringify(req.body)
            : undefined,
      });

      if (fetchResponse.ok) {
        res.setHeader("Set-Cookie", [
          `${process.env.COOKIE_NAME}=${JSON.stringify({
            token: accessToken,
            refreshToken,
          })}; Path=/; HttpOnly`,
        ]);
        await handleResponse(res, fetchResponse);
        return;
      }

      res.status(fetchResponse.status).end();
    } catch (error) {
      res.status(fetchResponse.status).end();
    }
  } else {
    handleResponse(res, fetchResponse);
  }
};

const handleResponse = async (
  res: NextApiResponse,
  fetchResponse: Response
) => {
  setResponseHeaders(res, fetchResponse.headers);
  const contentType = fetchResponse.headers.get("content-type");

  switch (contentType) {
    case "text/plain":
    case "text/plain; charset=utf-8":
      const text = await fetchResponse.text();
      res.status(fetchResponse.status).send(text);
      break;
    case null:
      res.status(fetchResponse.status).end();
      break;
    case "image/png":
      const image = fetchResponse.body;
      res.setHeader("content-type", "image/png");
      res.status(fetchResponse.status).send(image);
      break;
    case "application/json":
    default:
      const body = await fetchResponse.json();
      res.status(fetchResponse.status).json(body);
      break;
  }
};

export const config = {
  api: {
    externalResolver: true,
  },
};


### pages/api/account/login.ts ###
import type { NextApiRequest, NextApiResponse } from "next";
import { cloneRequestHeaders, setResponseHeaders } from "../../../server/proxy";

export default async (req: NextApiRequest, res: NextApiResponse) => {
  // copy headers from incoming request to fetch request
  const headers = cloneRequestHeaders(req);

  console.log(`--------------> URL: ${process.env.API_URL}${req.url}`)
  const fetchResponse = await fetch(`${process.env.API_URL}${req.url}`, {
    headers,
    body: JSON.stringify(req.body),
    method: req.method,
  });

  // copy headers from fetch response to outgoing response
  setResponseHeaders(res, fetchResponse.headers);

  // also copy the body from fetch response to outgoing response
  const body: LoginRes = await fetchResponse.json();

  // set the cookie in the outgoing response
  if (fetchResponse.status === 200) {
    res.setHeader("Set-Cookie", [
      `${process.env.COOKIE_NAME}=${JSON.stringify({
        token: body.token,
        refreshToken: body.refreshToken,
      })}; Path=/; HttpOnly`,
    ]);
  }

  // TODO: Show API response on error
  res.status(fetchResponse.status).json(body);
};

type LoginRes = {
  token: string;
  refreshToken: string;
};

export const config = {};


### pages/api/account/logout.ts ###
import type { NextApiRequest, NextApiResponse } from "next";
import {
  cloneRequestHeaders,
  handleRefreshToken,
  isTokenExpired,
  setResponseHeaders,
} from "../../../server/proxy";

export default async (
  req: NextApiRequest,
  res: NextApiResponse
): Promise<void> => {
  let headers = cloneRequestHeaders(req);

  let fetchResponse = await fetch(`${process.env.API_URL}${req.url}`, {
    headers,
    method: req.method,
  });

  handleSuccess(res, fetchResponse);

  if (fetchResponse.ok) {
    return;
  }

  if (isTokenExpired(fetchResponse)) {
    try {
      const { accessToken } = await handleRefreshToken(req);

      // retry request with new access token
      headers.set("authorization", `Bearer ${accessToken}`);

      fetchResponse = await fetch(`${process.env.API_URL}${req.url}`, {
        headers,
        method: req.method,
      });

      if (fetchResponse.ok) {
        handleSuccess(res, fetchResponse);
      }

      res.status(fetchResponse.status).end();
    } catch (error) {
      res.status(fetchResponse.status).end();
    }
  }

  res.status(fetchResponse.status).end();
};

const handleSuccess = (res: NextApiResponse, fetchResponse: Response) => {
  // copy headers from fetch response to outgoing response
  setResponseHeaders(res, fetchResponse.headers);
  res.setHeader("Set-Cookie", [
    `${process.env.COOKIE_NAME}=; Path=/; HttpOnly; Max-Age=0;`,
  ]);
  res.status(fetchResponse.status).end();
};

export const config = {};


### pages/api/account/refresh.ts ###
import type { NextApiRequest, NextApiResponse } from "next";
import { handleRefreshToken } from "../../../server/proxy";

export default async (req: NextApiRequest, res: NextApiResponse) => {
  const { accessToken, refreshToken } = await handleRefreshToken(req);

  res.setHeader("Set-Cookie", [
    `${process.env.COOKIE_NAME}=${JSON.stringify({
      token: accessToken,
      refreshToken,
    })}; Path=/; HttpOnly`,
  ]);

  res.status(200).end();
};

export const config = {};


### pages/api/copilot/form-completion/transcribe/index.ts ###
import httpProxy from "http-proxy";
import { NextApiRequest, NextApiResponse } from "next";
import { cloneRequestHeaders } from "../../../../../server/proxy";

export const config = {
  api: {
    externalResolver: true,
    bodyParser: false,
  },
};

export default (nextReq: NextApiRequest, nextRes: NextApiResponse) =>
  new Promise((resolve, reject) => {
    const proxy: httpProxy = httpProxy.createProxy({});

    proxy
      .once("proxyReq", (proxyReq, req) => {
        const headers = cloneRequestHeaders(nextReq);
        proxyReq.setHeader("Authorization", headers.get("Authorization")!);
      })
      .once("proxyRes", resolve)
      .once("error", reject)
      .web(nextReq, nextRes, {
        changeOrigin: true,
        target: process.env.API_URL,
      });
  });


### pages/api/file/[...slot].ts ###
import httpProxy from "http-proxy";
import { NextApiRequest, NextApiResponse } from "next";
import { cloneRequestHeaders } from "../../../server/proxy";

export const config = {
  api: {
    externalResolver: true,
    bodyParser: false,
  },
};

export default (nextReq: NextApiRequest, nextRes: NextApiResponse) =>
  new Promise((resolve, reject) => {
    const proxy: httpProxy = httpProxy.createProxy({});

    proxy
      .once("proxyReq", (proxyReq, req) => {
        const headers = cloneRequestHeaders(nextReq);
        proxyReq.setHeader("Authorization", headers.get("Authorization")!);
      })
      .once("proxyRes", resolve)
      .once("error", reject)
      .web(nextReq, nextRes, {
        changeOrigin: true,
        target: process.env.API_URL,
      });
  });


### pages/calendar/[...slug].tsx ###
import {
  Button,
  Form,
  FormLabel,
  FormServerSideErrors,
  Input,
  Select,
  useServerSideErrors,
} from "@fusion/ui";
import { memo, useEffect, useRef, useState } from "react";
import { GetServerSideProps } from "next";
import CalendarService, { CalendarRes } from "../../services/CalendarService";
import { zodResolver } from "@hookform/resolvers/zod";
import { useRouter } from "next/router";
import { useTranslation } from "react-i18next";
import { useForm } from "react-hook-form";
import { z } from "zod";
import AccountService from "../../services/AccountService";
import { roles } from "../../roles";
import useNetworkErrorHandler from "../../hooks/useNetworkErrorHandler";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [roles.FrontFrontHumanCapital];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );
  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }
  
  const { slug } = context.query;
  
  if (!slug) return { props: {} };
  
  if (slug?.length === 1 && slug[0] === "create")
    return {
  props: {
    mode: "create",
  },
};

if (slug?.length > 1 && slug[0] === "edit") {
  const calendarId = slug[1];
  const { data: calendar, cookies } = await CalendarService.getById(
    calendarId,
    context.req.cookies
  );
  // If cookies exists, set them in the response because the token was refreshed
  cookies && context.res.setHeader("Set-Cookie", cookies);
  
  return {
    props: {
      calendar,
      mode: "edit",
    },
  };
}

return { props: {} };
};

type CalendarCreateOrEditProps = React.FC<{
  calendar?: CalendarRes;
  mode: "create" | "edit";
}>;

type CalendarOption = {
  name: string;
  value: string;
};
const CalendarCreateOrEdit: CalendarCreateOrEditProps = (props) => {
  const { calendar, mode } = props;
  const { handleError } = useNetworkErrorHandler();
  const router = useRouter();
  const firstMount = useRef<boolean>(true);
  const [calendars, setCalendars] = useState<CalendarOption[]>();
  const { t } = useTranslation("CalendarCreateOrEditScreen");
  const {
    errors,
    setErrors,
    clearErrors: clearServerErrors,
  } = useServerSideErrors<CalendarRes>();

  const validationSchema = z.object({
    name: z
      .string({
        required_error: t("NameRequiredValidationMessage"),
      })
      .refine(
        (value) => {
          return value.trim() !== "";
        },
        { message: t("NameRequiredValidationMessage") }
      ),
      basedOn: z.string().optional(),
    
  });

  type ValidationSchema = z.infer<typeof validationSchema>;

  const {
    control,
    handleSubmit,
    formState: { errors: clientErrors, isSubmitting },
    clearErrors: clearClientErrors,
  } = useForm<ValidationSchema>({
    defaultValues: calendar
      ? {
          name: calendar.name
        }
      : {
          
        },
    resolver: zodResolver(validationSchema),
  });
  
  const getCalendars = async () => {
    try {
      const result = await CalendarService.getAll();
      const calendars = result.items.map((c) => ({
        value: c.id ?? "",
        name: c.name,
      }));
      setCalendars(calendars);
    } catch (error) {
      handleError(error);
    }
  };

  useEffect(() => {
    if (firstMount.current) {
      firstMount.current = false;
      getCalendars();
    }
  }, []);

  const onCancel = () => {
    router.back();
  };

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearServerErrors();
      try {
        const dto = {
          id: calendar?.id,
          name: data.name,
          basedOn: data.basedOn,
        };
        mode === "edit"
          ? calendar?.id && (await CalendarService.update(calendar.id, dto))
          : await CalendarService.create(dto);
        router.push("/calendar");
      } catch (error) {
        setErrors(error);
      }
    },
    (error, event) => {
      event?.preventDefault();
    }
  );

  return (
    <div className="tw-pb-4">
      <h1 className="tw-text-3xl tw-font-bold lg:tw-mt-12 tw-mb-4">
        {mode === "create" ? t("NewTitle") : t("EditTitle")}
      </h1>
      <div className="tw-bg-white tw-px-6 tw-py-3 tw-border-2 shadow tw-border-gray-200 tw-w-full lg:tw-max-w-[705px]">
        <Form>
          <Input
            name="name"
            defaultValue={calendar?.name}
            control={control}
            type="text"
            LabelComponent={<FormLabel required>{t("NameLabel")}</FormLabel>}
            placeholder={t("NamePlaceholder")}
            errors={errors}
          ></Input>
          {mode === "create" && 
          (
          <Select
            multiple={false}
            LabelComponent={<FormLabel>{t("BasedInLabel")}</FormLabel>}
            name="basedOn"
            placeholder={t("BasedInPlaceholder")}
            control={control}
            searchEnabled={false}
            displayExpr={"name"}
            valueExpr={"value"}
            items={
              calendars
            }
            errors={errors}
          />
          )}
          {/* Show general errors that are not related to any specific field */}
          <div className="errors">
            {errors && Object.keys(errors).length > 0 ? (
              <FormServerSideErrors
                errors={errors}
                fieldKey={""}
              ></FormServerSideErrors>
            ) : null}
          </div>

          <div className="tw-py-4">
            <div className="tw-flex tw-justify-end tw-gap-2">
              <Button
                variant="secondary"
                disabled={isSubmitting}
                onClick={() => {
                  onCancel();
                }}
              >
                {t("Cancel")}
              </Button>
              <Button
                onClick={onSubmit}
                disabled={isSubmitting}
                loading={isSubmitting}
              >
                {t("Save")}
              </Button>
            </div>
          </div>
        </Form>
      </div>
    </div>
  );
};

export default memo(CalendarCreateOrEdit);


### pages/calendar/index.tsx ###
import {
  Button,
  Column,
  Form,
  FormLabel,
  Input,
  Modal,
  PageHeader,
  Select,
  Switch,
  useServerSideErrors,
} from "@fusion/ui";
import { DefaultActionButtons } from "../../components/DefaultActionButtons";
import CalendarService, { CalendarPage } from "../../services/CalendarService";
import AccountService from "../../services/AccountService";
import { DataGridColumnInformation } from "@fusion/utils";
import { PlusIcon } from "@heroicons/react/20/solid";
import Link from "next/link";
import { useRouter } from "next/router";
import { useTranslation } from "react-i18next";
import { roles } from "../../roles";
import { GetServerSideProps } from "next";
import useNetworkErrorHandler from "../../hooks/useNetworkErrorHandler";
import { DataGridTypes } from "devextreme-react/cjs/data-grid";
import { LocalGrid } from "../../components/LocalGrid";
import Calendar, { MultipleRangeValues } from "../../components/Calendar";
import { useEffect, useRef, useState } from "react";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import CalendarDayService, {
  CalendarDayRes,
} from "../../services/CalendarDayService";
import { calendarDayTypes } from "../../constants/CalendarDayTypes";
import { DateHelper } from "../../helpers/DateHelper";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [roles.FrontFrontHumanCapital];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );

  const calendar = await CalendarService.getAll({
    page: 1,
    pageSize: 1,
    cookies: context.req.cookies,
  });

  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }
  return { props: { calendar } };
};

type CalendarProps = {
  calendar: CalendarPage;
};

type CalendarDay = {
  id: string;
  name: string;
  calendarId: string;
  date: Date;
  calendarDayTypeId?: string;
};

const Calendars = (props: CalendarProps) => {
  const router = useRouter();
  const { t } = useTranslation("CalendarListScreen");
  const { handleError } = useNetworkErrorHandler();
  const { errors, setErrors, clearErrors } =
    useServerSideErrors<CalendarDayRes>();
  const getCalendarUrl = `/api/calendar/get-by-current-companyId?format=dx`;
  const { calendar } = props;
  const [showDayModal, setShowDayModal] = useState<boolean>(false);
  const [selectedDay, setSelectedDay] = useState<string>("");
  const [selectedDayData, setSelectedDayData] = useState<MultipleRangeValues>();
  const [selectedCalendarData, setSelectedCalendarData] = useState<
    MultipleRangeValues[]
  >([]);
  const [filteredCalendarDays, setFilteredCalendarDays] = useState<
    MultipleRangeValues[]
  >([]);
  const [clickedRowKey, setClickedRowKey] = useState<number>();
  const [isDeleteIconClicked, setIsDeleteIconClicked] =
    useState<boolean>(false);

  const readyCalendarOriginalDataSet = useRef(false);
  const [tipoDiaFestivoValue, setTipoDiaFestivoValue] = useState<string>("");

  //this useEffect is important to order the calendar with the correct months and mark correctly the days
  useEffect(() => {
    if (
      !readyCalendarOriginalDataSet.current &&
      filteredCalendarDays.length > 0
    ) {
      readyCalendarOriginalDataSet.current = true;
      setFilteredCalendarDays([]);
      return;
    }
    if (filteredCalendarDays.length == 0 && selectedCalendarData.length > 0) {
      setFilteredCalendarDays(selectedCalendarData);
    }
  }, [filteredCalendarDays, selectedCalendarData]);

  const deleteCalendarById = async (id: string) => {
    try {
      await CalendarService.delete(id);
      router.push("/calendar");
    } catch (error) {
      handleError(error);
    }
  };

  const deleteCalendarDayById = async (id: string) => {
    try {
      await CalendarDayService.delete(id);
      router.push("/calendar");
    } catch (error) {
      handleError(error);
    }
  };

  const canCreateCalendar = (item: CalendarPage) => {
    return item.links.some((a: { rel: string }) => a.rel === "Create");
  };

  const color1 = "tw-bg-red-500";

  const loadCalendar = (e: DataGridTypes.RowClickEvent) => {
    // Cast rowElement to HTMLTableRowElement to access 'cells'
    const rowElement = e.rowElement as HTMLTableRowElement;
    const clickedCell = e.event && (e.event.target as HTMLElement); // The HTML element that was clicked
    const cells = Array.from(rowElement.getElementsByTagName("td")); // Get the <td> elements in the row
    const clickedColumnIndex = cells.indexOf(
      clickedCell as HTMLTableCellElement
    );
    // if the Column clicked has action buttons return
    if (clickedColumnIndex === -1) return;

    // if the Column clicked has no buttons select row and load calendar
    if (e.rowType === "data" && !isDeleteIconClicked) {
      const calendarValues = e.data.calendarDays.map(
        (c: CalendarDay, index: number) => {
          const date = new Date(c.date);
          date.setHours(date.getHours() + 1);
          const cellValue = {
            id: c.calendarId ?? "",
            singleDayId: c.id ?? "",
            name: c.name,
            startDate: date,
            endDate: date,
            rangeColorClass: calendarDayTypes.find(
              (cd) => cd.id === c.calendarDayTypeId
            )?.color,
            shownDays: [0, 1, 2, 3, 4, 5, 6],
          };
          return cellValue;
        }
      );

      if (calendarValues.length === 0) {
        calendarValues.push({
          id: e.data.id ?? "",
          singleDayId: "",
          startDate: new Date(),
          endDate: new Date(),
          rangeColorClass: color1,
          shownDays: [],
        });
      }

      setSelectedCalendarData(calendarValues);
      setFilteredCalendarDays(calendarValues);
      setClickedRowKey(e.rowIndex);
    }
  };

  const customizeRow = (e: DataGridTypes.RowPreparedEvent) => {
    if (e.rowIndex === clickedRowKey) {
      e.rowElement.style.backgroundColor = "#f5f5f5";
    }
  };

  const onDateSelected = (
    e: string | number | Date | (string | number | Date)[]
  ) => {
    const dates = Array.isArray(e)
      ? e.map((date) => new Date(date))
      : [new Date(e)];

    setSelectedDayData(
      selectedCalendarData.find((c) => {
        const startDate = new Date(c.startDate);
        startDate.setHours(0, 0, 0, 0);
        const date = new Date(dates[dates.length - 1]);
        date.setHours(0, 0, 0, 0);
        return startDate.getTime() === date.getTime();
      })
    );
    if (dates.length > 0) {
      setSelectedDay(dates[dates.length - 1].toString());
    }

    setShowDayModal(true);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);

    const formattedDate =
      date.getFullYear() +
      "-" +
      String(date.getMonth() + 1).padStart(2, "0") +
      "-" +
      String(date.getDate()).padStart(2, "0") +
      "T" +
      String(date.getHours()).padStart(2, "0") +
      ":" +
      String(date.getMinutes()).padStart(2, "0") +
      ":" +
      String(date.getSeconds()).padStart(2, "0");

    return new Date(formattedDate);
  };

  const validationSchema = z.object({
    name: z.string({
      required_error: t("NameRequiredValidationMessage"),
    }),
    calendarDayTypeId: z.string({
      required_error: t("HolidyTypeRequiredValidationMessage"),
    }),
  });

  type ValidationSchema = z.infer<typeof validationSchema>;

  const {
    control,
    handleSubmit,
    formState: { errors: clientErrors, isSubmitting },
    clearErrors: clearClientErrors,
  } = useForm<ValidationSchema>({
    resolver: zodResolver(validationSchema),
  });

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearErrors();

      function reloadCalendar() {
        setSelectedCalendarData([]);
        router.reload();
      }
      function dataCallback(success: boolean) {
        if (success) {
          setTipoDiaFestivoValue("");
          reloadCalendar();
        }
      }

      try {
        const dto: CalendarDayRes = {
          id: selectedDayData?.singleDayId,
          name: data.name,
          calendarId: selectedCalendarData[0].id,
          calendarDayTypeId: data.calendarDayTypeId,
          date: DateHelper.toLocalISOString(new Date(selectedDay)),
        };

        if (selectedDayData) {
          await CalendarDayService.update(dto, dataCallback);
        } else {
          await CalendarDayService.create(dto, dataCallback);
        }

        setShowDayModal(false);
        //router.reload();
      } catch (error) {
        setErrors(error);
        console.error("An unexpected error happened:", error);
      }
    },
    (error, event) => {
      event?.preventDefault();
    }
  );

  const filterCalendarValues = (isActive: boolean, filterColor: string) => {
    const filteredRanges = selectedCalendarData.filter(
      (c) => c.rangeColorClass === filterColor
    );

    const updatedFilteredAssignedWorkingHours = isActive
      ? [...filteredCalendarDays, ...filteredRanges]
      : filteredCalendarDays.filter((c) => c.rangeColorClass !== filterColor);

    setFilteredCalendarDays(updatedFilteredAssignedWorkingHours);
  };

  const formatDateTitle = (dateString: string) => {
    const date = new Date(dateString);

    const daysOfWeek = [
      "Domingo",
      "Lunes",
      "Martes",
      "MiÃ©rcoles",
      "Jueves",
      "Viernes",
      "SÃ¡bado",
    ];
    const months = [
      "Enero",
      "Febrero",
      "Marzo",
      "Abril",
      "Mayo",
      "Junio",
      "Julio",
      "Agosto",
      "Septiembre",
      "Octubre",
      "Noviembre",
      "Diciembre",
    ];

    const dayOfWeek = daysOfWeek[date.getDay()];
    const day = date.getDate();
    const month = months[date.getMonth()];

    return `${dayOfWeek} ${day} ${month}`;
  };

  return (
    <>
      {/* Header */}
      <PageHeader title={t("Title")}>
        {canCreateCalendar(calendar) ? (
          <Button
            onClick={() => router.push("/calendar/create")}
            iconLeft={<PlusIcon className="tw-h-3 tw-w-3"></PlusIcon>}
          >
            {t("Create")}
          </Button>
        ) : undefined}
      </PageHeader>

      {/* Grid */}
      {/* Column definitions */}
      <LocalGrid
        onRowClick={(e: DataGridTypes.RowClickEvent) => loadCalendar(e)}
        onRowPrepared={(e: DataGridTypes.RowPreparedEvent) => customizeRow(e)}
        url={getCalendarUrl}
        hoverStateEnabled={true}
        enableRowAlternation={false}
        locale={{
          nameColumn: {
            caption: t("NameColumnLabel", {
              ns: "Gridview",
            }),
          },
        }}
      >
        <Column
          name={"numberOfHolidays"}
          dataField={"numberOfHolidays"}
          caption={t("NumberOfHolidaysColumnLabel")}
          dataType="string"
        ></Column>
        <Column
          name={"numberOfEmployees"}
          dataField={"numberOfEmployees"}
          caption={t("NumberOfEmployeesColumnLabel")}
          dataType="string"
        />
        <Column
          allowFiltering={false}
          allowReordering={false}
          dataField={"Action Buttons"}
          caption={""}
          cellRender={(info: DataGridColumnInformation<null>) => (
            <DefaultActionButtons
              LinkComponent={Link}
              info={info}
              showDetailsButton={false}
              entityName="calendar"
              locale={{
                tooltips: {
                  edit: t("EditActionButtonLabel", {
                    ns: "Gridview",
                  }),
                  delete: t("DeleteActionButtonLabel", {
                    ns: "Gridview",
                  }),
                },
                delete: {
                  modalTitle: t("DeleteModalTitleLabel", {
                    ns: "Gridview",
                  }),
                  confirmLabel: t("DeleteModalConfirmButton", {
                    ns: "Gridview",
                  }),
                  cancelLabel: t("DeleteModalCancelButton", {
                    ns: "Gridview",
                  }),
                },
              }}
              onDeleteConfirmed={async () => {
                deleteCalendarById(info.row.data.id);
              }}
              showDeleteButton={!info.row.data.inactive}
            ></DefaultActionButtons>
          )}
        ></Column>
      </LocalGrid>

      {selectedCalendarData.length > 0 && (
        <div className="tw-gap-4 tw-grid tw-grid-cols-5 tw-mt-4">
          <div className="tw-col-span-4">
            <Calendar
              ranges={filteredCalendarDays}
              onValueChange={(
                e: Array<Date | number | string> | Date | number | string
              ) => {
                onDateSelected(e);
              }}
            />
          </div>
          <div className="tw-border tw-border-gray-300 tw-rounded-lg tw-p-4 tw-shadow-md tw-my-30 tw-h-fit tw-bg-white tw-pb-28">
            <p>{t("Filter")}</p>
            <div className="tw-grid tw-grid-cols-2">
              {calendarDayTypes.map((w) => (
                <>
                  <Switch
                    name={""}
                    checked={filteredCalendarDays.some(
                      (f) => f.rangeColorClass === w.color
                    )}
                    className={"tw-w-fit"}
                    onChange={(v) => filterCalendarValues(v, w.color)}
                    key={w.id}
                  ></Switch>
                  <p>{w.name}</p>
                </>
              ))}
            </div>
          </div>
        </div>
      )}
      <Modal
        title={t("EditDay")}
        isOpen={showDayModal}
        onClose={() => {
          setShowDayModal(false);
        }}
      >
        <Form>
          <p
            className={`tw-inline-flex tw-justify-center tw-items-center tw-rounded-md tw-border tw-border-transparent tw-px-2.5 tw-py-1.5 tw-text-sm tw-font-medium tw-text-white tw-shadow-sm ${
              selectedDayData?.rangeColorClass ?? "tw-bg-primary-600"
            }`}
          >
            {formatDateTitle(selectedDay)}
          </p>
          <Input
            name="name"
            defaultValue={selectedDayData?.name}
            control={control}
            type="text"
            LabelComponent={<FormLabel required>{t("NameLabel")}</FormLabel>}
            placeholder={t("NamePlaceholder")}
            errors={errors}
          ></Input>
          <Select
            multiple={false}
            LabelComponent={
              <FormLabel required>{t("CalendarDayTypeLabel")}</FormLabel>
            }
            name="calendarDayTypeId"
            placeholder={t("CalendarDayTypePlaceholder")}
            control={control}
            searchEnabled={false}
            displayExpr={"name"}
            valueExpr={"id"}
            items={calendarDayTypes}
            errors={errors}
            onValueChange={(v) => {
              setTipoDiaFestivoValue(v);
            }}
            value={
              //new value when user changes the select
              tipoDiaFestivoValue != ""
                ? tipoDiaFestivoValue
                : //original value saved in DB
                  calendarDayTypes.find(
                    (cd) => cd.color === selectedDayData?.rangeColorClass
                  )?.id
            }
          />
          <div className="tw-py-4 tw-justify-end tw-gap-4 tw-flex">
            <Button
              variant="secondary"
              disabled={isSubmitting}
              onClick={() => {
                setTipoDiaFestivoValue("");
                setShowDayModal(false);
              }}
            >
              {t("Cancel")}
            </Button>
            {selectedDayData && (
              <Button
                onClick={() => {
                  deleteCalendarDayById(selectedDayData.singleDayId);
                  setShowDayModal(false);
                  setTipoDiaFestivoValue("");
                  router.reload();
                }}
                disabled={isSubmitting}
                loading={isSubmitting}
                className="tw-bg-red-600 hover:tw-bg-red-700 active:tw-bg-red-800"
              >
                {t("Delete")}
              </Button>
            )}
            <Button
              onClick={onSubmit}
              disabled={isSubmitting}
              loading={isSubmitting}
            >
              {selectedDayData ? t("Edit") : t("Save")}
            </Button>
          </div>
        </Form>
      </Modal>
    </>
  );
};

export default Calendars;


### pages/company/[...slug].tsx ###
import {
  Button,
  Form,
  FormLabel,
  FormServerSideErrors,
  Input,
  Switch,
  useServerSideErrors,
} from "@fusion/ui";
import { memo } from "react";
import { GetServerSideProps } from "next";
import CompanyService, { CompanyRes } from "../../services/CompanyService";
import { zodResolver } from "@hookform/resolvers/zod";
import { useRouter } from "next/router";
import { useTranslation } from "react-i18next";
import { useForm } from "react-hook-form";
import { z } from "zod";
import AccountService from "../../services/AccountService";
import { roles } from "../../roles";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [roles.FrontSuperAdministrator];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );
  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }

  const { slug } = context.query;

  if (!slug) return { props: {} };

  if (slug?.length === 1 && slug[0] === "create")
    return {
      props: {
        mode: "create",
      },
    };

  if (slug?.length > 1 && slug[0] === "edit") {
    const companyId = slug[1];
    const { data: company, cookies } = await CompanyService.getById(
      companyId,
      context.req.cookies
    );
    // If cookies exists, set them in the response because the token was refreshed
    cookies && context.res.setHeader("Set-Cookie", cookies);

    return {
      props: {
        company,
        mode: "edit",
      },
    };
  }

  return { props: {} };
};

type CompanyCreateOrEditProps = React.FC<{
  company?: CompanyRes;
  mode: "create" | "edit";
}>;

const CompanyCreateOrEdit: CompanyCreateOrEditProps = (props) => {
  const { company, mode } = props;
  const router = useRouter();
  const { t } = useTranslation("CompanyCreateOrEditScreen");
  const {
    errors,
    setErrors,
    clearErrors: clearServerErrors,
  } = useServerSideErrors<CompanyRes>();

  const validationSchema = z.object({
    name: z
      .string({
        required_error: t("NameRequiredValidationMessage"),
      })
      .refine(
        (value) => {
          return value.trim() !== "";
        },
        { message: t("NameRequiredValidationMessage") }
      ),
    vat: z
      .string({
        required_error: t("VatRequiredValidationMessage"),
      })
      .refine(
        (value) => {
          return value.trim() !== "";
        },
        { message: t("VatRequiredValidationMessage") }
      ),
    address: z
      .string({
        required_error: t("AddressRequiredValidationMessage"),
      })
      .refine(
        (value) => {
          return value.trim() !== "";
        },
        { message: t("AddressRequiredValidationMessage") }
      ),
    telephone: z
      .string({
        required_error: t("TelephoneRequiredValidationMessage"),
      })
      .max(50, {
        message: t("MaxLengthValidationMessage", { maxLength: 100 }),
      })
      .refine(
        (value) => {
          return value.trim() !== "";
        },
        { message: t("TelephoneRequiredValidationMessage") }
      )
      .refine(
        (value) => {
          const trimmedValue = value.replace("-", " ").split(" ").join("");
          return /^[+]?\d+$/.test(trimmedValue);
        },
        { message: t("InvalidTelephone") }
      ),
    postalCode: z
      .string({
        required_error: t("PostalCodeRequiredValidationMessage"),
      })
      .refine(
        (value) => {
          return value.trim() !== "";
        },
        { message: t("PostalCodeRequiredValidationMessage") }
      ),
    city: z
      .string({
        required_error: t("CityRequiredValidationMessage"),
      })
      .refine(
        (value) => {
          return value.trim() !== "";
        },
        { message: t("CityRequiredValidationMessage") }
      ),
    country: z
      .string({
        required_error: t("CountryRequiredValidationMessage"),
      })
      .refine(
        (value) => {
          return value.trim() !== "";
        },
        { message: t("CountryRequiredValidationMessage") }
      ),
    inactive: z.boolean(),
  });

  type ValidationSchema = z.infer<typeof validationSchema>;

  const {
    control,
    handleSubmit,
    formState: { errors: clientErrors, isSubmitting },
    clearErrors: clearClientErrors,
  } = useForm<ValidationSchema>({
    defaultValues: company
      ? {
          name: company.name,
          vat: company.vat,
          address: company.address,
          telephone: company.telephone,
          postalCode: company.postalCode,
          city: company.city,
          country: company.country,
          inactive: company.inactive || false,
        }
      : {
          inactive: true,
        },
    resolver: zodResolver(validationSchema),
  });

  const onCancel = () => {
    router.back();
  };

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearServerErrors();
      try {
        const dto = {
          id: company?.id,
          name: data.name,
          vat: data.vat,
          address: data.address,
          telephone: data.telephone,
          postalCode: data.postalCode,
          city: data.city,
          country: data.country,
          inactive: data.inactive,
        };
        mode === "edit"
          ? company?.id && (await CompanyService.update(company.id, dto))
          : await CompanyService.create(dto);
        router.push("/company");
      } catch (error) {
        setErrors(error);
        console.error("An unexpected error happened:", error);
      }
    },
    (error, event) => {
      event?.preventDefault();
    }
  );

  return (
    <div className="tw-pb-4">
      <h1 className="tw-text-3xl tw-font-bold lg:tw-mt-12 tw-mb-4">
        {mode === "create" ? t("NewTitle") : t("EditTitle")}
      </h1>
      <div className="tw-bg-white tw-px-6 tw-py-3 tw-border-2 shadow tw-border-gray-200 tw-w-full lg:tw-max-w-[705px]">
        <Form>
          <Input
            name="name"
            defaultValue={company?.name}
            control={control}
            type="text"
            LabelComponent={<FormLabel required>{t("NameLabel")}</FormLabel>}
            placeholder={t("NamePlaceholder")}
            errors={errors}
          ></Input>
          <Input
            name="vat"
            defaultValue={company?.vat}
            control={control}
            type="text"
            LabelComponent={<FormLabel required>{t("VatLabel")}</FormLabel>}
            placeholder={t("VatPlaceholder")}
            errors={errors}
          ></Input>
          <Input
            name="address"
            defaultValue={company?.address}
            control={control}
            type="text"
            LabelComponent={<FormLabel required>{t("AddressLabel")}</FormLabel>}
            placeholder={t("AddressPlaceholder")}
            errors={errors}
          ></Input>
          <Input
            name="postalCode"
            defaultValue={company?.postalCode}
            control={control}
            type="text"
            LabelComponent={
              <FormLabel required>{t("PostalCodeLabel")}</FormLabel>
            }
            placeholder={t("PostalCodePlaceholder")}
            errors={errors}
          ></Input>
          <Input
            name="city"
            defaultValue={company?.city}
            control={control}
            type="text"
            LabelComponent={<FormLabel required>{t("CityLabel")}</FormLabel>}
            placeholder={t("CityPlaceholder")}
            errors={errors}
          ></Input>
          <Input
            name="country"
            defaultValue={company?.country}
            control={control}
            type="text"
            LabelComponent={<FormLabel required>{t("CountryLabel")}</FormLabel>}
            placeholder={t("CountryPlaceholder")}
            errors={errors}
          ></Input>
          <Input
            name="telephone"
            defaultValue={company?.telephone}
            control={control}
            type="text"
            LabelComponent={
              <FormLabel required>{t("TelephoneLabel")}</FormLabel>
            }
            placeholder={t("TelephonePlaceholder")}
            errors={errors}
          ></Input>
          <Switch
            name="inactive"
            control={control}
            defaultChecked={company?.inactive}
            LabelComponent={<FormLabel>{t("InactiveLabel")}</FormLabel>}
            errors={errors}
          ></Switch>

          {/* Show general errors that are not related to any specific field */}
          <div className="errors">
            {errors && Object.keys(errors).length > 0 ? (
              <FormServerSideErrors
                errors={errors}
                fieldKey={""}
              ></FormServerSideErrors>
            ) : null}
          </div>

          <div className="tw-py-4">
            <div className="tw-flex tw-justify-end tw-gap-2">
              <Button
                variant="secondary"
                disabled={isSubmitting}
                onClick={() => {
                  onCancel();
                }}
              >
                {t("Cancel")}
              </Button>
              <Button
                onClick={onSubmit}
                disabled={isSubmitting}
                loading={isSubmitting}
              >
                {t("Save")}
              </Button>
            </div>
          </div>
        </Form>
      </div>
    </div>
  );
};

export default memo(CompanyCreateOrEdit);


### pages/company/details/[id].tsx ###
import { Button, FormLabel, Input, PageHeader, Switch } from "@fusion/ui";
import { GetServerSideProps } from "next";
import { useRouter } from "next/router";
import { useTranslation } from "react-i18next";
import CompanyService, { CompanyRes } from "../../../services/CompanyService";
import AccountService from "../../../services/AccountService";
import { roles } from "../../../roles";

type Params = {
  id: string;
};

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [roles.FrontSuperAdministrator];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );
  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }

  const { id } = context.params as Params;

  if (!id) return { props: {} };

  const { data: company, cookies } = await CompanyService.getById(
    id,
    context.req.cookies
  );
  // If cookies exists, set them in the response because the token was refreshed
  cookies && context.res.setHeader("Set-Cookie", cookies);

  return {
    props: {
      company,
    },
  };
};

type CompanyDetailsProps = React.FC<{
  company?: CompanyRes;
}>;

const CompanyDetails: CompanyDetailsProps = (props) => {
  const { company } = props;
  const router = useRouter();

  const { t } = useTranslation("CompanyDetailsScreen");

  if (!company) return null;

  return (
    <div className="tw-flex tw-flex-col tw-gap-4">
      <PageHeader title={company.name}></PageHeader>
      <Input
        name="vat"
        disabled
        value={`${company.vat}`}
        LabelComponent={<FormLabel>{t("VatLabel")}</FormLabel>}
      ></Input>
      <Input
        name="address"
        disabled
        value={`${company.address}`}
        LabelComponent={<FormLabel>{t("AddressLabel")}</FormLabel>}
      ></Input>
      <Input
        name="postalCode"
        disabled
        value={`${company.postalCode}`}
        LabelComponent={<FormLabel>{t("PostalCodeLabel")}</FormLabel>}
      ></Input>
      <Input
        name="city"
        disabled
        value={`${company.city}`}
        LabelComponent={<FormLabel>{t("CityLabel")}</FormLabel>}
      ></Input>
      <Input
        name="country"
        disabled
        value={`${company.country}`}
        LabelComponent={<FormLabel>{t("CountryLabel")}</FormLabel>}
      ></Input>
      <Input
        name="telephone"
        disabled
        value={`${company.telephone}`}
        LabelComponent={<FormLabel>{t("TelephoneLabel")}</FormLabel>}
      ></Input>
      <Switch
        name="inactive"
        disabled
        checked={company?.inactive}
        LabelComponent={<FormLabel>{t("InactiveLabel")}</FormLabel>}
      ></Switch>
      <div className="tw-py-4">
        <div className="tw-flex tw-justify-end tw-gap-2">
          <Button variant="secondary" onClick={() => router.back()}>
            {t("Cancel")}
          </Button>
        </div>
      </div>
    </div>
  );
};

export default CompanyDetails;


### pages/company/index.tsx ###
import { Button, Checkbox, Column, DataGrid, PageHeader } from "@fusion/ui";
import { DefaultActionButtons } from "../../components/DefaultActionButtons";
import CompanyService, { CompanyPage } from "../../services/CompanyService";
import AccountService from "../../services/AccountService";
import { booleanHeaderFilter, DataGridColumnInformation } from "@fusion/utils";
import { PlusIcon } from "@heroicons/react/20/solid";
import Link from "next/link";
import { useRouter } from "next/router";
import { useTranslation } from "react-i18next";
import { roles } from "../../roles";
import { GetServerSideProps } from "next";
import useNetworkErrorHandler from "../../hooks/useNetworkErrorHandler";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [roles.FrontSuperAdministrator];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );

  const company = await CompanyService.getAll({
    page: 1,
    pageSize: 1,
    cookies: context.req.cookies,
    format: "default",
  });

  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }
  return { props: { company } };
};

type CompanyProps = {
  company: CompanyPage;
};

const Companies = (props: CompanyProps) => {
  const router = useRouter();
  const { t } = useTranslation("CompanyListScreen");
  const { handleError } = useNetworkErrorHandler();
  const getCompanyUrl = `/api/company/list?format=dx`;
  const { company } = props;
  const deleteCompanyById = async (id: string) => {
    try {
      await CompanyService.delete(id);
      router.push("/company");
    } catch (error) {
      handleError(error);
    }
  };

  const canCreateCompany = (item: CompanyPage) => {
    return item.links.some((a: { rel: string }) => a.rel === "Create");
  };

  return (
    <>
      {/* Header */}
      <PageHeader title={t("Title")}>
        {canCreateCompany(company) ? (
          <Button
            onClick={() => router.push("/company/create")}
            iconLeft={<PlusIcon className="tw-h-3 tw-w-3"></PlusIcon>}
          >
            {t("Create")}
          </Button>
        ) : undefined}
      </PageHeader>

      {/* Grid */}
      {/* Column definitions */}
      <DataGrid
        url={getCompanyUrl}
        enableRowAlternation={false}
        locale={{
          nameColumn: {
            caption: t("NameColumnLabel", {
              ns: "Gridview",
            }),
          },
        }}
      >
        <Column
          name={"vat"}
          dataField={"vat"}
          caption={t("VatColumnLabel")}
          dataType="string"
        ></Column>
        <Column
          name={"address"}
          dataField={"address"}
          caption={t("AddressColumnLabel")}
          dataType="string"
        ></Column>
        <Column
          name={"postalCode"}
          dataField={"postalCode"}
          caption={t("PostalCodeColumnLabel")}
          dataType="string"
        />
        <Column
          name={"city"}
          dataField={"city"}
          caption={t("CityColumnLabel")}
          dataType="string"
        />
        <Column
          name={"country"}
          dataField={"country"}
          caption={t("CountryColumnLabel")}
          dataType="string"
        />
        <Column
          name={"telephone"}
          dataField={"telephone"}
          caption={t("TelephoneColumnLabel")}
          dataType="string"
        />
        <Column
          name={"inactive"}
          dataField={"inactive"}
          caption={t("InactiveColumnLabel")}
          headerFilter={booleanHeaderFilter}
          cellRender={(info) => (
            <Checkbox name="inactive" disabled checked={info.value}></Checkbox>
          )}
          dataType="boolean"
        />
        <Column
          allowFiltering={false}
          allowReordering={false}
          dataField={"Action Buttons"}
          caption={""}
          cellRender={(info: DataGridColumnInformation<null>) => (
            <DefaultActionButtons
              LinkComponent={Link}
              info={info}
              entityName="company"
              locale={{
                tooltips: {
                  edit: t("EditActionButtonLabel", {
                    ns: "Gridview",
                  }),
                  details: t("DetailsActionButtonLabel", {
                    ns: "Gridview",
                  }),
                  delete: t("DeleteActionButtonLabel", {
                    ns: "Gridview",
                  }),
                },
                delete: {
                  modalTitle: t("DeleteModalTitleLabel", {
                    ns: "Gridview",
                  }),
                  confirmLabel: t("DeleteModalConfirmButton", {
                    ns: "Gridview",
                  }),
                  cancelLabel: t("DeleteModalCancelButton", {
                    ns: "Gridview",
                  }),
                },
              }}
              onDeleteConfirmed={async () => {
                deleteCompanyById(info.row.data.id);
              }}
              showDeleteButton={!info.row.data.inactive}
            ></DefaultActionButtons>
          )}
        ></Column>
      </DataGrid>
      {/* End Column definitions */}
    </>
  );
};

export default Companies;


### pages/create-password.tsx ###
import {
  Button,
  Form,
  FormLabel,
  FormServerSideErrors,
  Input,
  useServerSideErrors,
} from "@fusion/ui";
import { LockClosedIcon } from "@heroicons/react/20/solid";
import { zodResolver } from "@hookform/resolvers/zod";
import { GetServerSideProps, NextPage } from "next";
import Image from "next/image";
import { useRouter } from "next/router";
import { ParsedUrlQuery } from "querystring";
import { useForm } from "react-hook-form";
import { useTranslation } from "react-i18next";
import { z } from "zod";
import BrandBackground from "../components/BrandBackground";
import Logo from "../public/logo.png";
import { routes } from "../routes";
import AccountService, { CreatePasswordReq } from "../services/AccountService";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const { query } = context as { query: ParsedUrlQuery };

  return {
    props: {
      userId: query.userId,
      code: query.code,
    },
  };
};

type CreatePasswordProps = {
  userId: string;
  code: string;
};

const CreatePassword: NextPage<CreatePasswordProps> = ({ userId, code }) => {
  const router = useRouter();
  const { t } = useTranslation("CreatePasswordScreen");

  const createPasswordSchema = z
    .object({
      password: z.string().min(1, { message: t("PasswordValidationMessage") }),
      confirmPassword: z
        .string()
        .min(1, { message: t("ConfirmPasswordValidationMessage") }),
    })
    .refine((data) => data.password === data.confirmPassword, {
      message: t("PasswordsDontMatchValidationMessage"),
      path: ["confirmPassword"],
    });

  type ValidationSchema = z.infer<typeof createPasswordSchema>;

  const { errors, setErrors, clearErrors } =
    useServerSideErrors<ValidationSchema>();

  const {
    control,
    handleSubmit,
    formState: { isSubmitting },
  } = useForm<ValidationSchema>({
    defaultValues: {
      password: "",
      confirmPassword: "",
    },
    resolver: zodResolver(createPasswordSchema),
  });

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearErrors();
      try {
        const dto: CreatePasswordReq = {
          userId,
          code,
          newPassword: data.password,
          confirmPassword: data.confirmPassword,
        };
        const result = await AccountService.createPassword(dto);
        const login = {
          email: result.email,
          password: data.password,
        };
        await AccountService.login(login);
        router.push(routes.HOME);
      } catch (error) {
        setErrors(error);
      }
    },
    (error, event) => {
      event?.preventDefault();
    }
  );

  return (
    <>
      <div className="tw-flex tw-min-h-full">
        <BrandBackground />
        <div className="tw-flex tw-flex-1 tw-min-w-[50%] tw-flex-col tw-justify-center tw-py-12 tw-px-4 sm:tw-px-6 lg:tw-flex-none lg:tw-px-20 xl:tw-px-24">
          <div className="tw-mx-auto tw-w-full tw-max-w-sm lg:tw-w-96">
            <div className="tw-flex tw-flex-col tw-justify-center">
              <Image
                className="tw-h-12 tw-w-auto tw-object-contain"
                src={Logo}
                alt="Your Company"
              />
            </div>
            <h2 className="tw-mt-6 tw-text-3xl tw-font-bold tw-tracking-tight tw-text-gray-900">
              {t("CreatePasswordTitle")}
            </h2>
            <h4 className="tw-mt-2 tw-text-sm tw-tracking-tight tw-text-gray-500 ">
              {t("CreatePasswordMessage")}
            </h4>
            <div className="tw-mt-8">
              <div className="tw-mt-6 tw-space-y-6">
                <Form>
                  <Input
                    name="password"
                    control={control}
                    type="password"
                    iconLeft={
                      <LockClosedIcon width={20} height={20}></LockClosedIcon>
                    }
                    LabelComponent={
                      <FormLabel required>{t("PasswordLabel")}</FormLabel>
                    }
                    placeholder={t("PasswordPlaceholder")}
                    errors={errors}
                  />
                  <Input
                    name="confirmPassword"
                    control={control}
                    type="password"
                    iconLeft={
                      <LockClosedIcon width={20} height={20}></LockClosedIcon>
                    }
                    LabelComponent={
                      <FormLabel required>
                        {t("ConfirmPasswordLabel")}
                      </FormLabel>
                    }
                    placeholder={t("ConfirmPasswordPlaceholder")}
                    errors={errors}
                  />
                  {/* Show general errors that are not related to any specific field */}
                  <div className="errors">
                    <FormServerSideErrors errors={errors} fieldKey={""} />
                  </div>

                  <div className="tw-flex tw-justify-end">
                    <Button
                      onClick={onSubmit}
                      disabled={isSubmitting}
                      loading={isSubmitting}
                    >
                      {t("Save")}
                    </Button>
                  </div>
                </Form>
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default CreatePassword;


### pages/event/[...slug].tsx ###
import {
  Button,
  Column,
  DatePicker,
  Form,
  FormLabel,
  FormServerSideErrors,
  Select,
  TextArea,
  useServerSideErrors,
} from "@fusion/ui";
import { memo, useEffect, useRef, useState } from "react";
import { GetServerSideProps } from "next";
import EventService, { EventRes } from "../../services/EventService";
import { zodResolver } from "@hookform/resolvers/zod";
import { useRouter } from "next/router";
import { useTranslation } from "react-i18next";
import { useForm } from "react-hook-form";
import { z } from "zod";
import AccountService from "../../services/AccountService";
import { roles } from "../../roles";
import useNetworkErrorHandler from "../../hooks/useNetworkErrorHandler";
import EventTypeService from "../../services/EventTypeService";
import { TimeInput } from "../../components/TimeInput";
import { DateHelper } from "../../helpers/DateHelper";
import { DataGridLocal } from "../../components/DataGridLocal";
import { useUserStore } from "../../stores/UserStore";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [roles.FrontFrontHumanCapital, roles.FrontSystemUser];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );
  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }

  const { slug } = context.query;

  if (!slug) return { props: {} };

  if (slug?.length === 1 && slug[0] === "create")
    return {
      props: {
        mode: "create",
      },
    };

  if (slug?.length > 1 && slug[0] === "edit") {
    const eventId = slug[1];
    const { data: event, cookies } = await EventService.getById(
      eventId,
      context.req.cookies
    );
    // If cookies exists, set them in the response because the token was refreshed
    cookies && context.res.setHeader("Set-Cookie", cookies);

    return {
      props: {
        event,
        mode: "edit",
      },
    };
  }

  return { props: {} };
};

type EventCreateOrEditProps = React.FC<{
  event?: EventRes;
  mode: "create" | "edit";
}>;

type EventOption = {
  name: string;
  value: string;
};

export enum EventStatusEnum {
  Accepted,
  Rejected,
  Pending,
}

const EventCreateOrEdit: EventCreateOrEditProps = (props) => {
  const { event, mode } = props;
  const { handleError } = useNetworkErrorHandler();
  const router = useRouter();
  const culture = useUserStore.getState().preferredLanguage || "es";
  const getEventUrl = `/api/eventHistory/by-event?id=${event?.id}&culture=${culture}`;
  const firstMount = useRef<boolean>(true);
  const [eventTypes, setEventTypes] = useState<EventOption[]>();
  const { t } = useTranslation("EventCreateOrEditScreen");
  const {
    errors,
    setErrors,
    clearErrors: clearServerErrors,
  } = useServerSideErrors<EventRes>();
  const status = useRef<EventStatusEnum>(EventStatusEnum.Pending);

  const store = useUserStore();
  const isHumanCapitalRole =
    store.roles && store.roles.includes(roles.FrontFrontHumanCapital);

  const validationSchema = z.object({
    eventTypeId: z.string({
      required_error: t("EventTypeRequiredValidationMessage"),
    }),
    dateStart:
      mode == "create"
        ? z.date({
            required_error: t("DateStartRequiredValidationMessage"),
          })
        : z.string().optional(),
    hourStart: z.string().optional(),
    dateEnd: z
      .date({
        required_error: t("DateEndRequiredValidationMessage"),
      })
      .optional(),
    hourEnd: z.string().optional(),
    comments: z.string().optional(),
  });

  type ValidationSchema = z.infer<typeof validationSchema>;

  const {
    control,
    handleSubmit,
    formState: { errors: clientErrors, isSubmitting },
    clearErrors: clearClientErrors,
  } = useForm<ValidationSchema>({
    defaultValues: event
      ? {
          eventTypeId: event.eventTypeId,
          dateStart: event.dateStart,
          hourStart:
            event.dateStart instanceof Date
              ? DateHelper.formatTime(event.dateStart)
              : DateHelper.formatTime(new Date(event.dateStart)),
          dateEnd:
            event.dateEnd instanceof Date
              ? event.dateEnd
              : event.dateEnd
              ? new Date(event.dateEnd)
              : new Date(),
          hourEnd:
            event.dateEnd instanceof Date
              ? DateHelper.formatTime(event.dateEnd)
              : event.dateEnd
              ? DateHelper.formatTime(new Date(event.dateEnd))
              : undefined,
          comments: "",
        }
      : {},
    resolver: zodResolver(validationSchema),
  });

  const getEventTypes = async () => {
    try {
      const result = await EventTypeService.getAll();
      const eventTypes = result.map((c) => ({
        value: c.value,
        name: c.text,
      }));
      setEventTypes(eventTypes);
    } catch (error) {
      handleError(error);
    }
  };

  useEffect(() => {
    if (firstMount.current) {
      firstMount.current = false;
      getEventTypes();
    }
  }, []);

  const onCancel = () => {
    router.back();
  };

  const onSubmitWithStatus = (buttonStatus: EventStatusEnum) => {
    status.current = buttonStatus;
    onSubmit();
  };

  const onSubmit = handleSubmit(
    async (data, ev) => {
      ev?.preventDefault();
      clearServerErrors();
      try {
        const dto = {
          id: event?.id,
          eventTypeId: data.eventTypeId,
          dateStart:
            data && data.hourStart && data.dateStart instanceof Date
              ? DateHelper.setDateTime(data.dateStart, data.hourStart)
              : data && data.dateStart != undefined && data.hourStart
              ? DateHelper.setDateTime(new Date(data.dateStart), data.hourStart)
              : data && data.dateStart != undefined
              ? new Date(data.dateStart)
              : "",
          dateEnd:
            data && data.hourEnd && data.dateEnd instanceof Date
              ? DateHelper.setDateTime(data.dateEnd, data.hourEnd)
              : data && data.dateEnd != undefined && data.hourEnd
              ? DateHelper.setDateTime(new Date(data.dateEnd), data.hourEnd)
              : data && data.dateEnd != undefined
              ? new Date(data.dateEnd)
              : "",
          comments: data.comments ?? "",
          eventStatusEnum: status.current,
        };
        //Avoid errors from passing the Date type from frontend to backend
        dto.dateStart = DateHelper.toLocalISOString(new Date(dto.dateStart));
        dto.dateEnd = DateHelper.toLocalISOString(new Date(dto.dateEnd));

        mode === "edit"
          ? event?.id && (await EventService.update(dto))
          : await EventService.create(dto);
        router.push("/event");
      } catch (error) {
        handleError(error);
      }
    },
    (error, ev) => {
      ev?.preventDefault();
      handleError(error);
    }
  );

  return (
    <div className="tw-pb-4">
      <h1 className="tw-text-3xl tw-font-bold lg:tw-mt-12 tw-mb-4">
        {mode === "create" ? t("NewTitle") : t("EditTitle")}
      </h1>
      <div className="tw-bg-white tw-px-6 tw-py-3 tw-border-2 shadow tw-border-gray-200 tw-w-fit">
        <Form>
          {event?.name && (
              <>
                <FormLabel className={"tw-font-bold"} >{t("Employee")}</FormLabel>
                <FormLabel>{event?.name}</FormLabel>
              </>
          )}

          <Select
            multiple={false}
            LabelComponent={<FormLabel>{t("EventTypeLabel")}</FormLabel>}
            name="eventTypeId"
            placeholder={t("EventTypePlaceholder")}
            control={control}
            searchEnabled={false}
            displayExpr={"name"}
            valueExpr={"value"}
            items={eventTypes}
            errors={errors}
            defaultValue={event?.eventTypeId}
          />
          <div className="tw-flex tw-gap-14">
            <DatePicker
              type="date"
              control={control}
              defaultValue={event?.dateStart}
              placeholder={t("DateStartPlaceholder")}
              LabelComponent={
                <FormLabel required={false}>{t("DateStartLabel")}</FormLabel>
              }
              name="dateStart"
              useMaskBehavior={true}
              errors={errors}
              disabled={false}
            ></DatePicker>
            <TimeInput
              name={"hourStart"}
              defaultValue={
                event?.dateStart instanceof Date
                  ? DateHelper.formatTime(event.dateStart)
                  : event
                  ? DateHelper.formatTime(new Date(event.dateStart))
                  : undefined
              }
              LabelComponent={
                <FormLabel required={false}>{t("HourStartLabel")}</FormLabel>
              }
              control={control}
              errors={errors}
              containerClasses="tw-w-full"
              className="tw-mt-1"
            ></TimeInput>
          </div>
          <div className="tw-flex tw-gap-14">
            <DatePicker
              type="date"
              control={control}
              defaultValue={event?.dateEnd}
              placeholder={t("DateEndPlaceholder")}
              LabelComponent={
                <FormLabel required={false}>{t("DateEndLabel")}</FormLabel>
              }
              name="dateEnd"
              useMaskBehavior={true}
              errors={errors}
              disabled={false}
            ></DatePicker>
            <TimeInput
              name={"hourEnd"}
              // defaultValue={event ? formatTime(event.dateEnd) : "00:00"}
              defaultValue={
                event?.dateEnd instanceof Date
                  ? DateHelper.formatTime(event.dateEnd)
                  : event && event.dateEnd
                  ? DateHelper.formatTime(new Date(event.dateEnd))
                  : undefined
              }
              LabelComponent={
                <FormLabel required={false}>{t("HourEndLabel")}</FormLabel>
              }
              control={control}
              errors={errors}
              containerClasses="tw-w-full"
              className="tw-mt-1"
            ></TimeInput>
          </div>
          {mode == "edit" && (
            <>
              <FormLabel>{t("HistoryLabel")}</FormLabel>
              <DataGridLocal url={getEventUrl} enableRowAlternation={false}>
                <Column
                  name={"date"}
                  dataField={"date"}
                  caption={t("DateFromColumnLabel")}
                  dataType="date"
                />
                <Column
                  name={"editorName"}
                  dataField={"editorName"}
                  caption={t("UserNameColumnLabel")}
                  dataType="string"
                />
                <Column
                  name={"status"}
                  dataField={"status"}
                  caption={t("StatusColumnLabel")}
                  dataType="string"
                />
                <Column
                  name={"comments"}
                  dataField={"comments"}
                  caption={t("CommentsColumnLabel")}
                  dataType="string"
                />
              </DataGridLocal>
            </>
          )}
          <TextArea
            control={control}
            errors={errors}
            name="comments"
            rows={5}
            LabelComponent={<FormLabel>{t("CommentsLabel")}</FormLabel>}

          />

          {/* Show general errors that are not related to any specific field */}
          <div className="errors">
            {errors && Object.keys(errors).length > 0 ? (
              <FormServerSideErrors
                errors={errors}
                fieldKey={""}
              ></FormServerSideErrors>
            ) : null}
          </div>

          <div className="tw-py-4">
            <div className="tw-flex tw-justify-end tw-gap-2">
              {isHumanCapitalRole && mode === "edit" && (
                <>
                  <Button
                    accentColor="red"
                    disabled={isSubmitting}
                    onClick={() => onSubmitWithStatus(EventStatusEnum.Rejected)}
                    name="reject"
                  >
                    {t("Reject")}
                  </Button>
                  <Button
                    accentColor="blue"
                    onClick={() => onSubmitWithStatus(EventStatusEnum.Accepted)}
                    disabled={isSubmitting}
                    loading={isSubmitting}
                    name="approve"
                  >
                    {t("Approve")}
                  </Button>
                </>
              )}
              <Button
                variant="secondary"
                disabled={isSubmitting}
                onClick={() => {
                  onCancel();
                }}
              >
                {t("Cancel")}
              </Button>
              <Button
                onClick={onSubmit}
                disabled={isSubmitting}
                loading={isSubmitting}
              >
                {t("Save")}
              </Button>
            </div>
          </div>
        </Form>
      </div>
    </div>
  );
};

export default memo(EventCreateOrEdit);


### pages/event/index.tsx ###
import { Button, Column, PageHeader, Switch } from "@fusion/ui";
import { DefaultActionButtons } from "../../components/DefaultActionButtons";
import EventService, { EventPage, EventRes } from "../../services/EventService";
import AccountService from "../../services/AccountService";
import { DataGridColumnInformation } from "@fusion/utils";
import { PlusIcon } from "@heroicons/react/20/solid";
import Link from "next/link";
import { useRouter } from "next/router";
import { useTranslation } from "react-i18next";
import { roles } from "../../roles";
import { GetServerSideProps } from "next";
import useNetworkErrorHandler from "../../hooks/useNetworkErrorHandler";
import { DataGridLocal } from "../../components/DataGridLocal";
import Calendar, { MultipleRangeValues } from "../../components/Calendar";
import { calendarDayTypes } from "../../constants/CalendarDayTypes";
import { SetStateAction, useEffect, useState } from "react";
import CalendarDayService, {
  CalendarDayRes,
} from "../../services/CalendarDayService";
import { useUserStore } from "../../stores/UserStore";
import { EmployeeDateFilter } from "../../components/EmployeeDateFilter";
import {Paging} from "devextreme-react/data-grid";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [roles.FrontFrontHumanCapital, roles.FrontSystemUser];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );

  const event = await EventService.getAll({
    page: 1,
    pageSize: 1,
    cookies: context.req.cookies,
    format: "default",
  });

  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }
  return { props: { event } };
};

type EventProps = {
  event: EventPage;
};

const Events = (props: EventProps) => {
  const router = useRouter();
  const { t } = useTranslation("EventListScreen");
  const { handleError } = useNetworkErrorHandler();
  const [getEventUrl, setAbsencesUrl] = useState<string>();
  const { event } = props;
  const [filteredCalendarDays, setFilteredCalendarDays] = useState<
    MultipleRangeValues[]
  >([]);
  const [selectedCalendarData, setSelectedCalendarData] = useState<
    MultipleRangeValues[]
  >([]);
  const store = useUserStore();

  const absentType = [
    {
      id: "7c3c5a61-f312-41c5-8c5f-8ecd323fb304",
      name: t("Absences"),
      companyId: null,
      color: "tw-bg-orange-500",
    },
  ];

  const filterTypes = [...calendarDayTypes, ...absentType];

  const filterCalendarValues = (isActive: boolean, filterColor: string) => {
    const filteredRanges = selectedCalendarData.filter(
      (c) => c.rangeColorClass === filterColor
    );

    const updatedFilteredAssignedWorkingHours = isActive
      ? [...filteredCalendarDays, ...filteredRanges]
      : filteredCalendarDays.filter((c) => c.rangeColorClass !== filterColor);

    setFilteredCalendarDays(updatedFilteredAssignedWorkingHours);
  };

  const deleteEventById = async (id: string) => {
    try {
      await EventService.delete(id);
      router.push("/event");
    } catch (error) {
      handleError(error);
    }
  };

  const canCreateEvent = (item: EventPage) => {
    return item.links.some((a: { rel: string }) => a.rel === "Create");
  };

  const getEvents = async () => {
    const events = await EventService.getAll({
      page: 1,
      pageSize: 120,
    });
    return events;
  };

  const getCalendarDays = async () => {
    const calendarDays = await CalendarDayService.getAll({
      page: 1,
      pageSize: 120,
    });

    const calendarValues: MultipleRangeValues[] = calendarDays.items.map(
      (c: CalendarDayRes, index: number) => ({
        id: c.calendarId ?? "",
        singleDayId: c.id ?? "",
        name: c.name ?? "",
        startDate: new Date(c.date),
        endDate: new Date(c.date),
        rangeColorClass:
          calendarDayTypes.find((cd) => cd.id === c.calendarDayTypeId)?.color ??
          "",
        shownDays: [0, 1, 2, 3, 4, 5, 6],
      })
    );

    if (calendarValues.length === 0) {
      calendarValues.push({
        id: "",
        name: " ",
        singleDayId: "",
        startDate: new Date(),
        endDate: new Date(),
        rangeColorClass: "tw-bg-red-500",
        shownDays: [],
      });
    }

    const events: EventPage = await getEvents();

    const eventValues: MultipleRangeValues[] = events.items.map(
      (c: EventRes, index: number) => ({
        id: "",
        singleDayId: c.id ?? "",
        name: c.eventTypeName ?? "",
        startDate: new Date(c.dateStart),
        endDate: c.dateEnd ? new Date(c.dateEnd) : new Date(),
        rangeColorClass: "tw-bg-orange-500",
        shownDays: [0, 1, 2, 3, 4, 5, 6],
      })
    );

    const allValues: MultipleRangeValues[] = [
      ...calendarValues,
      ...eventValues,
    ];

    setSelectedCalendarData(allValues);
    setFilteredCalendarDays(allValues);
  };

  const isHumanCapital =
    store.roles && store.roles.includes(roles.FrontFrontHumanCapital);

  useEffect(() => {
    getCalendarDays();
    const culture = useUserStore.getState().preferredLanguage || "es";
    if (!isHumanCapital) {
      setAbsencesUrl(
        `/api/event/get-user-event?userId=${store.id}&culture=${culture}`
      );
    }
  }, []);

  return (
    <>
      {/* Header */}
      <PageHeader title={t("Title")}>
        {canCreateEvent(event) ? (
          <Button
            onClick={() => router.push("/event/create")}
            iconLeft={<PlusIcon className="tw-h-3 tw-w-3"></PlusIcon>}
          >
            {t("Create")}
          </Button>
        ) : undefined}
      </PageHeader>
      {isHumanCapital && (
        <EmployeeDateFilter
          setAbsencesUrl={setAbsencesUrl}
        ></EmployeeDateFilter>
      )}
      {/* Grid */}
      {/* Column definitions */}
      <DataGridLocal url={getEventUrl} enableRowAlternation={false} paginate={true}>
        <Column
                name={"name"}
                dataField={"name"}
                caption={t("nameColumnLabel")}
                dataType="string"
                visible={isHumanCapital}
        />

        <Column
          name={"eventTypeName"}
          dataField={"eventTypeName"}
          caption={t("eventTypeColumnLabel")}
          dataType="string"
        />
        <Column
            name={"dateCreated"}
            dataField={"dateCreated"}
            caption={t("createdDateFromColumnLabel")}
            dataType="date"
        />
        <Column
          name={"status"}
          dataField={"status"}
          caption={t("stateColumnLabel")}
          dataType="string"
        />
        <Column
          name={"dateStart"}
          dataField={"dateStart"}
          caption={t("dateFromColumnLabel")}
          dataType="date"
        />
        <Column
          name={"dateEnd"}
          dataField={"dateEnd"}
          caption={t("dateToColumnLabel")}
          dataType="date"
        />
        <Column
          name={"comments"}
          dataField={"comments"}
          caption={t("commentsColumnLabel")}
          dataType="string"
        />
        <Column
          allowFiltering={false}
          allowReordering={false}
          dataField={"Action Buttons"}
          caption={""}
          cellRender={(info: DataGridColumnInformation<null>) => (
            <DefaultActionButtons
              LinkComponent={Link}
              info={info}
              showDetailsButton={false}
              entityName="event"
              locale={{
                tooltips: {
                  edit: t("EditActionButtonLabel", {
                    ns: "Gridview",
                  }),
                  delete: t("DeleteActionButtonLabel", {
                    ns: "Gridview",
                  }),
                },
              }}
              onDeleteConfirmed={async () => {
                deleteEventById(info.row.data.id);
              }}
              showDeleteButton={false}
            ></DefaultActionButtons>
          )}
        ></Column>
      </DataGridLocal>
      {!isHumanCapital && (
        <div className="tw-gap-4 tw-grid tw-grid-cols-5 tw-mt-4">
          <div className="tw-col-span-4">
            <Calendar ranges={filteredCalendarDays} onValueChange={() => {}} />
          </div>
          <div className="tw-border tw-border-gray-300 tw-rounded-lg tw-p-4 tw-shadow-md tw-my-30 tw-h-fit tw-bg-white tw-pb-28">
            <p>{t("Filter")}</p>
            <div className="tw-grid tw-grid-cols-2">
              {filterTypes.map((w) => (
                <>
                  <Switch
                    name={""}
                    checked={filteredCalendarDays.some(
                      (f) => f.rangeColorClass === w.color
                    )}
                    className={"tw-w-fit"}
                    onChange={(v) => filterCalendarValues(v, w.color)}
                    key={w.id}
                  ></Switch>
                  <p>{w.name}</p>
                </>
              ))}
            </div>
          </div>
        </div>
      )}
    </>
  );
};

export default Events;


### pages/force-change-password.tsx ###
import {
  Button,
  Form,
  FormLabel,
  FormServerSideErrors,
  Input,
  useServerSideErrors,
} from "@fusion/ui";
import { LockClosedIcon } from "@heroicons/react/20/solid";
import { zodResolver } from "@hookform/resolvers/zod";
import { GetServerSideProps, NextPage } from "next";
import Image from "next/image";
import { useRouter } from "next/router";
import { ParsedUrlQuery } from "querystring";
import { useForm } from "react-hook-form";
import { useTranslation } from "react-i18next";
import { z } from "zod";
import BrandBackground from "../components/BrandBackground";
import Logo from "../public/logo.png";
import { routes } from "../routes";
import AccountService from "../services/AccountService";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const { query } = context as { query: ParsedUrlQuery };

  return {
    props: {
      email: query.email,
    },
  };
};

type ForceChangePasswordProps = {
  email: string;
};

const ForceChangePassword: NextPage<ForceChangePasswordProps> = ({ email }) => {
  const router = useRouter();
  const { t } = useTranslation("ForceChangePasswordScreen");

  const resetPasswordSchema = z
    .object({
      email: z.string().email(t("EmailValidationMessage")),
      oldPassword: z
        .string()
        .min(1, { message: t("OldPasswordValidationMessage") }),
      newPassword: z
        .string()
        .min(1, { message: t("NewPasswordValidationMessage") }),
      confirmPassword: z
        .string()
        .min(1, { message: t("ConfirmPasswordValidationMessage") }),
    })
    .refine((data) => data.newPassword === data.confirmPassword, {
      message: t("PasswordsDontMatchValidationMessage"),
      path: ["confirmPassword"],
    });

  type ValidationSchema = z.infer<typeof resetPasswordSchema>;

  const { errors, setErrors, clearErrors } =
    useServerSideErrors<ValidationSchema>();

  const {
    control,
    handleSubmit,
    formState: { isSubmitting },
  } = useForm<ValidationSchema>({
    defaultValues: {
      email: email,
      oldPassword: "",
      newPassword: "",
      confirmPassword: "",
    },
    resolver: zodResolver(resetPasswordSchema),
  });

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearErrors();
      try {
        await AccountService.forceChangePassword(data);
        router.push(routes.RESET_PASSWORD_CONFIRMATION);
      } catch (error) {
        setErrors(error);
      }
    },
    (error, event) => {
      event?.preventDefault();
    }
  );

  return (
    <>
      <div className="tw-flex tw-min-h-full">
        <BrandBackground />
        <div className="tw-flex tw-flex-1 tw-min-w-[50%] tw-flex-col tw-justify-center tw-py-12 tw-px-4 sm:tw-px-6 lg:tw-flex-none lg:tw-px-20 xl:tw-px-24">
          <div className="tw-mx-auto tw-w-full tw-max-w-sm lg:tw-w-96">
            <div className="tw-flex tw-flex-col tw-justify-center">
              <Image
                className="tw-h-12 tw-w-auto tw-object-contain"
                src={Logo}
                alt="Your Company"
              />
            </div>
            <h2 className="tw-mt-6 tw-text-3xl tw-font-bold tw-tracking-tight tw-text-gray-900">
              {t("PasswordExpiredTitle")}
            </h2>
            <h4 className="tw-mt-2 tw-text-sm tw-tracking-tight tw-text-gray-500 ">
              {t("PasswordExpiredMessage")}
            </h4>
            <div className="tw-mt-8">
              <div className="tw-mt-6 tw-space-y-6">
                <Form>
                  <Input
                    id="email"
                    name="email"
                    control={control}
                    disabled
                    defaultValue={email}
                    type="email"
                    LabelComponent={<FormLabel>{t("EmailLabel")}</FormLabel>}
                    errors={errors}
                  />
                  <Input
                    name="oldPassword"
                    control={control}
                    type="password"
                    iconLeft={<LockClosedIcon width={20} height={20} />}
                    LabelComponent={
                      <FormLabel required>{t("OldPasswordLabel")}</FormLabel>
                    }
                    placeholder={t("OldPasswordPlaceholder")}
                    errors={errors}
                  />
                  <Input
                    name="newPassword"
                    control={control}
                    type="password"
                    iconLeft={<LockClosedIcon width={20} height={20} />}
                    LabelComponent={
                      <FormLabel required>{t("NewPasswordLabel")}</FormLabel>
                    }
                    placeholder={t("NewPasswordPlaceholder")}
                    errors={errors}
                  />
                  <Input
                    name="confirmPassword"
                    control={control}
                    type="password"
                    iconLeft={<LockClosedIcon width={20} height={20} />}
                    LabelComponent={
                      <FormLabel required>
                        {t("ConfirmPasswordLabel")}
                      </FormLabel>
                    }
                    placeholder={t("ConfirmPasswordPlaceholder")}
                    errors={errors}
                  />

                  {/* Show general errors that are not related to any specific field */}
                  <div className="errors">
                    <FormServerSideErrors errors={errors} fieldKey={""} />
                  </div>

                  <div className="tw-flex tw-justify-end">
                    <Button
                      onClick={onSubmit}
                      disabled={isSubmitting}
                      loading={isSubmitting}
                      loadingMessage={t("ButtonLoadingMessage")}
                    >
                      {t("Save")}
                    </Button>
                  </div>
                </Form>
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default ForceChangePassword;


### pages/forgot-password-success.tsx ###
import Image from "next/image";
import { useTranslation } from "react-i18next";
import BrandBackground from "../components/BrandBackground";
import Link from "next/link";
import Logo from "../public/logo.png";
import { NextPage } from "next";

const ForgotPasswordConfirmation: NextPage = () => {
  const { t } = useTranslation("ResetPasswordScreen");

  return (
    <>
      <div className="tw-flex tw-min-h-full">
        <BrandBackground />
        <div className="tw-flex tw-flex-1 tw-min-w-[50%] tw-flex-col tw-justify-center tw-py-12 tw-px-4 sm:tw-px-6 lg:tw-flex-none lg:tw-px-20 xl:tw-px-24">
          <div className="tw-mx-auto tw-w-full tw-max-w-sm lg:tw-w-96">
            <div className="tw-flex tw-flex-col tw-justify-center">
              <Image
                className="tw-h-12 tw-w-auto tw-object-contain"
                src={Logo}
                alt="Your Company"
              />
            </div>
            <h2 className="tw-mt-6 tw-text-3xl tw-font-bold tw-tracking-tight tw-text-gray-900 tw-text-center">
              {t("ForgotPasswordTitle")}
            </h2>
            <div className="tw-mt-8">
              <div className="tw-mt-6">
                <div className="tw-justify-center tw-my-5 tw-flex tw-flex-col tw-text-center">
                  <span className="tw-text-gray-500 tw-font-light tw-text-xs tw-mb-1">
                    {t("ForgotPasswordConfirmationMessage")}
                  </span>
                </div>
                <Link
                  href="/login"
                  className="tw-text-sm tw-font-medium tw-ml-2 tw-text-primary-600 hover:tw-text-primary-500 tw-flex tw-justify-center"
                >
                  {t("BackToLoginButton")}
                </Link>
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default ForgotPasswordConfirmation;


### pages/forgot-password.tsx ###
import {
  Button,
  Form,
  FormLabel,
  FormServerSideErrors,
  Input,
  useServerSideErrors,
} from "@fusion/ui";
import { zodResolver } from "@hookform/resolvers/zod";
import Image from "next/image";
import { useRouter } from "next/router";
import { useForm } from "react-hook-form";
import { useTranslation } from "react-i18next";
import { z } from "zod";
import BrandBackground from "../components/BrandBackground";
import Logo from "../public/logo.png";
import { routes } from "../routes";
import AccountService from "../services/AccountService";
import { NextPage } from "next";

const ForgotPassword: NextPage = () => {
  const router = useRouter();
  const { t } = useTranslation("ResetPasswordScreen");

  const forgotPasswordSchema = z.object({
    email: z
      .string({
        required_error: t("EmailValidationMessage"),
      })
      .email(t("EmailValidationMessage")),
  });

  type ValidationSchema = z.infer<typeof forgotPasswordSchema>;

  const { errors, setErrors, clearErrors } =
    useServerSideErrors<ValidationSchema>();

  const {
    control,
    handleSubmit,
    formState: { isSubmitting },
  } = useForm<ValidationSchema>({
    defaultValues: {},
    resolver: zodResolver(forgotPasswordSchema),
  });

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearErrors();
      try {
        await AccountService.forgotPassword(data.email);
        router.push(routes.FORGOT_PASSWORD_SUCCESS);
      } catch (error) {
        setErrors(error);
      }
    },
    (error, event) => {
      event?.preventDefault();
    }
  );

  return (
    <>
      <div className="tw-flex tw-min-h-full">
        <BrandBackground />
        <div className="tw-flex tw-flex-1 tw-min-w-[50%] tw-flex-col tw-justify-center tw-py-12 tw-px-4 sm:tw-px-6 lg:tw-flex-none lg:tw-px-20 xl:tw-px-24">
          <div className="tw-mx-auto tw-w-full tw-max-w-sm lg:tw-w-96">
            <div className="tw-flex tw-flex-col tw-justify-center">
              <Image
                className="tw-h-12 tw-w-auto tw-object-contain"
                src={Logo}
                alt="Your Company"
              />
            </div>
            <h2 className="tw-mt-6 tw-text-3xl tw-font-bold tw-tracking-tight tw-text-gray-900">
              {t("ForgotPasswordTitle")}
            </h2>
            <div className="tw-mt-8">
              <div className="tw-mt-6 tw-space-y-6">
                <Form>
                  <Input
                    id="email"
                    name="email"
                    control={control}
                    type="email"
                    LabelComponent={<FormLabel>{t("EmailLabel")}</FormLabel>}
                    errors={errors}
                  />

                  {/* Show general errors that are not related to any specific field */}
                  <div className="errors">
                    <FormServerSideErrors
                      errors={errors}
                      fieldKey={""}
                    ></FormServerSideErrors>
                  </div>

                  <div className="tw-flex tw-justify-end">
                    <Button
                      onClick={onSubmit}
                      disabled={isSubmitting}
                      loading={isSubmitting}
                      loadingMessage={t("ButtonLoadingMessage")}
                    >
                      {t("Save")}
                    </Button>
                  </div>
                </Form>
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default ForgotPassword;


### pages/index.tsx ###
import { NextPage } from "next";
import { useTranslation } from "react-i18next";
import useCookieConsentBanner from "../hooks/useCookieConsentBanner";

const Home: NextPage = () => {
  const { t } = useTranslation("HomeScreen");

  // const CookieConsentBanner = useCookieConsentBanner({
  //   accentColor: "red",
  // });

  return (
    <div>
      <h1 className="tw-text-3xl tw-font-sans tw-pb-10">{t("WelcomeTitle")}</h1>
      {/* <CookieConsentBanner /> */}
    </div>
  );
};

export default Home;


### pages/login.tsx ###
import {
  Button,
  Form,
  FormLabel,
  FormServerSideErrors,
  Input,
  useServerSideErrors,
} from "@fusion/ui";
import { zodResolver } from "@hookform/resolvers/zod";
import { GetServerSideProps, NextPage } from "next";
import Image from "next/image";
import Link from "next/link";
import { useRouter } from "next/router";
import { ParsedUrlQuery } from "querystring";
import { useForm } from "react-hook-form";
import { useTranslation } from "react-i18next";
import { z } from "zod";
import BrandBackground from "../components/BrandBackground";
import Logo from "../public/logo.png";
import { routes } from "../routes";
import AccountService from "../services/AccountService";
import { useUserStore } from "../stores/UserStore";
import EntryTypeService from "../services/EntryTypeService";
import { roles } from "../roles";

type LocalizationResponse = {
  name: string;
  value: string;
};

export const getServerSideProps: GetServerSideProps = async (context) => {
  const { query } = context as { query: ParsedUrlQuery };

  if (query.returnUrl === undefined) {
    return {
      props: {},
    };
  }

  return {
    props: {
      returnUrl: query.returnUrl,
    },
  };
};

type LoginProps = {
  returnUrl?: string;
};

const Login: NextPage<LoginProps> = (props) => {
  const router = useRouter();
  const { t } = useTranslation("LoginScreen");
  const { setRoles, setEntryTypes, setTenantId, setId } = useUserStore();

  const validationSchema = z.object({
    email: z.string().email(t("EmailValidationMessage")),
    password: z.string().min(8, t("PasswordValidationMessage")),
    "remember-me": z.boolean(),
  });

  type ValidationSchema = z.infer<typeof validationSchema>;
  const { errors, setErrors, clearErrors } =
    useServerSideErrors<ValidationSchema>();

  const {
    control,
    handleSubmit,
    formState: { isSubmitting },
  } = useForm<ValidationSchema>({
    defaultValues: {
      email: "",
      password: "",
      "remember-me": true,
    },
    resolver: zodResolver(validationSchema),
  });

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearErrors();
      try {
        await AccountService.login(data);

        const entryTypeList = await EntryTypeService.getAll();
        setEntryTypes(entryTypeList);
        const account = await AccountService.getCurrentAccount();
        setRoles(account.data.roles);
        setTenantId(account.data.tenantId);
        setId(account.data.id);

        if (
          account.data.roles.some(
            (r) =>
              r == roles.FrontFrontManualSigning || r == roles.FrontSystemUser
          )
        ) {
          router.push(routes.TRACK);
        } else router.push(props.returnUrl || routes.HOME);
      } catch (error) {
        if (error instanceof Response && error.status === 403) {
          const body = (await error.json()) as LocalizationResponse;

          if (body.name.toLowerCase().includes("expired")) {
            router.push({
              pathname: routes.FORCE_CHANGE_PASSWORD,
              query: { email: data.email },
            });
            return;
          }
        }
        setErrors(error);
      }
    },
    (error, event) => {
      event?.preventDefault();
    }
  );

  return (
    <div className="tw-flex tw-w-full tw-min-h-full">
      <BrandBackground />
      <div className="tw-flex tw-flex-1 tw-min-w-[50%] tw-flex-col tw-justify-center tw-py-12 tw-px-4 sm:tw-px-6 lg:tw-flex-none lg:tw-px-20 xl:tw-px-24">
        <div className="tw-mx-auto tw-w-full tw-max-w-sm lg:tw-w-96">
          <LoginHeader />
          <div className="tw-mt-8">
            <div className="tw-mt-6">
              <Form className="tw-space-y-6">
                <Input
                  id="email"
                  name="email"
                  control={control}
                  type="email"
                  autoComplete="email"
                  required
                  errors={errors}
                  LabelComponent={<FormLabel>{t("EmailLabel")}</FormLabel>}
                />

                <Input
                  id="password"
                  name="password"
                  type="password"
                  control={control}
                  autoComplete="current-password"
                  required
                  errors={errors}
                  LabelComponent={<FormLabel>{t("PasswordLabel")}</FormLabel>}
                />

                <div className="tw-flex tw-items-center tw-justify-between">
                  <a
                    onClick={() => {
                      router.push(routes.FORGOT_PASSWORD);
                    }}
                    className="tw-text-sm tw-font-medium tw-text-primary-600 hover:tw-text-primary-300 tw-cursor-pointer"
                  >
                    {t("ForgotPasswordLabel")}
                  </a>
                </div>
                {process.env.NEXT_PUBLIC_ALLOW_SELF_SIGNUP === "true" ? (
                  <div className="tw-flex tw-items-center">
                    <span className="tw-text-gray-500 tw-font-light">
                      {t("NoAccount")}
                    </span>
                    <Link
                      href="/register"
                      className="tw-text-sm tw-font-medium tw-ml-2 tw-text-primary-600 hover:tw-text-primary-500"
                    >
                      <span>{t("SignUp")}</span>
                    </Link>
                  </div>
                ) : null}

                {/* Show general errors that are not related to any specific field */}
                <div className="errors">
                  <FormServerSideErrors errors={errors} fieldKey="" />
                </div>

                <div className="tw-mt-4">
                  <Button
                    disabled={isSubmitting}
                    onClick={onSubmit}
                    className="tw-w-full"
                    loading={isSubmitting}
                    loadingMessage={t("ButtonLoadingMessage")}
                  >
                    {t("SignIn")}
                  </Button>
                </div>
              </Form>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Login;

type SocialProvider = {
  href: string;
  name: string;
  icon: JSX.Element;
};

const FacebookIcon = () => {
  return (
    <svg
      fill="currentColor"
      className="tw-h-5 tw-w-5"
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 512 512"
    >
      <path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z" />
    </svg>
  );
};

const GoogleIcon = () => {
  return (
    <svg
      fill="currentColor"
      className="tw-h-5 tw-w-5"
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 488 512"
    >
      <path d="M488 261.8C488 403.3 391.1 504 248 504 110.8 504 0 393.2 0 256S110.8 8 248 8c66.8 0 123 24.5 166.3 64.9l-67.5 64.9C258.5 52.6 94.3 116.6 94.3 256c0 86.5 69.1 156.6 153.7 156.6 98.2 0 135-70.4 140.8-106.9H248v-85.3h236.1c2.3 12.7 3.9 24.9 3.9 41.4z" />
    </svg>
  );
};

const socialProviders: SocialProvider[] = [
  {
    href: "#",
    name: "Facebook",
    icon: FacebookIcon(),
  },
  {
    href: "#",
    name: "Google",
    icon: GoogleIcon(),
  },
];

const SocialLogin = ({ providers }: { providers: SocialProvider[] }) => {
  const { t } = useTranslation("LoginScreen");

  return (
    <div>
      <p className="tw-text-sm tw-font-medium tw-text-gray-700">
        {t("SignInWith")}
      </p>

      <div className="tw-mt-1 tw-grid tw-grid-cols-3 tw-gap-3">
        {providers.map((provider) => (
          <div key={provider.name}>
            <a
              href="#"
              className="tw-inline-flex tw-w-full tw-justify-center tw-rounded-md tw-border tw-border-gray-300 tw-bg-white tw-py-2 tw-px-4 tw-text-sm tw-font-medium tw-text-gray-500 tw-shadow-sm hover:tw-bg-gray-50"
            >
              <span className="tw-sr-only">
                {t("SignInWith")} {provider.name}
              </span>
              {provider.icon}
            </a>
          </div>
        ))}
      </div>
    </div>
  );
};

const LoginHeader = () => {
  const { t } = useTranslation("LoginScreen");

  return (
    <div>
      <Image className="tw-h-12 tw-w-auto" src={Logo} alt="Your Company" />
      <h2 className="tw-mt-6 tw-text-3xl tw-font-bold tw-tracking-tight tw-text-gray-900">
        {t("SignInMessage")}...
      </h2>
    </div>
  );
};


### pages/profile.tsx ###
import {
    Badge,
    Button,
    Form,
    FormLabel,
    FormServerSideErrors,
    Input,
    PageHeader,
    PhoneInput,
    Select,
    useServerSideErrors,
} from "@fusion/ui";
import {
    EnvelopeIcon,
    LanguageIcon,
    LockClosedIcon,
    PhoneIcon,
    UserIcon,
} from "@heroicons/react/20/solid";
import {PencilIcon} from "@heroicons/react/24/outline";
import {zodResolver} from "@hookform/resolvers/zod";
import {GetServerSideProps} from "next";
import {useState} from "react";
import {useForm} from "react-hook-form";
import {useTranslation} from "react-i18next";
import {z} from "zod";
import useLocalizedCountries from "../hooks/useLocalizedCountries";
import AccountService, {Account} from "../services/AccountService";
import React from "react";
import {useUserStore} from "../stores/UserStore";
import i18n from "../i18n";
import {FormServerSideErrorsProps} from "@fusion/form-error/src/FormServerSideErrors";
import {CustomFormServerSideErrors} from "../components/FormValidator/CustomValidator";
import {useRouter} from "next/router";
import {routes} from "../routes";

export const getServerSideProps: GetServerSideProps = async (context) => {
    const {data: account, cookies} = await AccountService.getCurrentAccount(
        context.req.cookies
    );

    try {
        // If cookies exists, set them in the response because the token was refreshed
        cookies && context.res.setHeader("Set-Cookie", cookies);

        return {
            props: {
                account,
            },
        };
    } catch (error) {
        return {
            redirect: {
                destination: `/500`,
                permanent: false,
            },
        };
    }
};

type ProfileScreenProps = {
    account: Account;
};

const ProfileScreen = (props: ProfileScreenProps) => {
    const [mode, setMode] = useState<"view" | "edit">("view");
    const {t} = useTranslation("ProfileScreen");

    const defaultLanguage = "es";
    const {setPreferredLanguage, preferredLanguage} = useUserStore();
    const [selectedLanguage, setSelectedLanguage] = React.useState(
        preferredLanguage || defaultLanguage
    );

    const setApplicationLanguage = async () => {
        setPreferredLanguage(selectedLanguage);
        await i18n.changeLanguage(selectedLanguage);
    };

    return (
        <div className="tw-pb-4">
            <PageHeader
                description={t("AccountSettingsDescription")}
                title={t("AccountSettingsTitle")}
            />
            <AccountInformation
                account={props.account}
                onToggleMode={() => setMode(mode === "edit" ? "view" : "edit")}
                mode={mode}
                toggleMode={() => setMode(mode === "edit" ? "view" : "edit")}
            />

            <h2 className="tw-mt-8 tw-mb-2 tw-text-2xl tw-font-bold tw-leading-7 tw-text-gray-900 sm:tw-truncate sm:tw-text-2xl sm:tw-tracking-tight">
                {t("PreferencesTitle")}
            </h2>

            {/* <div className="tw-bg-white tw-flex tw-space-x-4 tw-items-center tw-p-4 tw-rounded-lg tw-max-w-5xl">
        <Select
          name="language"
          LabelComponent={<FormLabel>{t("PreferredLanguageLabel")}</FormLabel>}
          placeholder={t("PreferredLanguagePlaceholder")}
          value={selectedLanguage}
          items={[
            { value: "en", text: t("LanguageEnglish") },
            { value: "es", text: t("LanguageSpanish") },
          ]}
          onValueChange={(value: string) => {
            setSelectedLanguage(value);
          }}
        ></Select>
        <Button onClick={() => setApplicationLanguage()}>
          {t("PreferredLanguageUpdateBtn")}
        </Button>
      </div> */}

            <h2 className="tw-mt-8 tw-mb-2 tw-text-2xl tw-font-bold tw-leading-7 tw-text-gray-900 sm:tw-truncate sm:tw-text-2xl sm:tw-tracking-tight">
                {t("ChangePasswordTitle")}
            </h2>

            <div className="tw-bg-white tw-max-w-5xl tw-px-4 tw-pb-4 tw-pt-1 tw-rounded-lg">
                <ChangePasswordForm/>
            </div>
        </div>
    );
};

const AccountInformation = (props: {
    account: Account;
    onToggleMode: () => void;
    mode: "view" | "edit";
    toggleMode: () => void;
}) => {

    const {account, onToggleMode, mode, toggleMode} = props;

    const {t} = useTranslation("EditAccountInfoForm");

    const {countriesPhoneCodes} = useLocalizedCountries();

    const validationSchema = z.object({
        name: z.string().min(1, {message: t("NameValidationMessage")}),
        lastName: z.string().min(1, {message: t("LastNameValidationMessage")}),
        phoneNumber: z.string().optional(),
        email: z.string(),
    });

    type ValidationSchema = z.infer<typeof validationSchema>;

    const {errors, setErrors, clearErrors} =
        useServerSideErrors<ValidationSchema>();

    const {control, handleSubmit} = useForm<ValidationSchema>({
        defaultValues: {
            email: account.email,
            name: account.name,
            lastName: account.lastName,
            phoneNumber: account.phoneNumber,
        },
        resolver: zodResolver(validationSchema),
    });

    const onSubmit = handleSubmit(
        async (data, event) => {
            event?.preventDefault();
            clearErrors();
            try {
                await AccountService.update(data);
                toggleMode();
            } catch (error) {
                setErrors(error);
            }
        },
        (error, event) => {
            event?.preventDefault();
        }
    );

    const onCancel = () => {
        toggleMode();
    };

    return (
        <div className="tw-bg-white tw-rounded-lg tw-p-4 tw-max-w-5xl">
            <div className="md:tw-flex md:tw-items-center md:tw-justify-between md:tw-space-x-5">
                <div className="tw-flex tw-items-start tw-space-x-5 tw-w-full tw-max-w-5xl">
                    <div className="tw-pt-1.5 tw-w-full tw-max-w-5xl">
                        {mode == "view" ? (
                            <>
                                <h1 className="tw-text-2xl tw-font-bold tw-text-gray-900">
                                    {account.name} {account.lastName}
                                </h1>

                                <p className="tw-text-sm tw-font-medium tw-text-gray-900 tw-flex tw-gap-2 tw-items-center tw-mt-2">
                                    <EnvelopeIcon height={20} width={20}></EnvelopeIcon>
                                    {account.email}
                                </p>
                                <div
                                    className="tw-text-sm tw-font-medium tw-text-gray-900 tw-flex tw-gap-2 tw-items-center tw-mt-2">
                                    <LockClosedIcon height={20} width={20}></LockClosedIcon>
                                    <div className="tw-flex tw-gap-2 tw-items-center tw-flex-wrap">
                                        {account.roles.map((role) => {
                                            const roleKey = role.split(".").pop() || "";
                                            return (
                                                <Badge key={role}>
                                                    {t(roleKey, {
                                                        ns: "Roles",
                                                    })}
                                                </Badge>
                                            );
                                        })}
                                    </div>
                                </div>

                                {account.phoneNumber ? (
                                    <p className="tw-text-sm tw-font-medium tw-text-gray-900 tw-flex tw-gap-2 tw-items-center tw-mt-2">
                                        <PhoneIcon height={20} width={20}></PhoneIcon>
                                        {account.phoneNumber}
                                    </p>
                                ) : null}

                                {account.language ? (
                                    <p className="tw-text-sm tw-font-medium tw-text-gray-900 tw-flex tw-gap-2 tw-items-center tw-mt-2">
                                        <LanguageIcon height={20} width={20}></LanguageIcon>
                                        {account.language}
                                    </p>
                                ) : null}
                            </>
                        ) : (
                            <Form title={t("AccountFormTitle")}>
                                <Input
                                    name="name"
                                    control={control}
                                    LabelComponent={<FormLabel>{t("NameLabel")}</FormLabel>}
                                    iconLeft={<UserIcon width={20} height={20}></UserIcon>}
                                    type="text"
                                    placeholder={t("NamePlaceholder")}
                                    errors={errors}
                                ></Input>
                                <Input
                                    name="lastName"
                                    control={control}
                                    LabelComponent={<FormLabel>{t("LastNameLabel")}</FormLabel>}
                                    type="text"
                                    iconLeft={<UserIcon width={20} height={20}></UserIcon>}
                                    placeholder={t("LastNamePlaceholder")}
                                    errors={errors}
                                ></Input>
                                <Input
                                    name="email"
                                    control={control}
                                    disabled
                                    iconLeft={
                                        <EnvelopeIcon width={20} height={20}></EnvelopeIcon>
                                    }
                                    LabelComponent={<FormLabel>{t("EmailLabel")}</FormLabel>}
                                    type="text"
                                    errors={errors}
                                ></Input>
                                <PhoneInput
                                    name="phoneNumber"
                                    intlTelInputProps={{
                                        countriesData: countriesPhoneCodes,
                                    }}
                                    control={control}
                                    placeholder={t("PhoneNumberPlaceholder")}
                                    value={account.phoneNumber}
                                    LabelComponent={
                                        <FormLabel>{t("PhoneNumberLabel")}</FormLabel>
                                    }
                                    errors={errors}
                                ></PhoneInput>

                                {/* Show general errors that are not related to any specific field */}
                                <div className="errors">
                                    <FormServerSideErrors
                                        errors={errors}
                                        fieldKey={""}
                                    ></FormServerSideErrors>
                                </div>
                                <div className="tw-flex tw-justify-end tw-gap-2">
                                    <div className="tw-flex tw-justify-end">
                                        <Button variant="secondary" onClick={onCancel}>
                                            {t("Cancel")}
                                        </Button>
                                    </div>
                                    <div className="tw-flex tw-justify-end">
                                        <Button onClick={onSubmit}>{t("Save")}</Button>
                                    </div>
                                </div>
                            </Form>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

const ChangePasswordForm: React.FC = () => {

    const [dataError, setDataError] = useState<{ [key: string]: string[] }>();
    const [isLoading,setIsLoading] = useState(false);
    const router = useRouter();
    const {t} = useTranslation("ChangePasswordForm");

    const changePasswordSchema = z
        .object({
            oldPassword: z
                .string()
                .min(1, {message: t("OldPasswordValidationMessage")}),
            newPassword: z
                .string()
                .min(1, {message: t("NewPasswordValidationMessage")}),
            confirmPassword: z
                .string()
                .min(1, {message: t("ConfirmPasswordValidationMessage")}),
        })
        .refine((data) => data.newPassword === data.confirmPassword, {
            message: t("PasswordsDontMatchValidationMessage"),
            path: ["confirmPassword"],
        });

    type ValidationSchema = z.infer<typeof changePasswordSchema>;

    const {errors, setErrors, clearErrors} =
        useServerSideErrors<ValidationSchema>();

    const {control, handleSubmit, reset} = useForm<ValidationSchema>({
        defaultValues: {
            oldPassword: "",
            newPassword: "",
            confirmPassword: "",
        },
        resolver: zodResolver(changePasswordSchema),
    });

    const onSubmit = handleSubmit(
        async (data, event) => {
            event?.preventDefault();
            clearErrors();
            setIsLoading(true);
            try {
                await AccountService.changePassword(data);
                reset();
                await AccountService.logout("");
                router.push(routes.LOGIN);
            } catch (error: any) {
                await handleServerError(error);
            } finally {
                setIsLoading(false);
            }
        },
        (error, event) => {
            event?.preventDefault();
        }
    );
    const handleServerError = async (error: unknown) => {
        clearErrors(); // Clear any previous errors

        if (error instanceof Response) {
            try {
                const errorData = await error.json();

                if (errorData?.errors) {
                    // If `errorData.errors` exists, set them in the appropriate format
                    const formattedErrors: { [key: string]: string[] } = {};

                    // Loop through each key and normalize the errors to be either an array of strings
                    Object.keys(errorData.errors).forEach((key) => {
                        const errorMessages = errorData.errors[key];
                        // Ensure each error is in array format, handling cases like objects (deep flatten)
                        formattedErrors[key.toLowerCase()] = Array.isArray(errorMessages)
                            ? errorMessages.map(String)
                            : [String(errorMessages)];
                    });

                    // Set the formatted errors in the state
                    setDataError(formattedErrors)
                    setErrors(formattedErrors);

                } else {
                    // Fallback for unexpected error structures
                    setErrors({
                        "": ["An unexpected error occurred. Please try again."],
                    });
                }
            } catch (jsonError) {
                // Fallback if the error response cannot be parse
                setErrors({
                    "": ["Failed to parse error response."],
                });
            }
        } else {
            // Fallback for non-Response errors
            setErrors({
                "": ["An unexpected error happened."],
            });
        }
    };
    return (
        <Form>
            <Input
                name="oldPassword"
                control={control}
                type="password"
                iconLeft={<LockClosedIcon width={20} height={20}></LockClosedIcon>}
                LabelComponent={<FormLabel required>{t("OldPasswordLabel")}</FormLabel>}
                placeholder={t("OldPasswordPlaceholder")}
                errors={errors}
            />
            <Input
                name="newPassword"
                control={control}
                type="password"
                iconLeft={<LockClosedIcon width={20} height={20}></LockClosedIcon>}
                LabelComponent={<FormLabel required>{t("NewPasswordLabel")}</FormLabel>}
                placeholder={t("NewPasswordPlaceholder")}
                errors={errors}
            />
            <Input
                name="confirmPassword"
                control={control}
                type="password"
                iconLeft={<LockClosedIcon width={20} height={20}></LockClosedIcon>}
                LabelComponent={
                    <FormLabel required>{t("ConfirmPasswordLabel")}</FormLabel>
                }
                placeholder={t("ConfirmPasswordPlaceholder")}
                errors={errors}
            />

            {/* Show general errors that are not related to any specific field */}
            <div className="errors">
                <FormServerSideErrors errors={errors} fieldKey={""}/>
                <CustomFormServerSideErrors errors={dataError} fieldKey={""}/>
            </div>

            <div className="tw-flex tw-justify-end">
                <Button onClick={onSubmit} loading={isLoading} disabled={isLoading}>{t("Save")}</Button>
            </div>
        </Form>
    );
};

export default ProfileScreen;


### pages/register-confirmation.tsx ###
import { GetServerSideProps, NextPage } from "next";
import Image from "next/image";
import Link from "next/link";
import { ParsedUrlQuery } from "querystring";
import { useTranslation } from "react-i18next";
import BrandBackground from "../components/BrandBackground";
import Logo from "../public/logo.png";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const { query } = context as { query: ParsedUrlQuery };

  if (process.env.NEXT_PUBLIC_ALLOW_SELF_SIGNUP === "false") {
    const destinationUrl = "/login";

    if (query.returnUrl) destinationUrl.concat(`?returnUrl=${query.returnUrl}`);

    return {
      redirect: {
        destination: destinationUrl,
        permanent: false,
      },
    };
  }

  if (query.confirmationMessages === undefined) {
    return {
      props: {},
    };
  }

  return {
    props: {
      confirmationMessages:
        typeof query.confirmationMessages === "string"
          ? [query.confirmationMessages]
          : query.confirmationMessages,
    },
  };
};

type RegisterConfirmationProps = {
  confirmationMessages?: string[];
};

const RegisterConfirmation: NextPage<RegisterConfirmationProps> = ({
  confirmationMessages,
}) => {
  const { t } = useTranslation("RegisterConfirmationScreen");

  return (
    <>
      <div className="tw-flex tw-w-full tw-min-h-full">
        <BrandBackground />
        <div className="tw-flex tw-flex-1 tw-min-w-[50%] tw-flex-col tw-justify-center tw-py-12 tw-px-4 sm:tw-px-6 lg:tw-flex-none lg:tw-px-20 xl:tw-px-24">
          <div className="tw-mx-auto tw-w-full tw-max-w-sm lg:tw-w-96">
            <div className="tw-flex tw-flex-col tw-justify-center">
              <Image
                className="tw-h-12 tw-w-auto tw-object-contain"
                src={Logo}
                alt="Your Company"
              />
            </div>
            <h2 className="tw-mt-6 tw-text-3xl tw-font-bold tw-tracking-tight tw-text-gray-900 tw-text-center">
              {t("RegisterConfirmation")}
            </h2>
            <div className="tw-mt-8">
              <div className="tw-mt-6">
                <div className="tw-justify-center tw-my-5 tw-flex tw-flex-col tw-text-center">
                  {confirmationMessages
                    ? confirmationMessages.map((confirmationMessage) => (
                        <span
                          key={confirmationMessage}
                          className="tw-text-gray-500 tw-font-light tw-text-xs tw-mb-1"
                        >
                          {confirmationMessage}
                        </span>
                      ))
                    : null}
                </div>
                <Link
                  href="/login"
                  className="tw-text-sm tw-font-medium tw-ml-2 tw-text-primary-600 hover:tw-text-primary-500 tw-flex tw-justify-center"
                >
                  {t("BackToLoginButton")}
                </Link>
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default RegisterConfirmation;


### pages/register.tsx ###
import {
  Button,
  Form,
  FormLabel,
  FormServerSideErrors,
  Input,
  useServerSideErrors,
} from "@fusion/ui";
import { zodResolver } from "@hookform/resolvers/zod";
import { GetServerSideProps, NextPage } from "next";
import Image from "next/image";
import Link from "next/link";
import { useRouter } from "next/router";
import { ParsedUrlQuery } from "querystring";
import { useForm } from "react-hook-form";
import { useTranslation } from "react-i18next";
import { z } from "zod";
import BrandBackground from "../components/BrandBackground";
import Logo from "../public/logo.png";
import AccountService from "../services/AccountService";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const { query } = context as { query: ParsedUrlQuery };

  if (process.env.NEXT_PUBLIC_ALLOW_SELF_SIGNUP === "false") {
    const destinationUrl = "/login";

    if (query.returnUrl) destinationUrl.concat(`?returnUrl=${query.returnUrl}`);

    return {
      redirect: {
        destination: destinationUrl,
        permanent: false,
      },
    };
  }

  return {
    props: {},
  };
};

const Register: NextPage = () => {
  const router = useRouter();
  const { t } = useTranslation("RegisterScreen");
  const { errors, setErrors, clearErrors } =
    useServerSideErrors<ValidationSchema>();

  const validationSchema = z
    .object({
      confirmPassword: z.string().min(8, t("PasswordValidationMessage")),
      email: z.string().email(t("EmailValidationMessage")),
      lastName: z.string().max(50, t("LastNameValidationMessage")),
      name: z.string().max(50, t("NameValidationMessage")),
      password: z.string().min(8, t("PasswordValidationMessage")),
    })
    .refine((data) => data.password === data.confirmPassword, {
      message: t("PasswordsDontMatchValidationMessage"),
      path: ["confirmPassword"],
    });

  type ValidationSchema = z.infer<typeof validationSchema>;

  const {
    control,
    handleSubmit,
    formState: { isSubmitting },
  } = useForm<ValidationSchema>({
    defaultValues: {
      confirmPassword: "",
      email: "",
      lastName: "",
      name: "",
      password: "",
    },
    resolver: zodResolver(validationSchema),
  });

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearErrors();
      try {
        const { confirmPassword, ...registerDTO } = data;

        const response = await AccountService.register(registerDTO);

        router.push({
          pathname: "/register-confirmation",
          query: { confirmationMessages: response },
        });
      } catch (error) {
        setErrors(error);
      }
    },
    (error, event) => {
      event?.preventDefault();
    }
  );

  return (
    <>
      <div className="tw-flex tw-w-full tw-min-h-full">
        <BrandBackground />
        <div className="tw-flex tw-flex-1 tw-min-w-[50%] tw-flex-col tw-justify-center tw-py-12 tw-px-4 sm:tw-px-6 lg:tw-flex-none lg:tw-px-20 xl:tw-px-24">
          <div className="tw-mx-auto tw-w-full tw-max-w-sm lg:tw-w-96">
            <div className="tw-flex tw-flex-col tw-justify-center">
              <Image
                className="tw-h-12 tw-w-auto tw-object-contain"
                src={Logo}
                alt="Your Company"
              />
            </div>
            <div className="tw-mt-8">
              <div className="tw-mt-6">
                <Form className="tw-space-y-6">
                  <Input
                    id="email"
                    name="email"
                    control={control}
                    type="email"
                    autoComplete="email"
                    required
                    errors={errors}
                    LabelComponent={<FormLabel>{t("EmailLabel")}</FormLabel>}
                  />

                  <Input
                    id="name"
                    name="name"
                    control={control}
                    required
                    errors={errors}
                    LabelComponent={<FormLabel>{t("NameLabel")}</FormLabel>}
                  />

                  <Input
                    id="lastName"
                    name="lastName"
                    control={control}
                    required
                    errors={errors}
                    LabelComponent={<FormLabel>{t("LastNameLabel")}</FormLabel>}
                  />

                  <Input
                    id="password"
                    name="password"
                    type="password"
                    control={control}
                    autoComplete="current-password"
                    required
                    errors={errors}
                    LabelComponent={<FormLabel>{t("PasswordLabel")}</FormLabel>}
                  />

                  <Input
                    id="confirmPassword"
                    name="confirmPassword"
                    type="password"
                    control={control}
                    autoComplete="current-password"
                    required
                    errors={errors}
                    LabelComponent={
                      <FormLabel>{t("ConfirmPasswordLabel")}</FormLabel>
                    }
                  />

                  {/* Show general errors that are not related to any specific field */}
                  <div className="errors">
                    <FormServerSideErrors errors={errors} fieldKey="" />
                  </div>

                  <div className="tw-mt-4">
                    <Button
                      disabled={isSubmitting}
                      onClick={onSubmit}
                      className="tw-w-full"
                      loading={isSubmitting}
                      loadingMessage={t("ButtonLoadingMessage")}
                    >
                      {t("SubmitButton")}
                    </Button>
                  </div>
                </Form>

                <div className="tw-flex tw-justify-center tw-items-center tw-mt-5">
                  <span className="tw-text-gray-500 tw-font-light">
                    {t("ExistingAccount")}
                  </span>
                  <Link
                    href="/login"
                    className="tw-text-sm tw-font-medium tw-ml-2 tw-text-primary-600 hover:tw-text-primary-500"
                  >
                    {t("LoginButton")}
                  </Link>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default Register;


### pages/reports/index.tsx ###
import {
    Button,
    Column,
    Form,
    FormLabel,
    Input,
    PageHeader,
    Select,
    useServerSideErrors,
} from "@fusion/ui";
import AccountService from "../../services/AccountService";
import {useTranslation} from "react-i18next";
import {roles} from "../../roles";
import {GetServerSideProps} from "next";
import useNetworkErrorHandler from "../../hooks/useNetworkErrorHandler";
import {useEffect, useRef, useState} from "react";
import {Summary, TotalItem} from "devextreme-react/data-grid";
import {useForm} from "react-hook-form";
import {z} from "zod";
import {zodResolver} from "@hookform/resolvers/zod";
import {DataGridLocal} from "../../components/DataGridLocal";
import UserEntryService from "../../services/UserEntryService";
import {TimeHelper} from "../../helpers/TimeHelper";
import {DateHelper} from "../../helpers/DateHelper";
import {useUserStore} from "../../stores/UserStore";

export type EmployeesOption = {
    name: string;
    value: string;
};

export const getServerSideProps: GetServerSideProps = async (context) => {
    const requiredRoles = [roles.FrontFrontHumanCapital, roles.FrontSystemUser];
    const {isAuthorized} = await AccountService.authorize(
        requiredRoles,
        context.req.cookies
    );

    if (!isAuthorized) {
        return {
            redirect: {
                destination: `/401`,
                permanent: false,
            },
        };
    }
    return {props: {}};
};

export type FormValues = {
    dateFrom: string;
    dateTo: string;
    employee: string;
};

const Reports = () => {
    const {t} = useTranslation("ReportListScreen");
    const firstMount = useRef<boolean>(true);
    const baseUrlReport = `/api/UserEntry/get-users-working-hour?format=dx`;
    const baseAbsencesUrlReport = `/api/eventHistory/get-user-event-history?format=dx`;
    const [reportUrl, setReportUrl] = useState<string>();
    const [absencesUrl, setAbsencesUrl] = useState<string>();
    const [employees, setEmployees] = useState<EmployeesOption[]>();
    const [totalHours, setTotalHours] = useState<string>();
    const {handleError} = useNetworkErrorHandler();
    const [formData, setFormData] = useState<FormValues>();
    const {
        errors,
        setErrors,
        clearErrors: clearServerErrors,
    } = useServerSideErrors<FormValues>();
    const [reportType, setReportType] = useState<"Absences" | "Hours">("Hours");
    const {id, roles} = useUserStore();
    const isHumanCapital =
        roles && roles.includes("Front.FrontHumanCapital");
    const getEmployees = async () => {
        try {
            const result = await UserEntryService.getUserReportList();
            let employeesList = result.map((c) => ({
                value: c.value ?? "",
                name: c.text,
            }));
            if (isHumanCapital) {
                const all = {
                    value: "",
                    name: t("EmployeesAllPlaceholder")
                }
                employeesList = [all, ...employeesList]
            }
            setEmployees(employeesList);
        } catch (error) {
            handleError(error);
        }
    };

    const getTotalHours = async () => {
        try {

            const result = await UserEntryService.getUserReportData(
                formData?.employee ? formData?.employee : "",
                formData?.dateFrom ? formData?.dateFrom : "0001-01-01",
                formData?.dateTo ? formData?.dateTo : "9999-01-01"
            );

            let totalHours: number = 0;
            result.map(
                (reportData) =>
                    (totalHours += TimeHelper.timeStringToMinutes(reportData.totalHour))
            );

            setTotalHours(TimeHelper.formatMinutes(totalHours));
        } catch (error) {
            handleError(error);
        }
    };

    useEffect(() => {
        if (firstMount.current) {
            firstMount.current = false;
            getEmployees();
        }
    }, []);

    useEffect(() => {

        const employeeId = (roles && roles[0] === "Front.SystemUser") ? id : "";

        if (formData && reportType === "Hours") {
            let url = `${baseUrlReport}&userId=${formData?.employee}&dateStart=${formData?.dateFrom}&dateEnd=${formData?.dateTo}`;
            setReportUrl(url);
        } else {
            setReportUrl(
                `${baseUrlReport}&userId=${employeeId}&dateStart=0001-01-01&dateEnd=9999-01-01`
            );
        }
        if (formData && reportType === "Absences") {
            let url = `${baseAbsencesUrlReport}&userId=${formData?.employee}&dateStart=${formData?.dateFrom}&dateEnd=${formData?.dateTo}`;
            setAbsencesUrl(url);
        } else {
            setAbsencesUrl(
                `${baseAbsencesUrlReport}&userId=${employeeId}&dateStart=0001-01-01&dateEnd=9999-01-01`
            );
        }
        getTotalHours()
    }, [formData]);

    const validationSchema = z.object({
        dateFrom: z.string({
            required_error: t("DateFromRequiredValidationMessage"),
        }),
        dateTo: z.string({
            required_error: t("DateToRequiredValidationMessage"),
        }),
        employee: z.string({
            required_error: t("EmployeeRequiredValidationMessage"),
        }),
    });

    type ValidationSchema = z.infer<typeof validationSchema>;
    const {
        control,
        handleSubmit,
        formState: {errors: clientErrors, isSubmitting},
        clearErrors: clearClientErrors,
    } = useForm<ValidationSchema>({
        defaultValues: {
            employee: (roles && roles[0] === "Front.SystemUser") ? id : ""
        },
        resolver: zodResolver(validationSchema),
    });

    const onSubmit = handleSubmit(
        async (data, event) => {
            event?.preventDefault();
            clearServerErrors();
            try {
                setFormData({
                    dateFrom: DateHelper.toLocalISOString(new Date(data.dateFrom)),
                    dateTo: DateHelper.toLocalISOString(new Date(data.dateTo)),
                    employee: data.employee,
                });
            } catch (error) {
                setErrors(error);
                console.error("An unexpected error happened:", error);
            }
        },
        (error, event) => {
            event?.preventDefault();
            handleError(error);
        }
    );
    const calculatedHours = (rowData: any) => {
        return rowData.totalHour;
    }
    return (
        <>
            {/* Header */}
            <PageHeader title={t("Title")}></PageHeader>
            <Select
                multiple={false}
                LabelComponent={<FormLabel>{t("WorkingHoursAbsencesLabel")}</FormLabel>}
                name="workinghoursAbsences"
                searchEnabled={false}
                displayExpr={"name"}
                valueExpr={"value"}
                value={reportType}
                items={[
                    {name: t("Absences"), value: "Absences"},
                    {name: t("Hours"), value: "Hours"},
                ]}
                onValueChange={(value) => {
                    setReportType(value);
                }}
            />
            {/* Filter Form */}
            <Form>
                <div className="tw-grid tw-grid-cols-4 tw-gap-4">
                    <Select
                        multiple={false}
                        LabelComponent={<FormLabel>{t("EmployeesLabel")}</FormLabel>}
                        name="employee"
                        placeholder={t("EmployeesPlaceholder")}
                        control={control}
                        errors={errors}
                        searchEnabled={false}
                        displayExpr={"name"}
                        valueExpr={"value"}
                        items={employees}
                        disabled={roles && roles[0] === "Front.SystemUser"}
                    />
                    <Input
                        name="dateFrom"
                        defaultValue={formData?.dateFrom}
                        control={control}
                        type="date"
                        errors={errors}
                        required
                        LabelComponent={<FormLabel>{t("DateFromLabel")}</FormLabel>}
                    ></Input>
                    <Input
                        name="dateTo"
                        defaultValue={formData?.dateTo}
                        control={control}
                        type="date"
                        errors={errors}
                        required
                        LabelComponent={<FormLabel>{t("DateToLabel")}</FormLabel>}
                    ></Input>
                    <div>
                        <Button
                            onClick={onSubmit}
                            disabled={isSubmitting}
                            loading={isSubmitting}
                        >
                            {t("Search")}
                        </Button>
                    </div>
                </div>
            </Form>
            {/* Grid */}
            {reportType === "Hours" && (
                <DataGridLocal url={reportUrl} enableRowAlternation={false}>
                    <Column
                        name={"name"}
                        dataField={"name"}
                        caption={t("NameLabel")}
                        dataType="string"
                        visible={isHumanCapital}
                    />
                    <Column
                        name={"date"}
                        dataField={"date"}
                        caption={t("DateColumnLabel")}
                        dataType="date"
                    />
                    <Column
                        name={"totalHour"}
                        dataField={"totalHour"}
                        caption={t("TotalHoursColumnLabel")}
                        calculateCellValue={calculatedHours}
                        cellRender={(cellData) => {
                            const isTargetRange = cellData.data && cellData.data.entriesRange.includes("??:??");

                            return (
                                <span style={{ color: isTargetRange ? "red" : "inherit" }}>
                                    {cellData.value}
                                </span>
                            );
                        }}
                    />
                    <Column
                        name={"entriesRange"}
                        dataField={"entriesRange"}
                        caption={t("EntriesRange")}
                        dataType="string"
                    />
                    <Column
                        name={"comments"}
                        dataField={"comments"}
                        caption={t("EventsColumnLabel")}
                        dataType="string"
                    ></Column>
                    <Summary>
                        <TotalItem
                            showInColumn="date"
                            column="totalHour"
                            summaryType="sum"
                            displayFormat={t("TotalHoursColumnLabel") + ": " + totalHours}
                        />
                    </Summary>
                </DataGridLocal>
            )}
            {reportType === "Absences" && (
                <DataGridLocal url={absencesUrl} enableRowAlternation={false}>
                    <Column
                        name={"name"}
                        dataField={"name"}
                        caption={t("NameLabel")}
                        dataType="string"
                    />
                    <Column
                        name={"status"}
                        dataField={"status"}
                        caption={t("StateColumnLabel")}
                        dataType="string"
                    />
                    <Column
                        name={"dateStart"}
                        dataField={"dateStart"}
                        caption={t("DateStartColumnLabel")}
                        dataType="date"
                    />
                    <Column
                        name={"dateEnd"}
                        dataField={"dateEnd"}
                        caption={t("DateEndColumnLabel")}
                        dataType="date"
                    />
                    <Column
                        name={"comments"}
                        dataField={"comments"}
                        caption={t("CommentsColumnLabel")}
                        dataType="string"
                    />
                </DataGridLocal>
            )}
        </>
    );
};

export default Reports;


### pages/reset-password-confirmation.tsx ###
import { NextPage } from "next";
import Image from "next/image";
import Link from "next/link";
import { useTranslation } from "react-i18next";
import BrandBackground from "../components/BrandBackground";
import Logo from "../public/logo.png";

const RegisterConfirmation: NextPage = () => {
  const { t } = useTranslation("ResetPasswordConfirmationScreen");

  return (
    <>
      <div className="tw-flex tw-w-full tw-min-h-full">
        <BrandBackground />
        <div className="tw-flex tw-flex-1 tw-min-w-[50%] tw-flex-col tw-justify-center tw-py-12 tw-px-4 sm:tw-px-6 lg:tw-flex-none lg:tw-px-20 xl:tw-px-24">
          <div className="tw-mx-auto tw-w-full tw-max-w-sm lg:tw-w-96">
            <div className="tw-flex tw-flex-col tw-justify-center">
              <Image
                className="tw-h-12 tw-w-auto tw-object-contain"
                src={Logo}
                alt="Your Company"
              />
            </div>
            <h2 className="tw-mt-6 tw-text-3xl tw-font-bold tw-tracking-tight tw-text-gray-900 tw-text-center">
              {t("ResetPasswordConfirmationTitle")}
            </h2>
            <div className="tw-mt-8">
              <div className="tw-mt-6">
                <div className="tw-justify-center tw-my-5 tw-flex tw-flex-col tw-text-center">
                  <span className="tw-text-gray-500 tw-font-light tw-text-xs tw-mb-1">
                    {t("ResetPasswordConfirmationMessage")}
                  </span>
                </div>
                <Link
                  href="/login"
                  className="tw-text-sm tw-font-medium tw-ml-2 tw-text-primary-600 hover:tw-text-primary-500 tw-flex tw-justify-center"
                >
                  {t("BackToLoginButton")}
                </Link>
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default RegisterConfirmation;


### pages/reset-password.tsx ###
import {
  Button,
  Form,
  FormLabel,
  FormServerSideErrors,
  Input,
  useServerSideErrors,
} from "@fusion/ui";
import { LockClosedIcon } from "@heroicons/react/20/solid";
import { zodResolver } from "@hookform/resolvers/zod";
import { GetServerSideProps, NextPage } from "next";
import Image from "next/image";
import { useRouter } from "next/router";
import { ParsedUrlQuery } from "querystring";
import { useForm } from "react-hook-form";
import { useTranslation } from "react-i18next";
import { z } from "zod";
import BrandBackground from "../components/BrandBackground";
import Logo from "../public/logo.png";
import { routes } from "../routes";
import AccountService, { ResetPasswordReq } from "../services/AccountService";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const { query } = context as { query: ParsedUrlQuery };

  return {
    props: {
      email: query.email,
      code: query.code,
    },
  };
};

type ResetPasswordProps = {
  code: string;
  email: string;
};

const ResetPassword: NextPage<ResetPasswordProps> = ({ code, email }) => {
  const router = useRouter();
  const { t } = useTranslation("ResetPasswordScreen");

  const resetPasswordSchema = z
    .object({
      email: z
        .string({
          required_error: t("EmailValidationMessage"),
        })
        .email(t("EmailValidationMessage")),
      newPassword: z
        .string({
          required_error: t("NewPasswordValidationMessage"),
        })
        .min(1, { message: t("NewPasswordValidationMessage") }),
      confirmPassword: z
        .string({
          required_error: t("ConfirmPasswordValidationMessage"),
        })
        .min(1, { message: t("ConfirmPasswordValidationMessage") }),
    })
    .refine((data) => data.newPassword === data.confirmPassword, {
      message: t("PasswordsDontMatchValidationMessage"),
      path: ["confirmPassword"],
    });

  type ValidationSchema = z.infer<typeof resetPasswordSchema>;

  const { errors, setErrors, clearErrors } =
    useServerSideErrors<ValidationSchema>();

  const {
    control,
    handleSubmit,
    formState: { isSubmitting },
  } = useForm<ValidationSchema>({
    defaultValues: {
      email: email,
      newPassword: "",
      confirmPassword: "",
    },
    resolver: zodResolver(resetPasswordSchema),
  });

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearErrors();
      try {
        const dto: ResetPasswordReq = {
          email: data.email,
          password: data.newPassword,
          confirmPassword: data.confirmPassword,
          code: code,
        };
        await AccountService.resetPassword(dto);
        router.push(routes.RESET_PASSWORD_CONFIRMATION);
      } catch (error) {
        setErrors(error);
      }
    },
    (error, event) => {
      event?.preventDefault();
    }
  );

  return (
    <>
      <div className="tw-flex tw-w-full tw-min-h-full">
        <BrandBackground />
        <div className="tw-flex tw-flex-1 tw-min-w-[50%] tw-flex-col tw-justify-center tw-py-12 tw-px-4 sm:tw-px-6 lg:tw-flex-none lg:tw-px-20 xl:tw-px-24">
          <div className="tw-mx-auto tw-w-full tw-max-w-sm lg:tw-w-96">
            <div className="tw-flex tw-flex-col tw-justify-center">
              <Image
                className="tw-h-12 tw-w-auto tw-object-contain"
                src={Logo}
                alt="Your Company"
              />
            </div>
            <h2 className="tw-mt-6 tw-text-3xl tw-font-bold tw-tracking-tight tw-text-gray-900">
              {t("ResetPasswordTitle")}
            </h2>
            <div className="tw-mt-8">
              <div className="tw-mt-6 tw-space-y-6">
                <Form>
                  <Input
                    id="email"
                    name="email"
                    control={control}
                    type="email"
                    disabled
                    defaultValue={email}
                    LabelComponent={<FormLabel>{t("EmailLabel")}</FormLabel>}
                    errors={errors}
                  />
                  <Input
                    name="newPassword"
                    control={control}
                    type="password"
                    iconLeft={
                      <LockClosedIcon width={20} height={20}></LockClosedIcon>
                    }
                    LabelComponent={
                      <FormLabel required>{t("NewPasswordLabel")}</FormLabel>
                    }
                    errors={errors}
                  />
                  <Input
                    name="confirmPassword"
                    control={control}
                    type="password"
                    iconLeft={<LockClosedIcon width={20} height={20} />}
                    LabelComponent={
                      <FormLabel required>
                        {t("ConfirmPasswordLabel")}
                      </FormLabel>
                    }
                    errors={errors}
                  />

                  {/* Show general errors that are not related to any specific field */}
                  <div className="errors">
                    <FormServerSideErrors errors={errors} fieldKey={""} />
                  </div>

                  <div className="tw-flex tw-justify-end">
                    <Button
                      onClick={onSubmit}
                      disabled={isSubmitting}
                      loading={isSubmitting}
                      loadingMessage={t("ButtonLoadingMessage")}
                    >
                      {t("Save")}
                    </Button>
                  </div>
                </Form>
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default ResetPassword;


### pages/track/index.tsx ###
import { GetServerSideProps, NextPage } from "next";

import Totem from "../../components/track/Totem";
import Checking from "../../components/track/Checking";
import { roles } from "../../roles";
import AccountService from "../../services/AccountService";
import { ToastContainer, useToast } from "@fusion/ui";
import "react-toastify/dist/ReactToastify.css";
import { useUserStore } from "../../stores/UserStore";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [
    roles.FrontSuperAdministrator,
    roles.FrontFrontManualSigning,
    roles.FrontSystemUser,
    roles.FrontFrontHumanCapital,
  ];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );

  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }
  return { props: {} };
};

const Track: NextPage = () => {
  const store = useUserStore();

  const showTotem = store.roles
    ? store.roles.includes(roles.FrontFrontManualSigning)
    : false;

  return (
    <>
      {showTotem ? <Totem /> : <Checking />}
      <ToastContainer />
    </>
  );
};

export default Track;


### pages/tracking/index.tsx ###
import {
  Button,
  Column,
  Form,
  FormLabel,
  Input,
  PageHeader,
  useServerSideErrors,
} from "@fusion/ui";
import AccountService from "../../services/AccountService";
import { useTranslation } from "react-i18next";
import { roles } from "../../roles";
import { GetServerSideProps } from "next";
import useNetworkErrorHandler from "../../hooks/useNetworkErrorHandler";
import { useEffect, useState } from "react";
import { Summary, TotalItem } from "devextreme-react/data-grid";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { DataGridLocal } from "../../components/DataGridLocal";
import UserEntryService from "../../services/UserEntryService";
import { useUserStore } from "../../stores/UserStore";
import { TimeHelper } from "../../helpers/TimeHelper";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [roles.FrontFrontHumanCapital, roles.FrontSystemUser];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );

  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }
  return { props: {} };
};

type FormValues = {
  dateFrom: string;
  dateTo: string;
};

const Trackings = () => {
  const { t } = useTranslation("ReportListScreen");
  const baseUrlReport = `/api/UserEntry/get-users-working-hour?format=dx`;
  const [reportUrl, setReportUrl] = useState<string>();
  const [totalHours, setTotalHours] = useState<string>();
  const { handleError } = useNetworkErrorHandler();

  const [formData, setFormData] = useState<FormValues>();
  const {
    errors,
    setErrors,
    clearErrors: clearServerErrors,
  } = useServerSideErrors<FormValues>();
  const store = useUserStore();

  const getTotalHours = async () => {
    try {
      const result = await UserEntryService.getUserReportData(
        store.id,
        formData?.dateFrom,
        formData?.dateTo
      );

      let totalHours: number = 0;
      result.map(
        (reportData) =>
          (totalHours += TimeHelper.timeStringToMinutes(reportData.totalHour))
      );

      setTotalHours(TimeHelper.formatMinutes(totalHours));
    } catch (error) {
      handleError(error);
    }
  };

  useEffect(() => {
    if (formData) {
      let url = `${baseUrlReport}&userId=${store.id}&dateStart=${formData?.dateFrom}&dateEnd=${formData?.dateTo}`;
      setReportUrl(url);
      getTotalHours();
    } else {
      setReportUrl(
        `${baseUrlReport}&userId=${store.id}&dateFrom=1000-01-01&dateTo=1000-01-01`
      );
    }
  }, [formData]);

  const validationSchema = z.object({
    dateFrom: z.string({
      required_error: t("DateFromRequiredValidationMessage"),
    }),
    dateTo: z.string({
      required_error: t("DateToRequiredValidationMessage"),
    }),
  });

  type ValidationSchema = z.infer<typeof validationSchema>;
  const {
    control,
    handleSubmit,
    formState: { errors: clientErrors, isSubmitting },
    clearErrors: clearClientErrors,
  } = useForm<ValidationSchema>({
    defaultValues: {},
    resolver: zodResolver(validationSchema),
  });

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearServerErrors();
      try {
        setFormData({
          dateFrom: data.dateFrom,
          dateTo: data.dateTo,
        });
      } catch (error) {
        setErrors(error);
        console.error("An unexpected error happened:", error);
      }
    },
    (error, event) => {
      event?.preventDefault();
      handleError(error);
    }
  );

  return (
    <>
      {/* Header */}
      <PageHeader title={t("TitleTrackings")}></PageHeader>
      {/* Filter Form */}
      <Form>
        <div className="tw-grid tw-grid-cols-4 tw-gap-4">
          <Input
            name="dateFrom"
            defaultValue={formData?.dateFrom}
            control={control}
            type="date"
            errors={errors}
            required
            LabelComponent={<FormLabel>{t("DateFromLabel")}</FormLabel>}
          ></Input>
          <Input
            name="dateTo"
            defaultValue={formData?.dateTo}
            control={control}
            type="date"
            errors={errors}
            required
            LabelComponent={<FormLabel>{t("DateToLabel")}</FormLabel>}
          ></Input>
          <div>
            <Button
              onClick={onSubmit}
              disabled={isSubmitting}
              loading={isSubmitting}
            >
              {t("Search")}
            </Button>
          </div>
        </div>
      </Form>
      {/* Grid */}
      {/* Column definitions */}
      <DataGridLocal url={reportUrl} enableRowAlternation={false}>
        <Column
          name={"date"}
          dataField={"date"}
          caption={t("DateColumnLabel")}
          dataType="date"
        />
        <Column
          name={"totalHour"}
          dataField={"totalHour"}
          caption={t("TotalHoursColumnLabel")}
          dataType="string"
        />
        <Column
          name={"comments"}
          dataField={"comments"}
          caption={t("CommentsColumnLabel")}
          dataType="string"
        ></Column>
        <Summary>
          <TotalItem
            showInColumn="date"
            column="totalHour"
            summaryType="sum"
            // valueFormat="number"
            displayFormat={t("TotalHoursColumnLabel") + ": " + totalHours}
          />
        </Summary>
      </DataGridLocal>
      {/* End Column definitions */}
    </>
  );
};

export default Trackings;


### pages/user/[...slug].tsx ###
import {
  Button,
  DatePicker,
  Form,
  FormLabel,
  FormServerSideErrors,
  Input,
  Select,
  Switch,
  useServerSideErrors,
} from "@fusion/ui";
import { zodResolver } from "@hookform/resolvers/zod";
import { GetServerSideProps, NextPage } from "next";
import { useRouter } from "next/router";
import { memo, useEffect, useRef, useState } from "react";
import {Controller, useForm} from "react-hook-form";
import { useTranslation } from "react-i18next";
import { z } from "zod";
import { UserReq, UserRes } from "../../services/FrontUserService";
import useNetworkErrorHandler from "../../hooks/useNetworkErrorHandler";
import AccountService from "../../services/AccountService";
import { roles } from "../../roles";
import CompanyService from "../../services/CompanyService";
import FrontUserService from "../../services/FrontUserService";
import { useUserStore } from "../../stores/UserStore";
import CalendarService from "../../services/CalendarService";
import TimeZoneService from "../../services/TimeZoneService";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [
    roles.FrontSuperAdministrator,
    roles.FrontFrontHumanCapital,
  ];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );
  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }

  const { slug } = context.query;

  if (!slug) return { props: {} };

  if (slug?.length === 1 && slug[0] === "create")
    return {
      props: {
        mode: "create",
      },
    };

  if (slug?.length > 1 && slug[0] === "edit") {
    const userId = slug[1];
    const { data: user, cookies } = await FrontUserService.getById(
      userId,
      context.req.cookies
    );

    cookies && context.res.setHeader("Set-Cookie", cookies);

    return {
      props: {
        user,
        mode: "edit",
      },
    };
  }

  return { props: {} };
};

type UserCreateOrEditProps = {
  user?: UserReq;
  mode: "create" | "edit";
};

type CompanyOption = {
  name: string;
  value: string;
};

type CalendarOption = {
  name: string;
  value: string;
};
type TimeZoneOption = {
    name: string;
    value: string;
};

const UserCreateOrEdit: NextPage<UserCreateOrEditProps> = (props) => {
  const { user, mode } = props;
  const { t } = useTranslation("UserCreateOrEditScreen");
  const { errors, setErrors, clearErrors } = useServerSideErrors<UserRes>();
  const { handleError } = useNetworkErrorHandler();
  const router = useRouter();
  const firstMount = useRef<boolean>(true);
  const [companies, setCompanies] = useState<CompanyOption[]>();
  const [calendars, setCalendars] = useState<CalendarOption[]>();
  const [timeZones, setTimeZones] = useState<TimeZoneOption[]>();
  const [selectedRol, setSelectedRol] = useState<string>();
  const store = useUserStore();

  const roleItems = () => {
    const roleOptions = Object.values(roles).map((role) => ({
      value: role,
      name: t(role.split(".")[1], {
        ns: "Roles",
      }),
    }));
    const filteredRoles = roleOptions.filter(
      (c) => c.value !== roles.FrontSuperAdministrator
    );

    return filteredRoles;
  };

  const validationSchema = z
    .object({
      name: z
        .string({
          required_error: t("NameRequiredValidationMessage"),
        })
        .refine(
          (value) => {
            return value.trim() !== "";
          },
          { message: t("NameRequiredValidationMessage") }
        ),
      lastName: z
        .string({
          required_error: t("SurnameRequiredValidationMessage"),
        })
        .refine(
          (value) => {
            return value.trim() !== "";
          },
          { message: t("SurnameRequiredValidationMessage") }
        ),
      email: z
        .string({
          required_error: t("EmailRequiredValidationMessage"),
        })
        .email({ message: t("MustBeEmailMessage") }),
      phoneNumber: z
        .string({
          required_error: t("TelephoneRequiredValidationMessage"),
        })
        .max(50, {
          message: t("MaxLengthValidationMessage", { maxLength: 100 }),
        })
        .refine(
          (value) => {
            return value.trim() !== "";
          },
          { message: t("TelephoneRequiredValidationMessage") }
        )
        .refine(
          (value) => {
            const trimmedValue = value.replace("-", " ").split(" ").join("");
            return /^[+]?\d+$/.test(trimmedValue);
          },
          { message: t("InvalidTelephone") }
        ),
      address: z
        .string({
          required_error: t("AddressRequiredValidationMessage"),
        })
        .refine(
          (value) => {
            return value.trim() !== "";
          },
          { message: t("AddressRequiredValidationMessage") }
        ),
      postalCode: z
        .string({
          required_error: t("PostalCodeRequiredValidationMessage"),
        })
        .refine(
          (value) => {
            return value.trim() !== "";
          },
          { message: t("PostalCodeRequiredValidationMessage") }
        ),
      city: z
        .string({
          required_error: t("CityRequiredValidationMessage"),
        })
        .refine(
          (value) => {
            return value.trim() !== "";
          },
          { message: t("CityRequiredValidationMessage") }
        ),
      country: z
        .string({
          required_error: t("CountryRequiredValidationMessage"),
        })
        .refine(
          (value) => {
            return value.trim() !== "";
          },
          { message: t("CountryRequiredValidationMessage") }
        ),
      birthdate:
        mode == "create"
          ? z.date({
              required_error: t("BirthDateRequiredValidationMessage"),
            })
          : z.string().optional(),
      tenantID: z.string({
        required_error: t("CompanyRequiredValidationMessage"),
      }),
      calendarId:
        selectedRol == roles.FrontSystemUser
          ? z.string({
              required_error: t("CalendarRequiredValidationMessage"),
            })
          : z
              .string({
                required_error: t("CalendarRequiredValidationMessage"),
              })
              ,
      entryKey: z.string().optional(),
      dni: z
        .string({
          required_error: t("DniRequiredValidationMessage"),
        })
        .refine(
          (value) => {
            return value.trim() !== "";
          },
          { message: t("DniRequiredValidationMessage") }
        ),
      roles: z.string({
        required_error: t("RolesRequiredValidationMessage"),
      }),
      inactive: z.boolean(),
      userType: z.string().optional(),
      timeZoneId: z.string({required_error: t("TimeZoneRequiredMessage")}).min(1, { message: t("TimeZoneRequiredMessage") }),
      confirmEmailCallback: z
        .string({
          required_error: t("ConfirmEmailCallbackRequiredValidationMessage"),
        })
        .refine(
          (value) => {
            return value.trim() !== "";
          },
          { message: t("ConfirmEmailCallbackRequiredValidationMessage") }
        ),
    })
    .refine((data) => data.email === data.confirmEmailCallback, {
      message: t("EmailMismatchValidationMessage"),
      path: ["confirmEmailCallback"],
    });

  type ValidationSchema = z.infer<typeof validationSchema>;

  const {
    control,
    handleSubmit,
    formState: { isSubmitting },
    getValues,
    setValue
  } = useForm<ValidationSchema>({
    defaultValues: user
      ? {
          name: user.name,
          lastName: user.lastName,
          email: user.email,
          entryKey: user.entryKey,
          dni: user.dni,
          phoneNumber: user.phoneNumber,
          address: user.address,
          postalCode: user.postalCode,
          city: user.city,
          country: user.country,
          birthdate: user.birthdate,
          roles: user.roles ? user.roles[0] : "",
          inactive: user.inactive,
          tenantID:  user.tenantID,
          calendarId: user.calendarId,
          userType: user.userType ?? "front_user",
          confirmEmailCallback: user.email,
          timeZoneId: user.timeZoneId,
        }
      : {
          inactive: false,
          tenantID:  (store.roles && store.roles.includes(roles.FrontFrontHumanCapital))? store.tenantId : "" ,
          timeZoneId:  timeZones? timeZones[0].value : ""
        },
    resolver: zodResolver(validationSchema),
  });

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearErrors();
      try {
        const dto = {
          id: user?.id,
          name: data.name,
          lastName: data.lastName,
          email: data.email,
          entryKey: data.entryKey,
          dni: data.dni,
          phoneNumber: data.phoneNumber,
          address: data.address,
          postalCode: data.postalCode,
          city: data.city,
          country: data.country,
          birthdate: data.birthdate,
          roles: [data.roles],
          inactive: data.inactive,
          tenantID: data.tenantID,
          userType: data.userType,
          confirmEmailCallback: data.confirmEmailCallback,
          calendarId: data.calendarId,
          timeZoneId: data.timeZoneId,
        };
        mode === "edit"
          ? user?.id && (await FrontUserService.update(user.id, dto))
          : await FrontUserService.create(dto);
        router.back();
      } catch (error) {
        setErrors(error);
        console.error("An unexpected error happened:", error);
      }
    },
    (error, event) => {
      event?.preventDefault();
    }
  );

  const getCompanies = async () => {
    try {
      const result = await CompanyService.getAll();
      const companies = result.items.map((c) => ({
        value: c.id ?? "",
        name: c.name,
      }));
      setCompanies(companies);
    } catch (error) {
      handleError(error);
    }
  };

  const getCalendars = async (tenantId?:string) => {
    try {

      const result = await CalendarService.getAllByTenantId({
          page:1,
          pageSize:20,
          tenantId:store.roles && store.roles.includes(roles.FrontFrontHumanCapital)? store.tenantId : tenantId
      })

      const calendars = result.items.map((c) => ({
        value: c.id ?? "",
        name: c.name,
      }));
      setCalendars(calendars);
    } catch (error) {
      handleError(error);
    }
  };

    const getTimeZones = async () => {
        try {

            const result: any = await TimeZoneService.getAll();

            const timeZoneList = result.map((c: any) => ({
                value: c.id ?? "",
                name: c.name,
            }));
            setTimeZones(timeZoneList);
        } catch (error) {
            handleError(error);
        }
    };

  useEffect(() => {
    if (firstMount.current) {
      firstMount.current = false;
      getCompanies();
      if (store.roles && store.roles.includes(roles.FrontFrontHumanCapital)){
          getCalendars();
      }
        getTimeZones();
      user?.roles && user.roles.length > 0 && setSelectedRol(user.roles[0]);
    }
  }, []);
    useEffect(() => {

        if (!user && timeZones && timeZones.length > 0) {
            setValue("timeZoneId", timeZones[0].value); // Set to first time zone
        }
    }, [timeZones, user, setValue]);
  const onCancel = () => {
    router.back();
  };

  return (
    <div className="tw-pb-4">
      <h1 className="tw-text-3xl tw-font-bold lg:tw-mt-12 tw-mb-4">
        {mode === "create" ? t("NewTitle") : t("EditTitle")}
      </h1>
      <div className="tw-bg-white tw-px-6 tw-py-3 tw-border-2 shadow tw-border-gray-200 tw-w-full lg:tw-max-w-[705px]">
        <Form>
          <Input
            name="name"
            defaultValue={user?.name}
            control={control}
            type="text"
            placeholder={t("NamePlaceholder")}
            LabelComponent={<FormLabel>{t("NameLabel")}</FormLabel>}
            errors={errors}
          />
          <Input
            name="lastName"
            defaultValue={user?.lastName}
            control={control}
            type="text"
            placeholder={t("SurnamePlaceholder")}
            LabelComponent={<FormLabel>{t("SurnameLabel")}</FormLabel>}
            errors={errors}
          />
          <Input
            name="dni"
            defaultValue={user?.dni}
            control={control}
            type="text"
            placeholder={t("DniPlaceholder")}
            LabelComponent={<FormLabel>{t("DniLabel")}</FormLabel>}
            errors={errors}
          />
          <Input
            name="email"
            defaultValue={user?.email}
            control={control}
            type="text"
            disabled={mode != "create" ? true : false}
            placeholder={t("EmailPlaceholder")}
            LabelComponent={<FormLabel>{t("EmailLabel")}</FormLabel>}
            errors={errors}
          />
          <Input
            name="confirmEmailCallback"
            defaultValue={user?.confirmEmailCallback}
            control={control}
            type="text"
            disabled={mode != "create" ? true : false}
            placeholder={t("ConfirmEmailCallbackPlaceholder")}
            LabelComponent={
              <FormLabel>{t("ConfirmEmailCallbackLabel")}</FormLabel>
            }
            errors={errors}
          />
          <Input
            name="phoneNumber"
            defaultValue={user?.phoneNumber}
            control={control}
            type="text"
            disabled={false}
            placeholder={t("TelephonePlaceholder")}
            LabelComponent={
              <FormLabel required>{t("TelephoneLabel")}</FormLabel>
            }
            errors={errors}
          />
          <Input
            name="address"
            defaultValue={user?.address}
            control={control}
            type="text"
            LabelComponent={<FormLabel required>{t("AddressLabel")}</FormLabel>}
            placeholder={t("AddressPlaceholder")}
            errors={errors}
          ></Input>
          <Input
            name="postalCode"
            defaultValue={user?.postalCode}
            control={control}
            type="text"
            LabelComponent={
              <FormLabel required>{t("PostalCodeLabel")}</FormLabel>
            }
            placeholder={t("PostalCodePlaceholder")}
            errors={errors}
          ></Input>
          <Input
            name="city"
            defaultValue={user?.city}
            control={control}
            type="text"
            LabelComponent={<FormLabel required>{t("CityLabel")}</FormLabel>}
            placeholder={t("CityPlaceholder")}
            errors={errors}
          ></Input>
          <Input
            name="country"
            defaultValue={user?.country}
            control={control}
            type="text"
            LabelComponent={<FormLabel required>{t("CountryLabel")}</FormLabel>}
            placeholder={t("CountryPlaceholder")}
            errors={errors}
          ></Input>
          <DatePicker
            type="date"
            control={control}
            defaultValue={user?.birthdate}
            placeholder={t("BirthdatePlaceholder")}
            LabelComponent={
              <FormLabel required={false}>{t("BirthdateLabel")}</FormLabel>
            }
            name="birthdate"
            useMaskBehavior={true}
            errors={errors}
            disabled={mode != "create" ? true : false}
          ></DatePicker>
          <Select
            multiple={false}
            LabelComponent={<FormLabel required>{t("CompanyLabel")}</FormLabel>}
            name="tenantID"
            placeholder={t("CompanyPlaceholder")}
            control={control}
            searchEnabled={false}
            displayExpr={"name"}
            valueExpr={"value"}
            items={
              store.roles && store.roles.includes(roles.FrontSuperAdministrator)
                ? companies
                : companies?.filter((c) => c.value === store.tenantId)
            }
            errors={errors}
            disabled={store.roles && !store.roles.includes(roles.FrontSuperAdministrator)}
            onSelectionChanged={(e)=>{
                getCalendars(e.selectedItem.value);
            }}
          />
          <Select
            onValueChange={() => setSelectedRol(getValues("roles"))}
            multiple={false}
            LabelComponent={<FormLabel required>{t("RolesLabel")}</FormLabel>}
            name="roles"
            placeholder={t("RolesPlaceholder")}
            defaultValue={user?.roles}
            control={control}
            searchEnabled={false}
            displayExpr={"name"}
            valueExpr={"value"}
            items={roleItems()}
            errors={errors}
            disabled={mode != "create" ? true : false}
          />
          <Select
            multiple={false}
            LabelComponent={
              <FormLabel required>{t("CalendarLabel")}</FormLabel>
            }
            name="calendarId"
            placeholder={t("CalendarPlaceholder")}
            defaultValue={user?.calendarId}
            control={control}
            searchEnabled={false}
            displayExpr={"name"}
            valueExpr={"value"}
            items={calendars}
            errors={errors}
          />
            <Select
                multiple={false}
                LabelComponent={
                    <FormLabel required>{t("TimeZoneLabel")}</FormLabel>
                }
                name="timeZoneId"
                placeholder={t("TimeZonePlaceHolder")}
                control={control}
                searchEnabled={true}
                displayExpr={"name"}
                valueExpr={"value"}
                items={timeZones}
                errors={errors}
            />

          <Switch
            name="inactive"
            control={control}
            defaultChecked={user?.inactive}
            LabelComponent={<FormLabel>{t("InactiveLabel")}</FormLabel>}
            errors={errors}
          ></Switch>
          <div className="errors">
            {errors && Object.keys(errors).length > 0 ? (
              <FormServerSideErrors errors={errors} fieldKey={""} />
            ) : null}
          </div>

          <div className="tw-py-4">
            <div className="tw-flex tw-justify-end tw-gap-2">
              <Button
                variant="secondary"
                disabled={isSubmitting}
                onClick={() => {
                  onCancel();
                }}
              >
                {t("Cancel")}
              </Button>
              <Button
                onClick={onSubmit}
                disabled={isSubmitting}
                loading={isSubmitting}
              >
                {t("Save")}
              </Button>
            </div>
          </div>
        </Form>
      </div>
    </div>
  );
};

export default memo(UserCreateOrEdit);


### pages/user/details/[id].tsx ###
import {
  Button,
  DatePicker,
  FormLabel,
  Input,
  PageHeader,
  Select,
  Switch,
} from "@fusion/ui";
import { GetServerSideProps, NextPage } from "next";
import { useRouter } from "next/router";
import { useEffect, useRef, useState } from "react";
import { useTranslation } from "react-i18next";
import { UserRes } from "../../../services/FrontUserService";
import useNetworkErrorHandler from "../../../hooks/useNetworkErrorHandler";
import AccountService from "../../../services/AccountService";
import { roles } from "../../../roles";
import FrontUserService from "../../../services/FrontUserService";
import CompanyService from "../../../services/CompanyService";
import CalendarService from "../../../services/CalendarService";

type Params = {
  id: string;
};

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [
    roles.FrontSuperAdministrator,
    roles.FrontFrontHumanCapital,
    roles.FrontFrontObserver,
  ];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );
  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }

  const { id } = context.params as Params;

  if (!id) return { props: {} };

  const { data: user, cookies } = await FrontUserService.getById(
    id,
    context.req.cookies
  );
  cookies && context.res.setHeader("Set-Cookie", cookies);

  return {
    props: {
      user,
    },
  };
};

type UserDetailsProps = {
  user?: UserRes;
};

type SelectOption = {
  name: string;
  value: string;
};

const UserDetails: NextPage<UserDetailsProps> = (props) => {
  const { user } = props;
  const router = useRouter();
  const { handleError } = useNetworkErrorHandler();
  const firstMount = useRef<boolean>(true);
  const [companies, setCompanies] = useState<SelectOption[]>();
  const [calendars, setCalendars] = useState<SelectOption[]>();

  const { t } = useTranslation("UserDetailsScreen");

  const onCancel = () => {
    router.back();
  };

  const getCompanies = async () => {
    try {
      const result = await CompanyService.getAll();
      const companies = result.items.map((c) => ({
        value: c.id ?? "",
        name: c.name,
      }));
      setCompanies(companies);
    } catch (error) {
      handleError(error);
    }
  };

  const getCalendars = async () => {
    try {
      const result = await CalendarService.getAll();
      const calendars = result.items.map((c) => ({
        value: c.id ?? "",
        name: c.name,
      }));
      setCalendars(calendars);
    } catch (error) {
      handleError(error);
    }
  };

  useEffect(() => {
    if (firstMount.current) {
      firstMount.current = false;
      getCompanies();
      getCalendars();
    }
  }, []);

  const roleItems = () => {
    const roleOptions = Object.values(roles).map((role) => ({
      value: role,
      name: t(role.split(".")[1], {
        ns: "Roles",
      }),
    }));
    const filteredRoles = roleOptions.filter(
      (c) => c.value !== roles.FrontSuperAdministrator
    );

    return filteredRoles;
  };

  if (!user) return null;

  return (
    <div className="tw-flex tw-flex-col tw-gap-4">
      <PageHeader title={user.name + " " + user.lastName}></PageHeader>
      <div className="tw-flex tw-flex-col tw-bg-white tw-px-6 tw-gap-4 tw-py-4 tw-border-2 shadow tw-border-gray-200 tw-w-full lg:tw-max-w-[705px]">
        <Input
          name="dni"
          type="text"
          LabelComponent={<FormLabel>{t("DniLabel")}</FormLabel>}
          value={user?.dni}
          disabled
        />
        <Input
          name="email"
          type="text"
          placeholder={t("EmailPlaceholder")}
          LabelComponent={<FormLabel>{t("EmailLabel")}</FormLabel>}
          disabled
          value={user?.email}
        />
        <Input
          name="phoneNumber"
          type="text"
          disabled
          LabelComponent={<FormLabel>{t("TelephoneLabel")}</FormLabel>}
          value={user?.phoneNumber}
        />
        <Input
          name="address"
          type="text"
          LabelComponent={<FormLabel required>{t("AddressLabel")}</FormLabel>}
          disabled
          value={user?.address}
        ></Input>
        <Input
          name="postalCode"
          type="text"
          LabelComponent={
            <FormLabel required>{t("PostalCodeLabel")}</FormLabel>
          }
          disabled
          value={user?.postalCode}
        ></Input>
        <Input
          name="city"
          type="text"
          LabelComponent={<FormLabel required>{t("CityLabel")}</FormLabel>}
          disabled
          value={user?.city}
        ></Input>
        <Input
          name="country"
          type="text"
          LabelComponent={<FormLabel required>{t("CountryLabel")}</FormLabel>}
          disabled
          value={user?.country}
        ></Input>
        <DatePicker
          type="date"
          name="birthdate"
          LabelComponent={
            <FormLabel required={false}>{t("BirthdateLabel")}</FormLabel>
          }
          useMaskBehavior={true}
          disabled
          value={user?.birthdate}
        ></DatePicker>
        <Select
          multiple={false}
          LabelComponent={<FormLabel required>{t("CompanyLabel")}</FormLabel>}
          name="tenantID"
          displayExpr={"name"}
          valueExpr={"value"}
          items={companies}
          disabled
          value={user?.tenantID}
        />
        <Select
          multiple={false}
          LabelComponent={<FormLabel required>{t("RolesLabel")}</FormLabel>}
          name="roles"
          displayExpr={"name"}
          valueExpr={"value"}
          items={roleItems()}
          disabled
          value={user?.roles && user?.roles[0]}
        />
        <Select
          multiple={false}
          LabelComponent={<FormLabel required>{t("CalendarLabel")}</FormLabel>}
          name="calendarId"
          searchEnabled={false}
          displayExpr={"name"}
          valueExpr={"value"}
          items={calendars}
          disabled
          value={user?.calendarId}
        />
        <Switch
          name="inactive"
          LabelComponent={<FormLabel>{t("InactiveLabel")}</FormLabel>}
          disabled
          checked={user?.inactive}
        ></Switch>
        <div className="tw-flex tw-justify-end tw-gap-2">
          <Button
            variant="secondary"
            onClick={() => {
              onCancel();
            }}
          >
            {t("GoBack")}
          </Button>
        </div>
      </div>
    </div>
  );
};

export default UserDetails;


### pages/user/index.tsx ###
import {
  Button,
  Checkbox,
  Column,
  DataGrid,
  PageHeader,
  RedirectButton,
} from "@fusion/ui";
import { DataGridColumnInformation } from "@fusion/utils";
import { EyeIcon, PlusIcon, ClockIcon } from "@heroicons/react/20/solid";
import Link from "next/link";
import { useRouter } from "next/router";
import { useTranslation } from "react-i18next";
import UserService, { UserPage } from "../../services/FrontUserService";
import { DefaultActionButtons } from "../../components/DefaultActionButtons";
import useNetworkErrorHandler from "../../hooks/useNetworkErrorHandler";
import { GetServerSideProps, NextPage } from "next";
import AccountService from "../../services/AccountService";
import { roles } from "../../roles";
import { useUserStore } from "../../stores/UserStore";
import FrontUserService from "../../services/FrontUserService";

export const getServerSideProps: GetServerSideProps = async (context) => {
  try {
    const requiredRoles = [
      roles.FrontSuperAdministrator,
      roles.FrontFrontHumanCapital,
      roles.FrontFrontObserver,
    ];
    const { isAuthorized } = await AccountService.authorize(
      requiredRoles,
      context.req.cookies
    );

    const user = await UserService.getAll({
      page: 1,
      pageSize: 1,
      cookies: context.req.cookies,
    });

    if (!isAuthorized) {
      return {
        redirect: {
          destination: `/401`,
          permanent: false,
        },
      };
    }
    return { props: { user } };
  } catch (error) {
    return {
      redirect: {
        destination: `/500`,
        permanent: false,
      },
    };
  }
};

type UsersProps = {
  user: UserPage;
};

const Users: NextPage<UsersProps> = (props) => {
  const router = useRouter();
  const { t } = useTranslation("UserListScreen");
  const { handleError } = useNetworkErrorHandler();
  const getUsersUrl = `/api/frontUser/list?format=dx`;
  const { user } = props;
  const store = useUserStore();

  const deleteUserById = async (id: string) => {
    try {
      await FrontUserService.delete(id);
      router.push("/user");
    } catch (error) {
      handleError(error);
    }
  };

  const canCreateUser = (item: UserPage) => {
    return (
      item.links.some((a) => a.rel === "Create") &&
      store.roles &&
      store.roles.some((role) =>
        [roles.FrontSuperAdministrator, roles.FrontFrontHumanCapital].includes(
          role
        )
      )
    );
  };

  return (
    <>
      <PageHeader title={t("Title")}>
        {canCreateUser(user) ? (
          <Button
            onClick={() => router.push("/user/create")}
            iconLeft={<PlusIcon className="tw-h-3 tw-w-3"></PlusIcon>}
          >
            {t("Create")}
          </Button>
        ) : undefined}
      </PageHeader>

      <DataGrid url={getUsersUrl} enableRowAlternation={false}>
        <Column
          name={"lastName"}
          dataField={"lastName"}
          dataType="string"
          caption={t("LastNameColumnLabel")}
        />
        <Column
          name={"email"}
          dataField={"email"}
          dataType="string"
          caption={t("EmailColumnLabel")}
        />
        <Column
          name={"entryKey"}
          dataField={"entryKey"}
          dataType="string"
          caption={t("EntryKeyColumnLabel")}
        />
        <Column
          name={"dni"}
          dataField={"dni"}
          dataType="string"
          caption={t("DniColumnLabel")}
        />
        <Column
          name={"phoneNumber"}
          dataField={"phoneNumber"}
          dataType="string"
          caption={t("TelephoneColumnLabel")}
        />
        <Column
          name={"address"}
          dataField={"address"}
          dataType="string"
          caption={t("AddressColumnLabel")}
        />
        <Column
          name={"postalCode"}
          dataField={"postalCode"}
          dataType="string"
          caption={t("PostalCodeColumnLabel")}
        />
        <Column
          name={"city"}
          dataField={"city"}
          dataType="string"
          caption={t("CityColumnLabel")}
        />
        <Column
          name={"country"}
          dataField={"country"}
          dataType="string"
          caption={t("CountryColumnLabel")}
        />
        <Column
          name={"inactive"}
          dataField={"inactive"}
          caption={t("InactiveColumnLabel")}
          cellRender={(info) => (
            <Checkbox name="inactive" disabled checked={info.value}></Checkbox>
          )}
          dataType="boolean"
        />
        <Column
          allowFiltering={false}
          allowReordering={false}
          dataField={t("ActionButtons", {
            ns: "Gridview",
          })}
          cellRender={(info: DataGridColumnInformation<null>) =>
            !canCreateUser(user) ? (
              <div className="tw-flex tw-items-center tw-justify-start">
                <RedirectButton
                  LinkComponent={Link}
                  tooltip={t("WorkingHoursActionButtonLabel", {
                    ns: "Gridview",
                  })}
                  _buttonProps={{
                    variant: "tertiary",
                  }}
                  iconLeft={
                    <ClockIcon
                      className="tw-h-5 tw-w-5"
                      fill="#799452"
                    ></ClockIcon>
                  }
                  url={`/user/user-working-hours/${info.row.data.id}`}
                ></RedirectButton>
                <RedirectButton
                  LinkComponent={Link}
                  tooltip={t("DetailsActionButtonLabel", {
                    ns: "Gridview",
                  })}
                  _buttonProps={{
                    variant: "tertiary",
                  }}
                  iconLeft={
                    <EyeIcon className="tw-h-5 tw-w-5" fill="#799452"></EyeIcon>
                  }
                  url={`/user/details/${info.row.data.id}`}
                ></RedirectButton>
              </div>
            ) : (
              <div className="tw-flex tw-items-center tw-justify-start">
                <RedirectButton
                  LinkComponent={Link}
                  tooltip={t("WorkingHoursActionButtonLabel", {
                    ns: "Gridview",
                  })}
                  _buttonProps={{
                    variant: "tertiary",
                  }}
                  iconLeft={
                    <ClockIcon
                      className="tw-h-5 tw-w-5"
                      fill="#799452"
                    ></ClockIcon>
                  }
                  url={`/user/user-working-hours/${info.row.data.id}`}
                ></RedirectButton>
                <DefaultActionButtons
                  LinkComponent={Link}
                  info={info}
                  entityName="user"
                  locale={{
                    tooltips: {
                      edit: t("EditActionButtonLabel", {
                        ns: "Gridview",
                      }),
                      details: t("DetailsActionButtonLabel", {
                        ns: "Gridview",
                      }),
                      delete: t("DeleteActionButtonLabel", {
                        ns: "Gridview",
                      }),
                    },
                    delete: {
                      modalTitle: t("DeleteModalTitleLabel", {
                        ns: "Gridview",
                      }),
                      confirmLabel: t("DeleteModalConfirmButton", {
                        ns: "Gridview",
                      }),
                      cancelLabel: t("DeleteModalCancelButton", {
                        ns: "Gridview",
                      }),
                    },
                  }}
                  onDeleteConfirmed={async () => {
                    deleteUserById(info.row.data.id);
                  }}
                ></DefaultActionButtons>
              </div>
            )
          }
        />
      </DataGrid>
    </>
  );
};

export default Users;


### pages/user/user-working-hours/[id].tsx ###
import {
  Button,
  Column,
  DataGrid,
  DatePicker,
  Form,
  FormLabel,
  Modal,
  PageHeader,
  Select,
  Switch,
  useServerSideErrors,
} from "@fusion/ui";
import { GetServerSideProps, NextPage } from "next";
import { useRouter } from "next/router";
import { useEffect, useRef, useState } from "react";
import { useTranslation } from "react-i18next";
import { UserRes } from "../../../services/FrontUserService";
import useNetworkErrorHandler from "../../../hooks/useNetworkErrorHandler";
import AccountService from "../../../services/AccountService";
import { roles } from "../../../roles";
import FrontUserService from "../../../services/FrontUserService";
import WorkingHoursService from "../../../services/WorkingHoursService";
import { useUserStore } from "../../../stores/UserStore";
import { PlusIcon } from "@heroicons/react/20/solid";
import { WorkingHoursForm } from "../../../components/WorkingHoursForm";
import dynamic from "next/dynamic";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import UserWorkingHoursService, {
  UserWorkingHoursRes,
} from "../../../services/UserWorkingHoursService";
import { DataGridColumnInformation } from "@fusion/utils";
import { WeekDayBoxes } from "../../../components/WeekDayBoxes";
import { calculateHours } from "../../working-hours";
import { MultipleRangeValues } from "../../../components/Calendar";
import { DefaultActionButtons } from "../../../components/DefaultActionButtons";
import Link from "next/link";
import { DateHelper } from "../../../helpers/DateHelper";
const Calendar = dynamic(() => import("../../../components/Calendar"), {
  ssr: false,
});

type Params = {
  id: string;
};

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [
    roles.FrontSuperAdministrator,
    roles.FrontFrontHumanCapital,
    roles.FrontSystemUser,
    roles.FrontFrontObserver,
  ];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );
  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }

  const { id } = context.params as Params;

  if (!id) return { props: {} };

  const { data: user, cookies } = await FrontUserService.getById(
    id,
    context.req.cookies
  );
  cookies && context.res.setHeader("Set-Cookie", cookies);

  return {
    props: {
      user,
    },
  };
};

type UserCreateOrEditProps = {
  user?: UserRes;
};

type WorkingHoursOption = {
  name: string;
  value: string;
};

const UserWorkingHours: NextPage<UserCreateOrEditProps> = (props) => {
  const { user } = props;
  const router = useRouter();
  const { handleError } = useNetworkErrorHandler();
  const { errors, setErrors, clearErrors } =
    useServerSideErrors<UserWorkingHoursRes>();
  const getUserWorkingHoursUrl = `/api/UserWorkingHour?userId=${user?.id}&format=dx`;
  const store = useUserStore();
  const [showAssignModal, setShowAssignModal] = useState(false);
  const [showWorkingHoursModal, setShowWorkingHoursModal] = useState(false);
  const [workingHours, setWorkingHours] = useState<WorkingHoursOption[]>();
  const firstMount = useRef<boolean>(true);
  const { t } = useTranslation("UserWorkingHoursScreen");
  const [assignedWorkingHours, setAssignedWorkingHours] = useState<
    MultipleRangeValues[]
  >([]);
  const [filteredAssignedWorkingHours, setFilteredAssignedWorkingHours] =
    useState<MultipleRangeValues[]>([
      {
        id: "1",
        singleDayId: "",
        name: "test",
        startDate: new Date(),
        endDate: new Date(),
        shownDays: [],
        rangeColorClass: "bg-red-500",
      },
    ]);

  const canCreateWorkingHours = () => {
    return (
      store.roles &&
      store.roles.some((role: string) =>
        [roles.FrontSuperAdministrator, roles.FrontFrontHumanCapital].includes(
          role
        )
      )
    );
  };

  const deleteWorkingHoursById = async (id: string) => {
    try {
      await UserWorkingHoursService.delete(id);
      router.reload();
    } catch (error) {
      handleError(error);
    }
  };

  const getWorkingHours = async () => {
    try {
      const result = await WorkingHoursService.getAllWithId({
        page: 1,
        pageSize: 20,
        format: "dx",
      });
      const workingHours = result.data.map((c) => ({
        value: c.id ?? "",
        name: c.name,
      }));
      setWorkingHours(workingHours);
    } catch (error) {
      handleError(error);
    }
  };

  const filterCalendarValues = (isActive: boolean, filterId: string) => {
    const addedRange = assignedWorkingHours.find((c) => c.id === filterId);
    const updatedFilteredAssignedWorkingHours =
      isActive && addedRange
        ? [...filteredAssignedWorkingHours, addedRange]
        : filteredAssignedWorkingHours.filter((c) => c.id !== filterId);
    setFilteredAssignedWorkingHours(updatedFilteredAssignedWorkingHours);
  };

  const color1 = "tw-bg-red-500";
  const color2 = "tw-bg-blue-500";
  const color3 = "tw-bg-green-500";

  const getUserWorkingHours = async () => {
    try {
      const result = await UserWorkingHoursService.getAllWithDays({
        id: user?.id,
        page: 1,
        pageSize: 20,
        format: "dx",
      });

      const calendarValues = result.data.map((c, index) => ({
        id: c.id ?? "",
        singleDayId: "",
        name: c.workingHourName,
        startDate: new Date(c.dateStart),
        endDate: c.dateEnd ? new Date(c.dateEnd) : undefined,
        rangeColorClass:
          index % 3 === 0 ? color1 : index % 3 === 1 ? color2 : color3,
        shownDays: c.workingHourDays.map((c) => c.dayOfWeek),
      }));
      console.log(calendarValues, "calendarValues");
      setAssignedWorkingHours(calendarValues);
      setFilteredAssignedWorkingHours(calendarValues);
    } catch (error) {
      handleError(error);
    }
  };

  const validationSchema = z.object({
    workingHourId: z.string({
      required_error: t("WorkingHourRequiredValidationMessage"),
    }),
    dateStart: z.date({
      required_error: t("StartDateRequiredValidationMessage"),
    }),
    dateEnd: z.date({
      required_error: t("EndDateRequiredValidationMessage"),
    }),
  });

  type ValidationSchema = z.infer<typeof validationSchema>;

  const {
    control,
    handleSubmit,
    formState: { errors: clientErrors, isSubmitting },
    clearErrors: clearClientErrors,
  } = useForm<ValidationSchema>({
    resolver: zodResolver(validationSchema),
  });

  const onSubmit = handleSubmit(
    async (data, event) => {
      event?.preventDefault();
      clearErrors();
      try {
        const dto = {
          userId: user?.id ? user.id : "",
          workingHourId: data.workingHourId,
          dateStart: DateHelper.toLocalDateString(data.dateStart),
          dateEnd: DateHelper.toLocalDateString(data.dateEnd)
        };

        await UserWorkingHoursService.create(dto);
        setShowAssignModal(false);
        router.reload();
      } catch (error) {
        console.log(error, "error");
        handleError(error);
      }
    },
    (error, event) => {
      event?.preventDefault();
    }
  );

  const onAssignClose = () => {
    setShowAssignModal(false);
  };

  const onWorkingHoursClose = () => {
    setShowWorkingHoursModal(false);
  };

  useEffect(() => {
    if (!user) return;
    if (firstMount.current) {
      firstMount.current = false;
      getWorkingHours();
      getUserWorkingHours();
    }
  }, [user]);

  return (
    <div className="tw-flex tw-flex-col tw-gap-4">
      {user && (
        <PageHeader title={user.name + " " + user.lastName}></PageHeader>
      )}
      <DataGrid
        url={getUserWorkingHoursUrl}
        enableRowAlternation={false}
        locale={{
          nameColumn: {
            caption: t("NameColumnLabel", {
              ns: "Gridview",
            }),
          },
        }}
      >
        <Column
          name={"totalWeeklyHours"}
          dataField={"totalWeeklyHours"}
          caption={t("TotalWeeklyHoursColumnLabel", {
            ns: "Gridview",
          })}
          dataType="string"
          cellRender={(info: DataGridColumnInformation<null>) => (
            <p>{calculateHours(info.row.data.workingHourDays, t)}</p>
          )}
        ></Column>
        <Column
          name={"totalWeeklyDays"}
          dataField={"totalWeeklyDays"}
          caption={t("TotalWeeklyDaysColumnLabel", {
            ns: "Gridview",
          })}
          dataType="string"
          cellRender={(info: DataGridColumnInformation<null>) => (
            <p>
              {t("TotalWeeklyDaysInfo", { ns: "WorkingHoursScreen" }).replace(
                "{0}",
                info.row.data.workingHourDays.length
              )}{" "}
            </p>
          )}
        ></Column>
        <Column
          name={"dateStart"}
          dataField={"dateStart"}
          caption={t("DateStartLabel")}
          dataType="date"
        ></Column>
        <Column
          name={"dateEnd"}
          dataField={"dateEnd"}
          caption={t("DateEndLabel")}
          dataType="date"
        ></Column>
        <Column
          name={"weekSummary"}
          dataField={"weekSummary"}
          dataType="string"
          caption={t("WeekSummaryColumnLabel", {
            ns: "Gridview",
          })}
          cellRender={(info: DataGridColumnInformation<null>) => (
            <WeekDayBoxes info={info}></WeekDayBoxes>
          )}
        />
        <Column
          allowFiltering={false}
          allowReordering={false}
          dataField={t("ActionButtons", {
            ns: "Gridview",
          })}
          cellRender={(info: DataGridColumnInformation<null>) =>
            canCreateWorkingHours() && (
              <DefaultActionButtons
                showEditButton={false}
                showDetailsButton={false}
                LinkComponent={Link}
                info={info}
                entityName="user"
                locale={{
                  tooltips: {
                    edit: t("EditActionButtonLabel", {
                      ns: "Gridview",
                    }),
                    details: t("DetailsActionButtonLabel", {
                      ns: "Gridview",
                    }),
                    delete: t("DeleteActionButtonLabel", {
                      ns: "Gridview",
                    }),
                  },
                  delete: {
                    modalTitle: t("DeleteModalTitleLabel", {
                      ns: "Gridview",
                    }),
                    confirmLabel: t("DeleteModalConfirmButton", {
                      ns: "Gridview",
                    }),
                    cancelLabel: t("DeleteModalCancelButton", {
                      ns: "Gridview",
                    }),
                  },
                }}
                onDeleteConfirmed={async () => {
                  deleteWorkingHoursById(info.row.data.id);
                }}
              ></DefaultActionButtons>
            )
          }
        />
      </DataGrid>

      {canCreateWorkingHours() ? (
        <div className="tw-flex tw-justify-end tw-gap-4">
          <Button
            onClick={() => setShowWorkingHoursModal(true)} //clear form
            iconLeft={<PlusIcon className="tw-h-3 tw-w-3"></PlusIcon>}
          >
            {t("CreateWorkingHours")}
          </Button>

          <Button
            className="tw-right-25"
            onClick={() => setShowAssignModal(true)} //clear form
            iconLeft={<PlusIcon className="tw-h-3 tw-w-3"></PlusIcon>}
          >
            {t("AssignWorkingHours")}
          </Button>
        </div>
      ) : undefined}
      <div className="tw-gap-4 tw-grid tw-grid-cols-5">
        <div className="tw-col-span-4">
          <Calendar ranges={filteredAssignedWorkingHours} />
        </div>
        <div className="tw-border tw-border-gray-300 tw-rounded-lg tw-p-4 tw-shadow-md tw-my-30 tw-h-fit tw-bg-white tw-pb-28">
          <p>{t("Filter")}</p>
          <div className="tw-grid tw-grid-cols-2">
            {assignedWorkingHours.map((w) => (
              <>
                <Switch
                  name={""}
                  checked={filteredAssignedWorkingHours.some(
                    (f) => f.id === w.id
                  )}
                  className={"tw-w-fit"}
                  onChange={(v) => filterCalendarValues(v, w.id)}
                ></Switch>
                <p>{w.name}</p>
              </>
            ))}
          </div>
        </div>
      </div>

      <Modal
        title={t("AssignWorkinHoursTitle")}
        isOpen={showAssignModal}
        onClose={onAssignClose}
        titleClasses="tw-pt-2 tw-flex"
      >
        <Form>
          <Select
            multiple={false}
            LabelComponent={
              <FormLabel required>{t("WorkingHoursLabel")}</FormLabel>
            }
            name="workingHourId"
            placeholder={t("WorkingHoursPlaceholder")}
            control={control}
            searchEnabled={false}
            displayExpr={"name"}
            valueExpr={"value"}
            items={workingHours}
            errors={errors}
          />
          <DatePicker
            type="date"
            control={control}
            placeholder={t("StartDatePlaceholder")}
            LabelComponent={
              <FormLabel required={false}>{t("StartDateLabel")}</FormLabel>
            }
            name="dateStart"
            useMaskBehavior={true}
            errors={errors}
          ></DatePicker>
          <DatePicker
            type="date"
            control={control}
            placeholder={t("EndDatePlaceholder")}
            LabelComponent={
              <FormLabel required={false}>{t("EndDateLabel")}</FormLabel>
            }
            name="dateEnd"
            useMaskBehavior={true}
            errors={errors}
          ></DatePicker>
          <div className="tw-py-4">
            <div className="tw-flex tw-justify-end tw-gap-2">
              <Button
                variant="secondary"
                disabled={isSubmitting}
                onClick={() => {
                  setShowAssignModal(false);
                }}
              >
                {t("Cancel")}
              </Button>
              <Button
                onClick={onSubmit}
                disabled={isSubmitting}
                loading={isSubmitting}
              >
                {t("Save")}
              </Button>
            </div>
          </div>
        </Form>
      </Modal>
      <WorkingHoursForm
        showModal={showWorkingHoursModal}
        onClose={onWorkingHoursClose}
        mode={"create"}
      ></WorkingHoursForm>
    </div>
  );
};

export default UserWorkingHours;


### pages/working-hours/index.tsx ###
import {
  Button,
  Column,
  DataGrid,
  DecisionButton,
  PageHeader,
} from "@fusion/ui";
import { DefaultActionButtons } from "../../components/DefaultActionButtons";
import AccountService from "../../services/AccountService";
import { DataGridColumnInformation } from "@fusion/utils";
import { PencilIcon, PlusIcon } from "@heroicons/react/20/solid";
import Link from "next/link";
import { useRouter } from "next/router";
import { useTranslation } from "react-i18next";
import { roles } from "../../roles";
import { GetServerSideProps } from "next";
import useNetworkErrorHandler from "../../hooks/useNetworkErrorHandler";
import WorkingHoursService, {
  WorkingHourDay,
  WorkingHoursPage,
  WorkingHoursRes,
} from "../../services/WorkingHoursService";
import { useUserStore } from "../../stores/UserStore";
import { useState } from "react";
import { WeekDayBoxes } from "../../components/WeekDayBoxes";
import { WorkingHoursForm } from "../../components/WorkingHoursForm";

export const getServerSideProps: GetServerSideProps = async (context) => {
  const requiredRoles = [
    roles.FrontFrontObserver,
    roles.FrontFrontHumanCapital,
  ];
  const { isAuthorized } = await AccountService.authorize(
    requiredRoles,
    context.req.cookies
  );

  const workingHours = await WorkingHoursService.getAll({
    page: 1,
    pageSize: 1,
    cookies: context.req.cookies,
    format: "default",
  });

  if (!isAuthorized) {
    return {
      redirect: {
        destination: `/401`,
        permanent: false,
      },
    };
  }
  return { props: { workingHours } };
};

export function calculateHours(
  workingHourDay: WorkingHourDay[],
  t: any
): string {
  if (
    workingHourDay.length === 0 ||
    !workingHourDay.some((d) => d.minutes != 0)
  ) {
    return t("NoHoursAssigned", {
      ns: "WorkingHoursScreen",
    });
  }

  const hoursWorked =
    workingHourDay.map((d) => d.minutes).reduce((a, b) => a + b, 0) / 60;

  return t("TotalWeeklyHoursInfo", { ns: "WorkingHoursScreen" }).replace(
    "{0}",
    hoursWorked.toString()
  );
}

type WorkingHoursProps = {
  workingHours: WorkingHoursPage;
};

const WorkingHours = (props: WorkingHoursProps) => {
  const router = useRouter();
  const { t } = useTranslation("WorkingHoursScreen");
  const { handleError } = useNetworkErrorHandler();
  const getWorkingHoursUrl = `/api/workingHour?format=dx`;
  const { workingHours } = props;
  const store = useUserStore();
  const [showModal, setShowModal] = useState(false);
  const [mode, setMode] = useState<"create" | "edit">("create");
  const [workingHourData, setWorkingHourData] = useState<WorkingHoursRes>();

  const onClose = () => {
    setShowModal(false);
    setMode("create");
    setWorkingHourData(undefined);
  };

  const onEditSelected = (data: WorkingHoursRes) => {
    console.log(data, "Data");
    setMode("edit");
    setWorkingHourData(data);
    setShowModal(true);
  };

  const deleteWorkingHoursById = async (id: string) => {
    try {
      await WorkingHoursService.delete(id);
      router.push("/working-hours");
    } catch (error) {
      handleError(error);
    }
  };

  const canCreateWorkingHours = (item: WorkingHoursPage) => {
    return (
      item.links.some((a) => a.rel === "Create") &&
      store.roles &&
      store.roles.some((role: string) =>
        [roles.FrontSuperAdministrator, roles.FrontFrontHumanCapital].includes(
          role
        )
      )
    );
  };

  return (
    <>
      <PageHeader title={t("Title")}>
        {canCreateWorkingHours(workingHours) ? (
          <Button
            onClick={() => setShowModal(true)} //clear form
            iconLeft={<PlusIcon className="tw-h-3 tw-w-3"></PlusIcon>}
          >
            {t("Create")}
          </Button>
        ) : undefined}
      </PageHeader>

      <DataGrid
        url={getWorkingHoursUrl}
        enableRowAlternation={false}
        locale={{
          nameColumn: {
            caption: t("NameColumnLabel", {
              ns: "Gridview",
            }),
          },
        }}
      >
        <Column
          name={"totalWeeklyHours"}
          dataField={"totalWeeklyHours"}
          dataType="string"
          caption={t("TotalWeeklyHoursColumnLabel", {
            ns: "Gridview",
          })}
          cellRender={(info: DataGridColumnInformation<null>) => (
            <p>{calculateHours(info.row.data.workingHourDays, t)}</p>
          )}
        />
        <Column
          name={"totalWeeklyDays"}
          dataField={"totalWeeklyDays"}
          dataType="string"
          caption={t("TotalWeeklyDaysColumnLabel", {
            ns: "Gridview",
          })}
          cellRender={(info: DataGridColumnInformation<null>) => (
            <p>
              {t("TotalWeeklyDaysInfo").replace(
                "{0}",
                info.row.data.workingHourDays.length
              )}{" "}
            </p>
          )}
        />
        <Column
          name={"weekSummary"}
          dataField={"weekSummary"}
          dataType="string"
          caption={t("WeekSummaryColumnLabel", {
            ns: "Gridview",
          })}
          cellRender={(info: DataGridColumnInformation<null>) => (
            <WeekDayBoxes info={info}></WeekDayBoxes>
          )}
        />
        <Column
          allowFiltering={false}
          allowReordering={false}
          dataField={t("ActionButtons", {
            ns: "Gridview",
          })}
          cellRender={(info: DataGridColumnInformation<null>) =>
            canCreateWorkingHours(workingHours) && (
              <div className="tw-flex tw-items-center tw-justify-start">
                <DecisionButton
                  tooltip={t("EditActionButtonLabel", {
                    ns: "Gridview",
                  })}
                  _buttonProps={{
                    variant: "tertiary",
                  }}
                  iconLeft={
                    <PencilIcon
                      className="tw-h-5 tw-w-5"
                      fill="#799452"
                    ></PencilIcon>
                  }
                  modal={{
                    title: t("EditModalTitle"),
                    onConfirm: async () => {
                      onEditSelected(info.row.data);
                      info.component.refresh();
                    },
                    confirmLabel: t("ConfirmLabel"),
                    cancelLabel: t("CancelLabel"),
                  }}
                ></DecisionButton>
                <DefaultActionButtons
                  showEditButton={false}
                  showDetailsButton={false}
                  LinkComponent={Link}
                  info={info}
                  entityName="user"
                  locale={{
                    tooltips: {
                      edit: t("EditActionButtonLabel", {
                        ns: "Gridview",
                      }),
                      details: t("DetailsActionButtonLabel", {
                        ns: "Gridview",
                      }),
                      delete: t("DeleteActionButtonLabel", {
                        ns: "Gridview",
                      }),
                    },
                    delete: {
                      modalTitle: t("DeleteModalTitleLabel", {
                        ns: "Gridview",
                      }),
                      confirmLabel: t("DeleteModalConfirmButton", {
                        ns: "Gridview",
                      }),
                      cancelLabel: t("DeleteModalCancelButton", {
                        ns: "Gridview",
                      }),
                    },
                  }}
                  onDeleteConfirmed={async () => {
                    deleteWorkingHoursById(info.row.data.id);
                  }}
                ></DefaultActionButtons>
              </div>
            )
          }
        />
      </DataGrid>
      {showModal && (
        <WorkingHoursForm
          showModal={showModal}
          onClose={onClose}
          mode={mode}
          workingHours={workingHourData}
        ></WorkingHoursForm>
      )}
    </>
  );
};

export default WorkingHours;


### postcss.config.js ###
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


### roles.ts ###
const roles = {
  FrontSuperAdministrator: "Front.SuperAdministrator",
  FrontSystemUser: "Front.SystemUser",
  FrontFrontHumanCapital: "Front.FrontHumanCapital",
  FrontFrontManualSigning: "Front.FrontManualSigning",
  FrontFrontObserver: "Front.FrontObserver",
};

export { roles };

type MenuItems = {
  menuItem: string;
  rolesAllowed: string[];
};

export const menuItems: MenuItems[] = [
  {
    menuItem: "Company",
    rolesAllowed: [roles.FrontSuperAdministrator],
  },
  {
    menuItem: "Calendar",
    rolesAllowed: [roles.FrontFrontHumanCapital],
  },
  {
    menuItem: "Reports",
    rolesAllowed: [roles.FrontFrontHumanCapital, roles.FrontSystemUser],
  },
  {
    menuItem: "Tracking",
    rolesAllowed: [roles.FrontSuperAdministrator],
  },
  {
    menuItem: "Event",
    rolesAllowed: [roles.FrontFrontHumanCapital, roles.FrontSystemUser],
  },
  {
    menuItem: "User",
    rolesAllowed: [
      roles.FrontSuperAdministrator,
      roles.FrontFrontObserver,
      roles.FrontFrontHumanCapital,
    ],
  },
  {
    menuItem: "Track",
    rolesAllowed: [
      roles.FrontSuperAdministrator,
      roles.FrontFrontManualSigning,
      roles.FrontSystemUser,
      roles.FrontFrontHumanCapital,
    ],
  },
  {
    menuItem: "WorkingHours",
    rolesAllowed: [roles.FrontFrontObserver, roles.FrontFrontHumanCapital],
  },
  {
    menuItem: "UserAssignedWorkingHours",
    rolesAllowed: [
      roles.FrontFrontObserver,
      roles.FrontSystemUser,
    ],
  },
];


### routes.ts ###
const routes = {
  CREATE_PASSWORD: "/create-password",
  COMPANY: "/company",
  CALENDAR: "/calendar",
  REPORTS: "/reports",
  TRACKING: "/tracking",
  EVENT: "/event",
  ERROR: "/500",
  FORCE_CHANGE_PASSWORD: "/force-change-password",
  FORGOT_PASSWORD: "/forgot-password",
  FORGOT_PASSWORD_SUCCESS: "/forgot-password-success",
  HOME: "/",
  LOGIN: "/login",
  REGISTER: "/register",
  REGISTER_CONFIRMATION: "/register-confirmation",
  RESET_PASSWORD: "/reset-password",
  RESET_PASSWORD_CONFIRMATION: "/reset-password-confirmation",
  UNAUTHORIZED: "/401",
  USER: "/user",
  TRACK: "/track",
  WORKINGHOURS: "/working-hours",
  USERWORKINHOURS: "/user/user-working-hours",
};

const publicRoutes = [
  routes.CREATE_PASSWORD,
  routes.ERROR,
  routes.LOGIN,
  routes.FORCE_CHANGE_PASSWORD,
  routes.FORGOT_PASSWORD,
  routes.FORGOT_PASSWORD_SUCCESS,
  routes.REGISTER,
  routes.REGISTER_CONFIRMATION,
  routes.RESET_PASSWORD,
  routes.RESET_PASSWORD_CONFIRMATION,
];

export { publicRoutes, routes };


### scripts/copy-files-linux.sh ###
#!/bin/bash

# Create folders if they do not exist
mkdir -p ./.next/standalone/public
mkdir -p ./.next/standalone/.next/static

# Copy files
cp -r ./public/* ./.next/standalone/public/
cp -r ./.next/static/* ./.next/standalone/.next/static/
cp ./ecosystem.config.js ./.next/standalone/
cp -r ./node_modules/dotenv ./.next/standalone/node_modules/


### scripts/copy-files-windows.ps1 ###
# create folder if not exist
New-Item -ItemType Directory -Force -Path .\.next\standalone, .\.next\standalone\public, .\.next\standalone\.next, .\.next\standalone\.next\static

# copy files
xcopy .\public .\.next\standalone\public /E /I /H /Y
xcopy .\.next\static .\.next\standalone\.next\static /E /I /H /Y
xcopy .\ecosystem.config.js .\.next\standalone /Y
xcopy .\node_modules\dotenv .\.next\standalone\node_modules\dotenv /Y /E /I /H
 


### server/proxy.ts ###
import { NextApiRequest, NextApiResponse } from "next";

export const cloneRequestHeaders = (req: NextApiRequest) => {
  const headers = new Headers();

  Object.entries(req.headers).forEach(([key, value]) => {
    headers.append(key, value as string);
  });

  headers.set("host", process.env.APP_HOST || "");
  console.log('--------------------- host2:' + process.env.APP_HOST)

  const tokens = getTokensFromCookie(req);

  if (tokens) {
    headers.set("authorization", `Bearer ${tokens.accessToken}`);
  }

  return headers;
};

const getTokensFromCookie = (req: NextApiRequest) => {
  const cookie = req.cookies[process.env.COOKIE_NAME!];
  if (cookie) {
    const json = JSON.parse(cookie);
    return {
      accessToken: json.token,
      refreshToken: json.refreshToken,
    };
  }
  return null;
};

export const setResponseHeaders = (res: NextApiResponse, headers: Headers) => {
  Object.entries(headers).forEach(([key, value]) => {
    res.setHeader(key, value as string);
  });
};

export const isTokenExpired = (response: Response) => {
  // check status code 401 and www-authenticate header should include "Bearer error="invalid_token""
  if (
    response.status === 401 &&
    response.headers
      .get("www-authenticate")
      ?.includes('Bearer error="invalid_token"')
  ) {
    return true;
  }
  return false;
};

export const handleRefreshToken = async (
  req: NextApiRequest
): Promise<{
  accessToken: string;
  refreshToken: string;
}> => {
  const tokens = getTokensFromCookie(req);
  const headers = cloneRequestHeaders(req);

  headers.set("Content-Type", "application/json");

  if (tokens) {
    const fetchResponse = await fetch(
      `${process.env.API_URL}/api/account/refresh`,
      {
        headers: headers,
        method: "POST",
        body: JSON.stringify({
          accessToken: tokens.accessToken,
          refreshToken: tokens.refreshToken,
        }),
      }
    );

    if (fetchResponse.status === 200) {
      const body = await fetchResponse.text();
      return {
        accessToken: body,
        refreshToken: tokens.refreshToken,
      };
    } else {
      throw new Error("Refresh token failed");
    }
  }
  throw new Error("No cookie found");
};


### services/AccountService.ts ###
import { Cookies, HateoasLink, Response } from "@fusion/network";
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";

export type Account = {
  email: string;
  id: string;
  lastName: string;
  name: string;
  phoneNumber?: string;
  roles: string[];
  links: HateoasLink[];
  language?: string;
  tenantId?: string;
};

export type ChangePasswordReq = {
  oldPassword: string;
  newPassword: string;
  confirmPassword: string;
};

export type ForceChangePasswordReq = ChangePasswordReq & {
  email: string;
};

export type CreatePasswordReq = {
  userId: string;
  code: string;
  newPassword: string;
  confirmPassword: string;
};

export type CreatePasswordRes = {
  email: string;
};

export type CookieConsentRes = {
  cookiePolicyUrl: string;
  accepted: boolean;
};

export type TermsAndConditions = {
  accepted: boolean;
  url: string;
};

type AcceptedTermsAndConditionsRes = {
  token: string;
};

const store = useUserStore.getState();

type LoginReq = {
  email: string;
  password: string;
};

type LoginRes = {
  token: string;
  refreshToken: string;
  email: string;
};

type RegisterReq = {
  email: string;
  lastName: string;
  name: string;
  password: string;
  confirmEmailCallback?: string;
};

type AuthorizeRes = {
  isAuthorized: boolean;
};

export type CurrentRolesRes = {
  roles: string[];
};

export type ResetPasswordReq = {
  email: string;
  password: string;
  confirmPassword: string;
  code: string;
};
export default class AccountService {
  static login = async (dto: LoginReq): Promise<void> => {
    console.log("------------------>LOGIN: " + process.env.NEXT_PUBLIC_WEB_URL)
    const response = await client.post<LoginRes>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/login`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: dto,
    });

    if (response.data.email) {
      store.setEmail(dto.email);
    }
  };

  static logout = async (entryKey: string | null) => {

    const entryKeyParam = entryKey ? '?entryKey=' + entryKey : '';

    await client.post({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/logout${entryKeyParam}`,
        headers: new Headers({
          "Content-Type": "application/json",
        })
      }
    });

    store.setEmail();
  };

  static getCurrentAccount = async (
    cookies?: Cookies
  ): Promise<Response<Account>> => {
    const response = await client.get<Account>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
        cookies: cookies,
      },
    });

    return response;
  };

  static getCookieConsentInfo = async (): Promise<CookieConsentRes> => {
    const { data } = await client.get<CookieConsentRes>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/cookie-policy`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };

  static acceptCookie = async (): Promise<void> => {
    await client.post({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/cookie-policy`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: {},
    });
  };

  static changePassword = async (data: ChangePasswordReq): Promise<void> => {
    await client.put({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/change-password`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: data,
    });
  };

  static update = async (data: Partial<Account>): Promise<void> => {
    await client.put({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: {
        name: data.name,
        lastName: data.lastName,
        phoneNumber: data.phoneNumber,
      },
    });
  };

  static getTermsAndConditions = async (
    cookies?: Cookies
  ): Promise<Response<TermsAndConditions>> => {
    const response = await client.get<TermsAndConditions>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/terms-and-conditions`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return response;
  };

  static acceptTermsAndConditions =
    async (): Promise<AcceptedTermsAndConditionsRes> => {
      const { data } = await client.post<AcceptedTermsAndConditionsRes>({
        request: {
          url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/terms-and-conditions`,
          headers: new Headers({
            "Content-Type": "application/json",
          }),
        },
      });

      return data;
    };

  static register = async (dto: RegisterReq): Promise<string[]> => {
    const { data } = await client.post<string[]>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/register`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: {
        ...dto,
        confirmEmailCallback: `${process.env.NEXT_PUBLIC_WEB_URL}/login`,
      },
    });

    return data;
  };

  // Used to reset user password when it's expired.
  static forceChangePassword = async (
    data: ForceChangePasswordReq
  ): Promise<void> => {
    await client.put({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/force-change-password`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: data,
    });
  };

  static forgotPassword = async (email: string): Promise<void> => {
    await client.post({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/forgot-password`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: {
        email: email,
        forgotPasswordEmailCallback: `${process.env.NEXT_PUBLIC_WEB_URL}/reset-password?email=${email}`,
      },
    });
  };

  static confirmationEmail = async (id: string): Promise<void> => {
    await client.put<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/confirmation-email/${id}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: {
        confirmEmailCallback: `${process.env.NEXT_PUBLIC_WEB_URL}/create-password`,
      },
    });
  };

  static resetPassword = async (dto: ResetPasswordReq): Promise<void> => {
    await client.post({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/reset-password`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: dto,
    });
  };

  static createPassword = async (
    dto: CreatePasswordReq
  ): Promise<CreatePasswordRes> => {
    const { data } = await client.post<CreatePasswordRes>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/create-password`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: dto,
    });
    return data;
  };

  static authorize = async (
    dto: string[],
    cookies?: Cookies
  ): Promise<AuthorizeRes> => {
    try {
      await client.post<AuthorizeRes>({
        request: {
          url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/account/authorize`,
          cookies: cookies,
          headers: new Headers({
            "Content-Type": "application/json",
          }),
        },
        body: { roles: dto },
      });

      return {
        isAuthorized: true,
      };
    } catch (error) {
      return {
        isAuthorized: false,
      };
    }
  };
}


### services/CalendarDayService.ts ###
import { Cookies, HateoasPage } from "@fusion/network";
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export type CalendarDayRes = {
  id?: string | null;
  name: string;
  calendarId?: string;
  calendarDayTypeId?: string;
  date: string;
  color?: string;
};

export type CalendarDayPage = HateoasPage<CalendarDayRes>;

export default class CalendarDayService {
  static delete = async (
    id: string,
    dataCallback?: (success: boolean) => void
  ): Promise<void> => {
    try {
      await client.delete<void>({
        request: {
          url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/calendarDay?id=${id}&culture=${culture}`,
          headers: new Headers({
            "Content-Type": "application/json",
          }),
        },
      });

      if (dataCallback) dataCallback(true);
    } catch {
      if (dataCallback) dataCallback(false);
    }
  };

  static create = async (
    calendar: CalendarDayRes,
    dataCallback?: (success: boolean) => void
  ): Promise<void> => {
    try {
      await client.post<void>({
        request: {
          url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/calendarDay`,
          headers: new Headers({
            "Content-Type": "application/json",
          }),
        },
        body: calendar,
      });

      if (dataCallback) dataCallback(true);
    } catch {
      if (dataCallback) dataCallback(false);
    }
  };

  static update = async (
    calendar: CalendarDayRes,
    dataCallback?: (success: boolean) => void
  ): Promise<void> => {
    try {
      await client.put<void>({
        request: {
          url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/calendarDay`,
          headers: new Headers({
            "Content-Type": "application/json",
          }),
        },
        body: calendar,
      });

      if (dataCallback) dataCallback(true);
    } catch {
      if (dataCallback) dataCallback(false);
    }
  };

  static getAll = async (options?: {
    page?: number;
    pageSize?: number;
    cookies?: Cookies;
    format?: string;
  }): Promise<CalendarDayPage> => {
    if (!options) {
      options = {
        page: 1,
        pageSize: 20,
      };
    }

    const { page = 1, pageSize = 20, cookies } = options;

    const { data } = await client.get<CalendarDayPage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/calendarDay/list?page=${page}&pageSize=${pageSize}&culture=${culture}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };
}


### services/CalendarService.ts ###
import { Cookies, HateoasLink, HateoasPage, Response } from "@fusion/network";
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export type CalendarRes = {
  id?: string;
  name: string;
  numberOfEmployees?: number;
  numberOfHolidays?: number;
  links?: {
    rel: string;
  }[];
};

export type CalendarPage = HateoasPage<CalendarRes>;

export default class CalendarService {
  static getAll = async (options?: {
    page?: number;
    pageSize?: number;
    cookies?: Cookies;
    format?: string;
  }): Promise<CalendarPage> => {
    if (!options) {
      options = {
        page: 1,
        pageSize: 20,
      };
    }

    const { page = 1, pageSize = 20, cookies } = options;

    const { data } = await client.get<CalendarPage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/calendar/get-by-current-companyId?page=${page}&pageSize=${pageSize}&culture=${culture}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };
  static getAllByTenantId = async (options?: {
    page?: number;
    pageSize?: number;
    cookies?: Cookies;
    format?: string;
    tenantId ?: string;
  }): Promise<CalendarPage> => {
    if (!options) {
      options = {
        page: 1,
        pageSize: 20
      };
    }

    const { page = 1, pageSize = 20, cookies, tenantId } = options;

    const { data } = await client.get<CalendarPage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/calendar/get-by-companyId?tenantId=${tenantId}&page=${page}&pageSize=${pageSize}&culture=${culture}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };

  static delete = async (id: string): Promise<void> => {
    await client.delete<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/calendar/delete?id=${id}&culture=${culture}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
  };

  static getById = async (
    id: string,
    cookies?: Cookies
  ): Promise<Response<CalendarRes>> => {
    const response = await client.get<CalendarRes>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/calendar/get-calendar?id=${id}&culture=${culture}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
    return response;
  };

  static create = async (calendar: CalendarRes): Promise<void> => {
    await client.post<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/calendar/create`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: calendar,
    });
  };

  static update = async (id: string, calendar: CalendarRes): Promise<void> => {
    await client.put<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/calendar/edit?id=${id}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: calendar,
    });
  };
}


### services/CompanyService.ts ###
import { Cookies, HateoasLink, HateoasPage, Response } from "@fusion/network";
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export type CompanyRes = {
  id?: string;
  name: string;
  vat: string;
  address: string;
  telephone: string;
  postalCode: string;
  city: string;
  country: string;
  inactive: boolean;
  links?: {
    rel: string;
  }[];
};

export type CompanyPage = HateoasPage<CompanyRes>;

export default class CompanyService {
  static getAll = async (options?: {
    page?: number;
    pageSize?: number;
    cookies?: Cookies;
    format?: string;
  }): Promise<CompanyPage> => {
    if (!options) {
      options = {
        page: 1,
        pageSize: 20,
      };
    }

    const { page = 1, pageSize = 20, cookies } = options;

    const { data } = await client.get<CompanyPage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/company/list?page=${page}&pageSize=${pageSize}&culture=${culture}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };

  static delete = async (id: string): Promise<void> => {
    await client.delete<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/company?id=${id}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
  };

  static getById = async (
    id: string,
    cookies?: Cookies
  ): Promise<Response<CompanyRes>> => {
    const response = await client.get<CompanyRes>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/company?id=${id}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
    return response;
  };

  static create = async (company: CompanyRes): Promise<void> => {
    await client.post<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/company/create`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: company,
    });
  };

  static update = async (id: string, company: CompanyRes): Promise<void> => {
    await client.put<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/company?id=${id}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: company,
    });
  };
}


### services/EntryTypeService.ts ###
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export type EntryTypeResponse = {
  id: string;
  name: string;
  requestGeoLocation: boolean;
  isDefault: boolean;
};

export default class EntryTypeService {
  static getAll = async (): Promise<EntryTypeResponse[]> => {
    let url = `${process.env.NEXT_PUBLIC_WEB_URL}/api/EntryType?culture=${culture}`;
    const { data } = await client.get<EntryTypeResponse[]>({
      request: {
        url: url,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };
}


### services/EventService.ts ###
import { Cookies, HateoasPage, Response } from "@fusion/network";
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";
import { EventStatusEnum } from "../pages/event/[...slug]";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export type EventRes = {
  id?: string;
  eventTypeName?: string;
  eventTypeId: string;
  dateStart: Date | string;
  dateEnd?: Date | string;
  comments?: string;
  name?: string;
  eventStatusEnum?: EventStatusEnum;
  links?: {
    rel: string;
  }[];
};

export type EventPage = HateoasPage<EventRes>;

export default class EventService {
  static getAll = async (options?: {
    page?: number;
    pageSize?: number;
    cookies?: Cookies;
    format?: string;
  }): Promise<EventPage> => {
    if (!options) {
      options = {
        page: 1,
        pageSize: 20,
      };
    }

    const { page = 1, pageSize = 20, cookies } = options;

    const { data } = await client.get<EventPage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/event?page=${page}&pageSize=${pageSize}&culture=${culture}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };

  static delete = async (id: string): Promise<void> => {
    await client.delete<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/calendar/delete?id=${id}&culture=${culture}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
  };

  static getById = async (
    id: string,
    cookies?: Cookies
  ): Promise<Response<EventRes>> => {
    const response = await client.get<EventRes>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/event/get-event-by-id?id=${id}&culture=${culture}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
    return response;
  };

  static create = async (request: EventRes): Promise<void> => {
    await client.post<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/event`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: request,
    });
  };

  static update = async (request: EventRes): Promise<void> => {
    await client.put<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/event?culture=${culture}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: request,
    });
  };
}


### services/EventTypeService.ts ###
import { Cookies, HateoasPage, Response } from "@fusion/network";
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export type EventTypeRes = {
  value: string;
  text: string;
};

export type EventTypePage = HateoasPage<EventTypeRes>;

export default class EventTypeService {
  static getAll = async (options?: {
    page?: number;
    pageSize?: number;
    cookies?: Cookies;
    format?: string;
  }): Promise<EventTypeRes[]> => {
    if (!options) {
      options = {
        page: 1,
        pageSize: 20,
      };
    }

    const { page = 1, pageSize = 20, cookies } = options;

    const { data } = await client.get<EventTypeRes[]>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/eventType/get-event-type-list`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };
}


### services/FileService.ts ###
import { FileRes } from "../components/chat/types";
import client from "../network-client";

export default class FileService {
  static upload = async (file: File): Promise<FileRes> => {
    const formData = new FormData();
    formData.append("formFile", file);
    const { data } = await client.post<FileRes>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/file/upload`,
        headers: new Headers({
          "Content-Type": "multipart/form-data",
        }),
      },
      body: formData,
    });

    return data;
  };
}


### services/FrontUserService.ts ###
import { Cookies, HateoasPage, Response } from "@fusion/network";
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export type UserRes = {
  id?: string;
  email: string;
  name: string;
  lastName: string;
  address: string;
  city: string;
  country: string;
  inactive: boolean;
  dni: string;
  entryKey: string;
  postalCode: string;
  birthdate: string;
  roles?: string;
  tenantID: string;
  calendarId?: string;
  phoneNumber: string;
};

export type UserReq = {
  id?: string;
  entryKey?: string;
  dni: string;
  name: string;
  lastName: string;
  email: string;
  confirmEmailCallback: string;
  phoneNumber: string;
  address: string;
  postalCode: string;
  city: string;
  country: string;
  birthdate?: Date | string;
  roles?: string[];
  inactive: boolean;
  tenantID: string;
  calendarId?: string;
  userType?: string;
  timeZoneId?: string;
};

export type UserOption = {
  currentPage: number;
  pageSize: number;
  total: number;
  items: { id: string; text: string }[];
};

export type UserPage = HateoasPage<UserRes>;

export default class FrontUserService {
  static getAll = async (options?: {
    page?: number;
    pageSize?: number;
    cookies?: Cookies;
  }): Promise<UserPage> => {
    if (!options) {
      options = {
        page: 1,
        pageSize: 20,
      };
    }

    const { page = 1, pageSize = 20, cookies } = options;

    const { data } = await client.get<UserPage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/frontUser/list?page=${page}&pageSize=${pageSize}&culture=${culture}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };

  static create = async (user: UserReq): Promise<void> => {
    await client.post<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/frontUser/create`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: user,
    });
  };

  static update = async (
    id: string | undefined,
    user: UserReq
  ): Promise<void> => {
    await client.put<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/frontUser`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: user,
    });
  };

  static getById = async (
    id: string,
    cookies?: Cookies
  ): Promise<Response<UserRes>> => {
    const response = await client.get<UserRes>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/frontUser?id=${id}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return response;
  };

  static delete = async (id: string): Promise<void> => {
    await client.delete<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/frontUser?id=${id}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
  };

  static getOptions = async (
    page: number = 1,
    pageSize: number = 20,
    cookies?: Cookies
  ): Promise<UserOption> => {
    const response = await client.get<UserOption>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/user/basic?page=${page}&pageSize=${pageSize}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
    return response.data;
  };
}


### services/LanguageService.ts ###
import { Cookies, HateoasPage, Response } from "@fusion/network";
import client from "../network-client";

export type LanguageRes = {
  id: string;
  text: string;
};

export type LanguagePage = HateoasPage<LanguageRes>;

export default class LanguageService {
  static getOptions = async (
    cookies?: Cookies
  ): Promise<Response<LanguagePage>> => {
    const response = await client.get<LanguagePage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/language/basic`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
    return response;
  };
}


### services/QueryBuilderService.ts ###
import client from "../network-client";
import { Response } from "@fusion/network";

type ExecuteOptions = {
  message: string;
  chatId: string;
  apiUrl: string;
  filter?: unknown;
  sort?: unknown;
};

type QueryBuilderRes = {
  content: string;
  queryBuilderResult: {
    filter: unknown;
    sort: unknown;
  };
};

export default class QueryBuilderService {
  static execute = async (
    options: ExecuteOptions
  ): Promise<Response<QueryBuilderRes>> => {
    const response = await client.post<QueryBuilderRes>({
      request: {
        url: options.apiUrl,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: {
        ask: options.message,
        chatId: options.chatId,
        currentQuery: {
          filter: options.filter,
          sort: options.sort,
        },
      },
    });

    return response;
  };
}


### services/RoleService.ts ###
import { Cookies } from "@fusion/network";
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export default class RoleService {
  static getAll = async (cookies?: Cookies): Promise<string[]> => {
    let url = `${process.env.NEXT_PUBLIC_WEB_URL}/api/role?culture=${culture}`;
    const { data } = await client.get<string[]>({
      request: {
        url: url,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };
}


### services/TimeZoneService.ts ###
import { Cookies, HateoasPage, Response } from "@fusion/network";
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export type TimeZoneRes = {
  id?: string;
  name: string;
};

export type TimeZonePage = HateoasPage<TimeZoneRes>;

export default class TimeZoneService {
  static getAll = async (options?: {
    page?: number;
    pageSize?: number;
    cookies?: Cookies;

  }): Promise<TimeZonePage> => {
    if (!options) {
      options = {
        page: 1,
        pageSize: 20,
      };
    }

    const { cookies } = options;

    const { data } = await client.get<TimeZonePage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/TimeZone/list`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };

}


### services/UserEntryService.ts ###
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export type EntryTotemReq = {
  entryKey: string;
  isStart: boolean;
};

export type EntryReq = {
  isStart: boolean;
  isPaused: boolean;
  motiveMessage?: string;
  entryTypeId?: string;
  entryKey?: string;
  lat?: number;
  lng?: number;
};

export type StatusRes = {
  startEnabled: boolean;
  isInProgress: boolean;
  isPaused: boolean;
  entryTypeId: string;
  remainingMinutes?: number;
  totalMinutes?: number;
};

export type UserReportList = {
  value: string;
  text: string;
  selected?: boolean;
  disabled?: boolean;
  group?: string;
};

export type UserReportData = {
  date: string;
  totalHour: string;
  comments: string;
  disabled: string;
};

export default class UserEntryService {
  static saveTotemEntry = async (req: EntryTotemReq): Promise<void> => {
    let url = `${process.env.NEXT_PUBLIC_WEB_URL}/api/UserEntry/totem?culture=${culture}`;
    const { data } = await client.post<void>({
      request: {
        url: url,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: req,
    });

    return data;
  };

  static saveEntry = async (req: EntryReq): Promise<StatusRes> => {
    let url = `${process.env.NEXT_PUBLIC_WEB_URL}/api/UserEntry?culture=${culture}`;
    const { data } = await client.post<StatusRes>({
      request: {
        url: url,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: req,
    });

    return data;
  };
  static getTotemEntry = async (req: EntryTotemReq): Promise<void> => {
    let url = `${process.env.NEXT_PUBLIC_WEB_URL}/api/UserEntry/getUserByEntry?culture=${culture}`;
    const { data } = await client.post<void>({
      request: {
        url: url,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: req,
    });

    return data;
  };
  static getStatus = async (): Promise<StatusRes> => {
    let url = `${process.env.NEXT_PUBLIC_WEB_URL}/api/UserEntry/status?culture=${culture}`;
    const { data } = await client.get<StatusRes>({
      request: {
        url: url,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };

  static getUserReportList = async (): Promise<UserReportList[]> => {
    let url = `${process.env.NEXT_PUBLIC_WEB_URL}/api/UserEntry/get-user-list?culture=${culture}`;
    const { data } = await client.get<UserReportList[]>({
      request: {
        url: url,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
    return data;
  };

  static getUserReportData = async (
    user?: string,
    from?: string,
    to?: string
  ): Promise<UserReportData[]> => {
    let url = `${process.env.NEXT_PUBLIC_WEB_URL}/api/UserEntry/get-users-working-hour?culture=${culture}
    &userId=${user}&dateStart=${from}&dateEnd=${to}`;
    const { data } = await client.get<UserReportData[]>({
      request: {
        url: url,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
    return data;
  };
}


### services/UserService.ts ###
import { Cookies, HateoasPage, Response } from "@fusion/network";
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export type UserRes = {
  id: string;
  name: string;
  lastName: string;
  email: string;
  roles: string[];
  links: {
    rel: string;
  }[];
};

export type UserReq = {
  id?: string;
  name: string;
  lastName: string;
  email: string;
  roles: string[];
};

export type UserOption = {
  currentPage: number;
  pageSize: number;
  total: number;
  items: { id: string; text: string }[];
};

export type UserPage = HateoasPage<UserRes>;

export default class UserService {
  static getAll = async (options?: {
    page?: number;
    pageSize?: number;
    cookies?: Cookies;
  }): Promise<UserPage> => {
    if (!options) {
      options = {
        page: 1,
        pageSize: 20,
      };
    }

    const { page = 1, pageSize = 20, cookies } = options;

    const { data } = await client.get<UserPage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/user?page=${page}&pageSize=${pageSize}&culture=${culture}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };

  static create = async (user: UserReq): Promise<void> => {
    await client.post<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/user`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: user,
    });
  };

  static update = async (
    id: string | undefined,
    user: UserReq
  ): Promise<void> => {
    await client.put<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/user/${id}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: user,
    });
  };

  static getById = async (
    id: string,
    cookies?: Cookies
  ): Promise<Response<UserRes>> => {
    const response = await client.get<UserRes>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/user/${id}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return response;
  };

  static delete = async (id: string): Promise<void> => {
    await client.delete<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/user/${id}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
  };

  static getOptions = async (
    page: number = 1,
    pageSize: number = 20,
    cookies?: Cookies
  ): Promise<UserOption> => {
    const response = await client.get<UserOption>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/user/basic?page=${page}&pageSize=${pageSize}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return response.data;
  };
}


### services/UserWorkingHoursService.ts ###
import { Cookies, HateoasPage } from "@fusion/network";
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";
import { WorkingHourDay } from "./WorkingHoursService";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export type UserWorkingHoursRes = {
  id?: string;
  userName?: string;
  userId: string;
  workingHourId: string;
  dateStart: string;
  dateEnd?: string;
};

export type UserWorkingHoursWithDaysRes = {
  id?: string;
  userName?: string;
  userId: string;
  workingHourName: string;
  workingHourId: string;
  dateStart: Date;
  dateEnd?: Date;
  workingHourDays: WorkingHourDay[];
};

export type UserWorkingHoursPage = HateoasPage<UserWorkingHoursRes>;

type DataPage = {
  data: UserWorkingHoursWithDaysRes[];
};

export default class UserWorkingHoursService {
  static getAll = async (options?: {
    id?: string;
    page?: number;
    pageSize?: number;
    cookies?: Cookies;
    format?: string;
  }): Promise<UserWorkingHoursPage> => {
    if (!options) {
      options = {
        id: undefined,
        page: 1,
        pageSize: 20,
      };
    }

    const { id = null, page = 1, pageSize = 20, cookies } = options;

    const { data } = await client.get<UserWorkingHoursPage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/UserWorkingHour?userId=${id}&page=${page}&pageSize=${pageSize}&culture=${culture}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };

  static delete = async (id: string): Promise<void> => {
    await client.delete<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/userWorkingHour?id=${id}&culture=${culture}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
  };

  static create = async (workingHours: UserWorkingHoursRes): Promise<void> => {
    await client.post<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/userWorkingHour?culture=${culture}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: workingHours,
    });
  };

  static getAllWithDays = async (options?: {
    id?: string;
    page?: number;
    pageSize?: number;
    cookies?: Cookies;
    format?: string;
  }): Promise<DataPage> => {
    if (!options) {
      options = {
        id: "00000000-0000-0000-0000-000000000000",
        page: 1,
        pageSize: 20,
        format: "default",
      };
    }

    const {
      id = "00000000-0000-0000-0000-000000000000",
      page = 1,
      pageSize = 20,
      cookies,
      format,
    } = options;

    const { data } = await client.get<DataPage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/userWorkingHour?userId=${id}&page=${page}&pageSize=${pageSize}&culture=${culture}&format=${format}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };
}


### services/WorkingHoursService.ts ###
import { Cookies, HateoasPage } from "@fusion/network";
import client from "../network-client";
import { useUserStore } from "../stores/UserStore";

let culture = useUserStore.getState().preferredLanguage || "es";

useUserStore.subscribe((state) => {
  culture = state.preferredLanguage || "es";
});

export type WorkingHoursRes = {
  id?: string;
  name: string;
  timeBreakMinutes: number;
  timeLimitIssues: number;
  timeAutoCloseAfterMinutes: number;
  isDefault: boolean;
  companyId: string;
  workingHourDays: WorkingHourDay[];
};

export type WorkingHourDay = {
  name: string;
  workingHourId?: string;
  minutes: number;
  dayOfWeek: number;
  timeStart: string;
  timeEnd: string;
  marginTimeStartEnd?: string;
};

type DataPage = {
  data: WorkingHoursRes[];
};

export type WorkingHoursPage = HateoasPage<WorkingHoursRes>;

export default class WorkingHoursService {
  static getAll = async (options?: {
    page?: number;
    pageSize?: number;
    cookies?: Cookies;
    format?: string;
  }): Promise<WorkingHoursPage> => {
    if (!options) {
      options = {
        page: 1,
        pageSize: 20,
        format: "default",
      };
    }

    const { page = 1, pageSize = 20, cookies, format } = options;

    const { data } = await client.get<WorkingHoursPage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/workingHour?page=${page}&pageSize=${pageSize}&culture=${culture}&format=${format}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };

  static getAllWithId = async (options?: {
    page?: number;
    pageSize?: number;
    cookies?: Cookies;
    format?: string;
  }): Promise<DataPage> => {
    if (!options) {
      options = {
        page: 1,
        pageSize: 20,
        format: "default",
      };
    }

    const { page = 1, pageSize = 20, cookies, format } = options;

    const { data } = await client.get<DataPage>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/workingHour?page=${page}&pageSize=${pageSize}&culture=${culture}&format=${format}`,
        cookies: cookies,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });

    return data;
  };

  static delete = async (id: string): Promise<void> => {
    await client.delete<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/workingHour?id=${id}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
    });
  };

  static create = async (workingHours: WorkingHoursRes): Promise<void> => {
    await client.post<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/workingHour?culture=${culture}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: workingHours,
    });
  };

  static update = async (
    id: string,
    workingHours: WorkingHoursRes
  ): Promise<void> => {
    await client.put<void>({
      request: {
        url: `${process.env.NEXT_PUBLIC_WEB_URL}/api/workingHour?id=${id}&culture=${culture}`,
        headers: new Headers({
          "Content-Type": "application/json",
        }),
      },
      body: workingHours,
    });
  };
}


### stores/UserStore.ts ###
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { EntryTypeResponse } from "../services/EntryTypeService";

type UserStore = {
  id?: string;
  name?: string;
  lastName?: string;
  email?: string;
  cookieConsentAccepted?: boolean;
  preferredLanguage?: string;
  roles?: string[];
  tenantId?: string;
  entryTypes?: EntryTypeResponse[];
  setId: (id?: string) => void;
  setName: (name?: string, lastName?: string) => void;
  setEmail: (email?: string) => void;
  setCookieConsentAccepted: (cookieConsentAccepted?: boolean) => void;
  setPreferredLanguage: (preferredLanguage?: string) => void;
  setRoles: (roles?: string[]) => void;
  setTenantId: (tenantId?: string) => void;
  setEntryTypes: (entryTypes?: EntryTypeResponse[]) => void;
};

const useUserStore = create(
  persist<UserStore>(
    (set) => ({
      setId: (id) => {
        set({
          id,
        });
      },
      setName: (name, lastName) => {
        set({
          name,
          lastName,
        });
      },
      setEmail: (email) => {
        set({
          email,
        });
      },
      setCookieConsentAccepted: (cookieConsentAccepted?: boolean) => {
        set({
          cookieConsentAccepted,
        });
      },
      setPreferredLanguage: (preferredLanguage?: string) => {
        set({
          preferredLanguage,
        });
      },
      setRoles: (roles?: string[]) => {
        set({
          roles,
        });
      },
      setTenantId: (tenantId?: string) => {
        set({
          tenantId,
        });
      },
      setEntryTypes: (entryTypes?: EntryTypeResponse[]) => {
        set({
          entryTypes,
        });
      },
    }),
    { name: process.env.NEXT_PUBLIC_GLOBAL_STATE_KEY || "state" }
  )
);

export { useUserStore };


### styles/forms.css ###
[type="text"]:focus {
  --tw-ring-color: transparent;
}

/* HTML Editor component - DevExtreme */
.dx-htmleditor.dx-htmleditor-outlined.dx-state-active,
.dx-htmleditor.dx-htmleditor-outlined.dx-state-focused {
  border-color: var(--primary-500) !important;
  --tw-ring-color: rgb(99 102 241);
  border-top-color: transparent !important;
  border-left-color: transparent !important;
  border-right-color: transparent !important;
  border-width: 2px;
}
.dx-htmleditor {
  border-color: var(--gray-300) !important;
  border-radius: 0px !important;
  background-color: var(--gray-50);
  border-top-color: transparent !important;
  border-left-color: transparent !important;
  border-right-color: transparent !important;
  border-width: 2px !important;
}
/* End HTML Editor component - DevExtreme */

/* Tag Box component - DevExtreme */
.dx-tag-content {
  background-color: #e5e5e5;
}
.dx-tag-content span {
  color: #171717;
}

.dx-tag-remove-button::after,
.dx-tag-remove-button::before {
  background-color: #171717 !important;
}
.dx-tag .dx-tag-content {
  border-radius: 4px;
}
.dx-list:not(.dx-list-select-decorator-enabled)
  .dx-list-item.dx-list-item-selected {
  background-color: white !important;
}
.dx-list:not(.dx-list-select-decorator-enabled) .dx-list-item.dx-state-hover {
  background-color: #f5f5f5 !important;
}

.dx-list:not(.dx-list-select-decorator-enabled) .dx-list-item.dx-state-active {
  background-color: #e5e5e5 !important;
  color: #171717 !important;
}

.dx-selectbox.dx-texteditor.dx-state-hover,
.dx-selectbox.dx-texteditor {
  border: transparent !important;
}

.dx-texteditor-input {
  background-color: transparent !important;
}
.dx-texteditor-input:focus {
  --tw-ring-color: transparent !important;
}

/* End Tag Box component - DevExtreme */

/* Text Area */
textarea:focus {
  --tw-ring-color: transparent !important;
}


### styles/globals.css ###
@tailwind base;
@tailwind components;

#__next {
  @apply tw-h-full;
}

@tailwind utilities;

* {
  font-family: "Inter", sans-serif;
}

.dx-datagrid .dx-column-lines > td {
  border-right: 0px;
  border-left: 0px;
}

.dx-datagrid-borders > .dx-datagrid-rowsview,
.dx-datagrid-borders > .dx-datagrid-total-footer {
  border-bottom: 0px;
}

.dx-datagrid-rowsview .dx-row,
.dx-datagrid-headers .dx-datagrid-table .dx-row > td {
  border-bottom: 1px solid #eaeaea;
}

.dx-gridbase-container > .dx-datagrid-rowsview.dx-scrollable {
  padding-left: 4px;
  padding-right: 4px;
}

.dx-datagrid,
.dx-toolbar,
.dx-editor-cell .dx-texteditor,
.dx-editor-cell .dx-texteditor .dx-texteditor-input {
  background-color: transparent;
}

.dx-datagrid-headers,
.dx-datagrid-rowsview,
.dx-datagrid-borders > .dx-datagrid-pager {
  background-color: white;
}

.dx-datagrid-rowsview {
  border-top: 0px;
}

/* Adds borders to the footer (pager) */
.dx-datagrid-borders > .dx-datagrid-pager {
  border-left: 1px solid #ddd;
  border-right: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

/* Rounded borders */
.dx-datagrid-headers {
  border-top-left-radius: 6px;
  border-top-right-radius: 6px;
}
.dx-datagrid-borders > .dx-datagrid-pager {
  border-bottom-left-radius: 6px;
  border-bottom-right-radius: 6px;
}

.dx-datagrid-table.dx-datagrid-table-fixed {
  border-bottom: 0px;
}

.uppy-Root {
  display: none;
}

.uppy-Container .uppy-Root {
  display: block;
}

.calendar.hide-header .dx-calendar-navigator {
  display: none;
}
 
.calendar.hide-left-arrow .dx-calendar-navigator-previous-month {
  display: none;
}
 
.calendar.hide-right-arrow .dx-calendar-navigator-next-month {
  display: none;
}


### styles/variables.css ###
:root {
  --primary-100: #e0e7ff;
  --primary-200: #c7d2fe;
  --primary-300: #a5b4fc;
  --primary-400: #818cf8;
  --primary-500: #6366f1;
  --primary-600: #4f46e5;
  --primary-700: #4338ca;
  --primary-800: #3730a3;
  --primary-900: #312e81;

  --gray-50: #fafafa;
  --gray-100: #f5f5f5;
  --gray-200: #e5e5e5;
  --gray-300: #d4d4d4;
  --gray-400: #a3a3a3;
  --gray-500: #737373;
  --gray-600: #525252;
  --gray-700: #404040;
  --gray-800: #262626;
  --gray-900: #171717;
}


### tailwind.config.js ###
const { withFusion } = require("@fusion/theme");
const colors = require("tailwindcss/colors");

delete colors["lightBlue"];
delete colors["warmGray"];
delete colors["trueGray"];
delete colors["coolGray"];
delete colors["blueGray"];

/** @type {import('tailwindcss').Config} */
module.exports = withFusion({
  content: [
    "./pages/**/*.{js,ts,jsx,tsx}",
    "./components/**/*.{js,ts,jsx,tsx}",
    "./hooks/**/*.{js,ts,jsx,tsx}",
    "./node_modules/@fusion/**/*.{js,ts,jsx,tsx}",
  ],
  prefix: "tw-",
  safelist: [
    {
      pattern:
        /text-(primary|red|orange|amber|yellow|lime|green|emerald|teal|cyan|sky|blue|indigo|violet|purple|fuchsia|pink|rose)-(400|500|800|600|900)/,
      variants: ["hover"],
    },
    {
      pattern:
        /border-(primary|red|orange|amber|yellow|lime|green|emerald|teal|cyan|sky|blue|indigo|violet|purple|fuchsia|pink|rose)-(300|400|500)/,
      variants: ["focus-within"],
    },
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: "#f0f8e7",
          100: "#dae5cb",
          200: "#c3d2ac",
          300: "#abc08c",
          400: "#93ae6c",
          500: "#799452",
          600: "#5e733f",
          700: "#43522c",
          800: "#273118",
          900: "#0a1100",
        },
      },
    },
    // screens: {
    //   "max-md": { max: "768px" },
    //   // => @media (max-width: 768px) { ... }

    //   xl: "1280px",
    //   // => @media (min-width: 1280px) { ... }

    //   lg: "1024px",
    //   // => @media (min-width: 1024px) { ... }

    //   md: "768px",
    //   // => @media (min-width: 768px) { ... }

    //   sm: "640px",
    //   // => @media (min-width: 640px) { ... }
    // },
  },
  plugins: [require("@tailwindcss/forms")],
});


### tsconfig.json ###
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "downlevelIteration": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", "./*.ts"],
  "exclude": ["node_modules"]
}


